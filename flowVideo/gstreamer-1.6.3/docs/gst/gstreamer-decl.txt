<MACRO>
<NAME>GST_TYPE_CLOCK</NAME>
#define GST_TYPE_CLOCK                  (gst_clock_get_type ())
</MACRO>
<MACRO>
<NAME>GST_CLOCK</NAME>
#define GST_CLOCK(clock)                (G_TYPE_CHECK_INSTANCE_CAST ((clock), GST_TYPE_CLOCK, GstClock))
</MACRO>
<MACRO>
<NAME>GST_IS_CLOCK</NAME>
#define GST_IS_CLOCK(clock)             (G_TYPE_CHECK_INSTANCE_TYPE ((clock), GST_TYPE_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_CLOCK_CLASS</NAME>
#define GST_CLOCK_CLASS(cclass)         (G_TYPE_CHECK_CLASS_CAST ((cclass), GST_TYPE_CLOCK, GstClockClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CLOCK_CLASS</NAME>
#define GST_IS_CLOCK_CLASS(cclass)      (G_TYPE_CHECK_CLASS_TYPE ((cclass), GST_TYPE_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_CLOCK_GET_CLASS</NAME>
#define GST_CLOCK_GET_CLASS(clock)      (G_TYPE_INSTANCE_GET_CLASS ((clock), GST_TYPE_CLOCK, GstClockClass))
</MACRO>
<MACRO>
<NAME>GST_CLOCK_CAST</NAME>
#define GST_CLOCK_CAST(clock)           ((GstClock*)(clock))
</MACRO>
<TYPEDEF>
<NAME>GstClockTime</NAME>
typedef guint64 GstClockTime;
</TYPEDEF>
<MACRO>
<NAME>GST_TYPE_CLOCK_TIME</NAME>
#define GST_TYPE_CLOCK_TIME G_TYPE_UINT64
</MACRO>
<TYPEDEF>
<NAME>GstClockTimeDiff</NAME>
typedef gint64 GstClockTimeDiff;
</TYPEDEF>
<TYPEDEF>
<NAME>GstClockID</NAME>
typedef gpointer GstClockID;
</TYPEDEF>
<MACRO>
<NAME>GST_CLOCK_TIME_NONE</NAME>
#define GST_CLOCK_TIME_NONE             ((GstClockTime) -1)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_TIME_IS_VALID</NAME>
#define GST_CLOCK_TIME_IS_VALID(time)   (((GstClockTime)(time)) != GST_CLOCK_TIME_NONE)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_STIME_NONE</NAME>
#define GST_CLOCK_STIME_NONE             G_MININT64
</MACRO>
<MACRO>
<NAME>GST_CLOCK_STIME_IS_VALID</NAME>
#define GST_CLOCK_STIME_IS_VALID(time)   (((GstClockTimeDiff)(time)) != GST_CLOCK_STIME_NONE)
</MACRO>
<MACRO>
<NAME>GST_SECOND</NAME>
#define GST_SECOND  (G_USEC_PER_SEC * G_GINT64_CONSTANT (1000))
</MACRO>
<MACRO>
<NAME>GST_MSECOND</NAME>
#define GST_MSECOND (GST_SECOND / G_GINT64_CONSTANT (1000))
</MACRO>
<MACRO>
<NAME>GST_USECOND</NAME>
#define GST_USECOND (GST_SECOND / G_GINT64_CONSTANT (1000000))
</MACRO>
<MACRO>
<NAME>GST_NSECOND</NAME>
#define GST_NSECOND (GST_SECOND / G_GINT64_CONSTANT (1000000000))
</MACRO>
<MACRO>
<NAME>GST_TIME_AS_SECONDS</NAME>
#define GST_TIME_AS_SECONDS(time)  ((time) / GST_SECOND)
</MACRO>
<MACRO>
<NAME>GST_TIME_AS_MSECONDS</NAME>
#define GST_TIME_AS_MSECONDS(time) ((time) / G_GINT64_CONSTANT (1000000))
</MACRO>
<MACRO>
<NAME>GST_TIME_AS_USECONDS</NAME>
#define GST_TIME_AS_USECONDS(time) ((time) / G_GINT64_CONSTANT (1000))
</MACRO>
<MACRO>
<NAME>GST_TIME_AS_NSECONDS</NAME>
#define GST_TIME_AS_NSECONDS(time) (time)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_DIFF</NAME>
#define GST_CLOCK_DIFF(s, e)            (GstClockTimeDiff)((e) - (s))
</MACRO>
<MACRO>
<NAME>GST_TIMEVAL_TO_TIME</NAME>
#define GST_TIMEVAL_TO_TIME(tv)         (GstClockTime)((tv).tv_sec * GST_SECOND + (tv).tv_usec * GST_USECOND)
</MACRO>
<MACRO>
<NAME>GST_TIME_TO_TIMEVAL</NAME>
#define GST_TIME_TO_TIMEVAL(t,tv)                               \
G_STMT_START {                                                  \
  g_assert ("Value of time " #t " is out of timeval's range" && \
      ((t) / GST_SECOND) < G_MAXLONG);                          \
  (tv).tv_sec  = (glong) (((GstClockTime) (t)) / GST_SECOND);   \
  (tv).tv_usec = (glong) ((((GstClockTime) (t)) -               \
                  ((GstClockTime) (tv).tv_sec) * GST_SECOND)    \
                 / GST_USECOND);                                \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_TIMESPEC_TO_TIME</NAME>
#define GST_TIMESPEC_TO_TIME(ts)        (GstClockTime)((ts).tv_sec * GST_SECOND + (ts).tv_nsec * GST_NSECOND)
</MACRO>
<MACRO>
<NAME>GST_TIME_TO_TIMESPEC</NAME>
#define GST_TIME_TO_TIMESPEC(t,ts)                                \
G_STMT_START {                                                    \
  g_assert ("Value of time " #t " is out of timespec's range" &&  \
      ((t) / GST_SECOND) < G_MAXLONG);                            \
  (ts).tv_sec  =  (glong) ((t) / GST_SECOND);                     \
  (ts).tv_nsec = (glong) (((t) - (ts).tv_sec * GST_SECOND) / GST_NSECOND);        \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_TIME_FORMAT</NAME>
#define GST_TIME_FORMAT "u:%02u:%02u.%09u"
</MACRO>
<MACRO>
<NAME>GST_TIME_ARGS</NAME>
#define GST_TIME_ARGS(t) \
        GST_CLOCK_TIME_IS_VALID (t) ? \
        (guint) (((GstClockTime)(t)) / (GST_SECOND * 60 * 60)) : 99, \
        GST_CLOCK_TIME_IS_VALID (t) ? \
        (guint) ((((GstClockTime)(t)) / (GST_SECOND * 60)) % 60) : 99, \
        GST_CLOCK_TIME_IS_VALID (t) ? \
        (guint) ((((GstClockTime)(t)) / GST_SECOND) % 60) : 99, \
        GST_CLOCK_TIME_IS_VALID (t) ? \
        (guint) (((GstClockTime)(t)) % GST_SECOND) : 999999999
</MACRO>
<MACRO>
<NAME>GST_STIME_FORMAT</NAME>
#define GST_STIME_FORMAT "c%" GST_TIME_FORMAT
</MACRO>
<MACRO>
<NAME>GST_STIME_ARGS</NAME>
#define GST_STIME_ARGS(t) \
          ((t) >= 0) ? ' ' : '-', GST_TIME_ARGS (ABS (t))
</MACRO>
<USER_FUNCTION>
<NAME>GstClockCallback</NAME>
<RETURNS>gboolean </RETURNS>
GstClock *clock, GstClockTime time,
                                                 GstClockID id, gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstClockReturn</NAME>
typedef enum
{
  GST_CLOCK_OK          =  0,
  GST_CLOCK_EARLY       =  1,
  GST_CLOCK_UNSCHEDULED =  2,
  GST_CLOCK_BUSY        =  3,
  GST_CLOCK_BADTIME     =  4,
  GST_CLOCK_ERROR       =  5,
  GST_CLOCK_UNSUPPORTED =  6,
  GST_CLOCK_DONE        =  7
} GstClockReturn;
</ENUM>
<ENUM>
<NAME>GstClockEntryType</NAME>
typedef enum {
  GST_CLOCK_ENTRY_SINGLE,
  GST_CLOCK_ENTRY_PERIODIC
} GstClockEntryType;
</ENUM>
<MACRO>
<NAME>GST_CLOCK_ENTRY</NAME>
#define GST_CLOCK_ENTRY(entry)          ((GstClockEntry *)(entry))
</MACRO>
<MACRO>
<NAME>GST_CLOCK_ENTRY_CLOCK</NAME>
#define GST_CLOCK_ENTRY_CLOCK(entry)    ((entry)->clock)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_ENTRY_TYPE</NAME>
#define GST_CLOCK_ENTRY_TYPE(entry)     ((entry)->type)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_ENTRY_TIME</NAME>
#define GST_CLOCK_ENTRY_TIME(entry)     ((entry)->time)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_ENTRY_INTERVAL</NAME>
#define GST_CLOCK_ENTRY_INTERVAL(entry) ((entry)->interval)
</MACRO>
<MACRO>
<NAME>GST_CLOCK_ENTRY_STATUS</NAME>
#define GST_CLOCK_ENTRY_STATUS(entry)   ((entry)->status)
</MACRO>
<STRUCT>
<NAME>GstClockEntry</NAME>
struct _GstClockEntry {
  gint                  refcount;
  /*< protected >*/
  GstClock              *clock;
  GstClockEntryType      type;
  GstClockTime           time;
  GstClockTime           interval;
  GstClockReturn         status;
  GstClockCallback       func;
  gpointer               user_data;
  GDestroyNotify         destroy_data;
  gboolean               unscheduled;
  gboolean               woken_up;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<ENUM>
<NAME>GstClockFlags</NAME>
typedef enum {
  GST_CLOCK_FLAG_CAN_DO_SINGLE_SYNC     = (GST_OBJECT_FLAG_LAST << 0),
  GST_CLOCK_FLAG_CAN_DO_SINGLE_ASYNC    = (GST_OBJECT_FLAG_LAST << 1),
  GST_CLOCK_FLAG_CAN_DO_PERIODIC_SYNC   = (GST_OBJECT_FLAG_LAST << 2),
  GST_CLOCK_FLAG_CAN_DO_PERIODIC_ASYNC  = (GST_OBJECT_FLAG_LAST << 3),
  GST_CLOCK_FLAG_CAN_SET_RESOLUTION     = (GST_OBJECT_FLAG_LAST << 4),
  GST_CLOCK_FLAG_CAN_SET_MASTER         = (GST_OBJECT_FLAG_LAST << 5),
  GST_CLOCK_FLAG_NEEDS_STARTUP_SYNC     = (GST_OBJECT_FLAG_LAST << 6),
  /* padding */
  GST_CLOCK_FLAG_LAST                   = (GST_OBJECT_FLAG_LAST << 8)
} GstClockFlags;
</ENUM>
<MACRO>
<NAME>GST_CLOCK_FLAGS</NAME>
#define GST_CLOCK_FLAGS(clock)  GST_OBJECT_FLAGS(clock)
</MACRO>
<STRUCT>
<NAME>GstClock</NAME>
struct _GstClock {
  GstObject      object;

  /*< private >*/
  GstClockPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstClockClass</NAME>
struct _GstClockClass {
  GstObjectClass        parent_class;

  /*< public >*/
  /* vtable */
  GstClockTime          (*change_resolution)    (GstClock *clock,
                                                 GstClockTime old_resolution,
                                                 GstClockTime new_resolution);
  GstClockTime          (*get_resolution)       (GstClock *clock);

  GstClockTime          (*get_internal_time)    (GstClock *clock);

  /* waiting on an ID */
  GstClockReturn        (*wait)                 (GstClock *clock, GstClockEntry *entry,
                                                 GstClockTimeDiff *jitter);
  GstClockReturn        (*wait_async)           (GstClock *clock, GstClockEntry *entry);
  void                  (*unschedule)           (GstClock *clock, GstClockEntry *entry);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_clock_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_set_resolution</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock, GstClockTime resolution
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_resolution</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_time</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_set_calibration</NAME>
<RETURNS>void                     </RETURNS>
GstClock *clock, GstClockTime internal, GstClockTime external, GstClockTime rate_num, GstClockTime rate_denom
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_calibration</NAME>
<RETURNS>void                     </RETURNS>
GstClock *clock, GstClockTime *internal, GstClockTime *external, GstClockTime *rate_num, GstClockTime *rate_denom
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_set_master</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock *clock, GstClock *master
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_master</NAME>
<RETURNS>GstClock *               </RETURNS>
GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_set_timeout</NAME>
<RETURNS>void                     </RETURNS>
GstClock *clock, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_timeout</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_add_observation</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock *clock, GstClockTime slave, GstClockTime master, gdouble *r_squared
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_add_observation_unapplied</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock *clock, GstClockTime slave, GstClockTime master, gdouble *r_squared, GstClockTime *internal, GstClockTime *external, GstClockTime *rate_num, GstClockTime *rate_denom
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_get_internal_time</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_adjust_unlocked</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock, GstClockTime internal
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_adjust_with_calibration</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock *clock, GstClockTime internal_target, GstClockTime cinternal, GstClockTime cexternal, GstClockTime cnum, GstClockTime cdenom
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_unadjust_unlocked</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClock * clock, GstClockTime external
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_wait_for_sync</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock * clock, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_is_synced</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock * clock
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_set_synced</NAME>
<RETURNS>void                     </RETURNS>
GstClock * clock, gboolean synced
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_new_single_shot_id</NAME>
<RETURNS>GstClockID               </RETURNS>
GstClock *clock, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_new_periodic_id</NAME>
<RETURNS>GstClockID               </RETURNS>
GstClock *clock, GstClockTime start_time, GstClockTime interval
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_ref</NAME>
<RETURNS>GstClockID               </RETURNS>
GstClockID id
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_unref</NAME>
<RETURNS>void                     </RETURNS>
GstClockID id
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_compare_func</NAME>
<RETURNS>gint                     </RETURNS>
gconstpointer id1, gconstpointer id2
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_get_time</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstClockID id
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_wait</NAME>
<RETURNS>GstClockReturn           </RETURNS>
GstClockID id, GstClockTimeDiff *jitter
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_wait_async</NAME>
<RETURNS>GstClockReturn           </RETURNS>
GstClockID id, GstClockCallback func, gpointer user_data, GDestroyNotify destroy_data
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_id_unschedule</NAME>
<RETURNS>void                     </RETURNS>
GstClockID id
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_single_shot_id_reinit</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock * clock, GstClockID id, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>gst_clock_periodic_id_reinit</NAME>
<RETURNS>gboolean                 </RETURNS>
GstClock * clock, GstClockID id, GstClockTime start_time, GstClockTime interval
</FUNCTION>
<STRUCT>
<NAME>GstClockPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_REGISTRY</NAME>
#define GST_TYPE_REGISTRY               (gst_registry_get_type ())
</MACRO>
<MACRO>
<NAME>GST_REGISTRY</NAME>
#define GST_REGISTRY(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_REGISTRY, GstRegistry))
</MACRO>
<MACRO>
<NAME>GST_IS_REGISTRY</NAME>
#define GST_IS_REGISTRY(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>GST_REGISTRY_CLASS</NAME>
#define GST_REGISTRY_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_REGISTRY, GstRegistryClass))
</MACRO>
<MACRO>
<NAME>GST_IS_REGISTRY_CLASS</NAME>
#define GST_IS_REGISTRY_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_REGISTRY))
</MACRO>
<MACRO>
<NAME>GST_REGISTRY_GET_CLASS</NAME>
#define GST_REGISTRY_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_REGISTRY, GstRegistryClass))
</MACRO>
<STRUCT>
<NAME>GstRegistry</NAME>
struct _GstRegistry {
  GstObject      object;

  /*< private >*/
  GstRegistryPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstRegistryClass</NAME>
struct _GstRegistryClass {
  GstObjectClass        parent_class;
};
</STRUCT>
<FUNCTION>
<NAME>gst_registry_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get</NAME>
<RETURNS>GstRegistry  *           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_scan_path</NAME>
<RETURNS>gboolean                 </RETURNS>
GstRegistry *registry, const gchar *path
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_add_path</NAME>
<RETURNS>void                     </RETURNS>
GstRegistry * registry, const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get_path_list</NAME>
<RETURNS>GList *                  </RETURNS>
GstRegistry *registry
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_add_plugin</NAME>
<RETURNS>gboolean                 </RETURNS>
GstRegistry *registry, GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_remove_plugin</NAME>
<RETURNS>void                     </RETURNS>
GstRegistry *registry, GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_add_feature</NAME>
<RETURNS>gboolean                 </RETURNS>
GstRegistry * registry, GstPluginFeature * feature
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_remove_feature</NAME>
<RETURNS>void                     </RETURNS>
GstRegistry * registry, GstPluginFeature * feature
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get_plugin_list</NAME>
<RETURNS>GList *                  </RETURNS>
GstRegistry *registry
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_plugin_filter</NAME>
<RETURNS>GList *                  </RETURNS>
GstRegistry *registry, GstPluginFilter filter, gboolean first, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_feature_filter</NAME>
<RETURNS>GList *                  </RETURNS>
GstRegistry *registry, GstPluginFeatureFilter filter, gboolean first, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get_feature_list</NAME>
<RETURNS>GList  *                 </RETURNS>
GstRegistry *registry, GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get_feature_list_by_plugin</NAME>
<RETURNS>GList  *                 </RETURNS>
GstRegistry *registry, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_get_feature_list_cookie</NAME>
<RETURNS>guint32                  </RETURNS>
GstRegistry *registry
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_find_plugin</NAME>
<RETURNS>GstPlugin *              </RETURNS>
GstRegistry *registry, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_find_feature</NAME>
<RETURNS>GstPluginFeature *       </RETURNS>
GstRegistry *registry, const gchar *name, GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_lookup</NAME>
<RETURNS>GstPlugin  *             </RETURNS>
GstRegistry *registry, const char *filename
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_lookup_feature</NAME>
<RETURNS>GstPluginFeature  *      </RETURNS>
GstRegistry *registry, const char *name
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_check_feature_version</NAME>
<RETURNS>gboolean                 </RETURNS>
GstRegistry *registry, const gchar *feature_name, guint        min_major, guint        min_minor, guint        min_micro
</FUNCTION>
<STRUCT>
<NAME>GstRegistryPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_CHILD_PROXY</NAME>
#define GST_TYPE_CHILD_PROXY               (gst_child_proxy_get_type ())
</MACRO>
<MACRO>
<NAME>GST_CHILD_PROXY</NAME>
#define GST_CHILD_PROXY(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_CHILD_PROXY, GstChildProxy))
</MACRO>
<MACRO>
<NAME>GST_IS_CHILD_PROXY</NAME>
#define GST_IS_CHILD_PROXY(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_CHILD_PROXY))
</MACRO>
<MACRO>
<NAME>GST_CHILD_PROXY_GET_INTERFACE</NAME>
#define GST_CHILD_PROXY_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_CHILD_PROXY, GstChildProxyInterface))
</MACRO>
<STRUCT>
<NAME>GstChildProxyInterface</NAME>
struct _GstChildProxyInterface
{
  GTypeInterface parent;

  /* methods */
  GObject * (*get_child_by_name)  (GstChildProxy * parent, const gchar * name);
  GObject * (*get_child_by_index) (GstChildProxy * parent, guint index);
  guint     (*get_children_count) (GstChildProxy * parent);
  /*< private >*/
  /* signals */
  void      (*child_added)        (GstChildProxy * parent, GObject * child, const gchar * name);
  void      (*child_removed)      (GstChildProxy * parent, GObject * child, const gchar * name);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_child_proxy_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get_child_by_name</NAME>
<RETURNS>GObject  * </RETURNS>
GstChildProxy * parent, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get_children_count</NAME>
<RETURNS>guint      </RETURNS>
GstChildProxy * parent
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get_child_by_index</NAME>
<RETURNS>GObject  * </RETURNS>
GstChildProxy * parent, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_lookup</NAME>
<RETURNS>gboolean   </RETURNS>
GstChildProxy *object, const gchar *name, GObject **target, GParamSpec **pspec
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get_property</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * object, const gchar *name, GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get_valist</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * object, const gchar * first_property_name, va_list var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_get</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * object, const gchar * first_property_name, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_set_property</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * object, const gchar *name, const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_set_valist</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy* object, const gchar * first_property_name, va_list var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_set</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * object, const gchar * first_property_name, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_child_added</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * parent, GObject * child, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_child_proxy_child_removed</NAME>
<RETURNS>void       </RETURNS>
GstChildProxy * parent, GObject * child, const gchar *name
</FUNCTION>
<STRUCT>
<NAME>GstChildProxy</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_plugin_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_PLUGIN_ERROR</NAME>
#define GST_PLUGIN_ERROR gst_plugin_error_quark ()
</MACRO>
<ENUM>
<NAME>GstPluginError</NAME>
typedef enum
{
  GST_PLUGIN_ERROR_MODULE,
  GST_PLUGIN_ERROR_DEPENDENCIES,
  GST_PLUGIN_ERROR_NAME_MISMATCH
} GstPluginError;
</ENUM>
<ENUM>
<NAME>GstPluginFlags</NAME>
typedef enum
{
  GST_PLUGIN_FLAG_CACHED      = (GST_OBJECT_FLAG_LAST << 0),
  GST_PLUGIN_FLAG_BLACKLISTED = (GST_OBJECT_FLAG_LAST << 1)
} GstPluginFlags;
</ENUM>
<ENUM>
<NAME>GstPluginDependencyFlags</NAME>
typedef enum {
  GST_PLUGIN_DEPENDENCY_FLAG_NONE = 0,
  GST_PLUGIN_DEPENDENCY_FLAG_RECURSE = (1 << 0),
  GST_PLUGIN_DEPENDENCY_FLAG_PATHS_ARE_DEFAULT_ONLY = (1 << 1),
  GST_PLUGIN_DEPENDENCY_FLAG_FILE_NAME_IS_SUFFIX = (1 << 2)
} GstPluginDependencyFlags;
</ENUM>
<USER_FUNCTION>
<NAME>GstPluginInitFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin *plugin
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPluginInitFullFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin *plugin, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstPluginDesc</NAME>
struct _GstPluginDesc {
  gint major_version;
  gint minor_version;
  const gchar *name;
  const gchar *description;
  GstPluginInitFunc plugin_init;
  const gchar *version;
  const gchar *license;
  const gchar *source;
  const gchar *package;
  const gchar *origin;
  const gchar *release_datetime;
  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PLUGIN</NAME>
#define GST_TYPE_PLUGIN   (gst_plugin_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_PLUGIN</NAME>
#define GST_IS_PLUGIN(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLUGIN))
</MACRO>
<MACRO>
<NAME>GST_IS_PLUGIN_CLASS</NAME>
#define GST_IS_PLUGIN_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLUGIN))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_GET_CLASS</NAME>
#define GST_PLUGIN_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PLUGIN, GstPluginClass))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN</NAME>
#define GST_PLUGIN(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLUGIN, GstPlugin))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_CLASS</NAME>
#define GST_PLUGIN_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PLUGIN, GstPluginClass))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_CAST</NAME>
#define GST_PLUGIN_CAST(obj)           ((GstPlugin*)(obj))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_STATIC_DECLARE</NAME>
#define GST_PLUGIN_STATIC_DECLARE(name) \
  extern void G_PASTE(gst_plugin_, G_PASTE(name, _register)) (void)
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_STATIC_REGISTER</NAME>
#define GST_PLUGIN_STATIC_REGISTER(name) G_PASTE(gst_plugin_, G_PASTE(name, _register)) ()
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_DEFINE</NAME>
#define GST_PLUGIN_DEFINE(major,minor,name,description,init,version,license,package,origin)	\
G_BEGIN_DECLS						\
GST_PLUGIN_EXPORT void G_PASTE(gst_plugin_, G_PASTE(name, _register)) (void);			\
							\
void							\
G_PASTE(gst_plugin_, G_PASTE(name, _register)) (void)	\
{							\
  gst_plugin_register_static (major, minor, G_STRINGIFY(name),	\
      description, init, version, license,		\
      PACKAGE, package, origin);			\
}							\
G_END_DECLS
</MACRO>
<MACRO>
<NAME>GST_LICENSE_UNKNOWN</NAME>
#define GST_LICENSE_UNKNOWN "unknown"
</MACRO>
<USER_FUNCTION>
<NAME>GstPluginFilter</NAME>
<RETURNS>gboolean </RETURNS>
GstPlugin *plugin,
                                                         gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_register_static</NAME>
<RETURNS>gboolean 		</RETURNS>
gint major_version, gint minor_version, const gchar *name, const gchar *description, GstPluginInitFunc init_func, const gchar *version, const gchar *license, const gchar *source, const gchar *package, const gchar *origin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_register_static_full</NAME>
<RETURNS>gboolean 		</RETURNS>
gint major_version, gint minor_version, const gchar *name, const gchar *description, GstPluginInitFullFunc init_full_func, const gchar *version, const gchar *license, const gchar *source, const gchar *package, const gchar *origin, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_name</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_description</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_filename</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_version</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_license</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_source</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_package</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_origin</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_release_date_string</NAME>
<RETURNS>const gchar *		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_get_cache_data</NAME>
<RETURNS>const GstStructure *	</RETURNS>
GstPlugin * plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_set_cache_data</NAME>
<RETURNS>void 			</RETURNS>
GstPlugin * plugin, GstStructure *cache_data
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_is_loaded</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_load_file</NAME>
<RETURNS>GstPlugin  *		</RETURNS>
const gchar *filename, GError** error
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_load</NAME>
<RETURNS>GstPlugin  *             </RETURNS>
GstPlugin *plugin
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_load_by_name</NAME>
<RETURNS>GstPlugin  *             </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_add_dependency</NAME>
<RETURNS>void                     </RETURNS>
GstPlugin    * plugin, const gchar ** env_vars, const gchar ** paths, const gchar ** names, GstPluginDependencyFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_add_dependency_simple</NAME>
<RETURNS>void                     </RETURNS>
GstPlugin   * plugin, const gchar * env_vars, const gchar * paths, const gchar * names, GstPluginDependencyFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_list_free</NAME>
<RETURNS>void  </RETURNS>
GList *list
</FUNCTION>
<STRUCT>
<NAME>GstPlugin</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPluginClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_BUFFER_LIST</NAME>
#define GST_TYPE_BUFFER_LIST      (_gst_buffer_list_type)
</MACRO>
<MACRO>
<NAME>GST_IS_BUFFER_LIST</NAME>
#define GST_IS_BUFFER_LIST(obj)   (GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER_LIST))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_LIST_CAST</NAME>
#define GST_BUFFER_LIST_CAST(obj) ((GstBufferList *)obj)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_LIST</NAME>
#define GST_BUFFER_LIST(obj)      (GST_BUFFER_LIST_CAST(obj))
</MACRO>
<USER_FUNCTION>
<NAME>GstBufferListFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstBuffer **buffer, guint idx,
                                           gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_ref</NAME>
<RETURNS>GstBufferList  * </RETURNS>
GstBufferList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_unref</NAME>
<RETURNS>void  </RETURNS>
GstBufferList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_copy</NAME>
<RETURNS>GstBufferList  * </RETURNS>
const GstBufferList * list
</FUNCTION>
<MACRO>
<NAME>gst_buffer_list_is_writable</NAME>
#define gst_buffer_list_is_writable(list) gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (list))
</MACRO>
<MACRO>
<NAME>gst_buffer_list_make_writable</NAME>
#define gst_buffer_list_make_writable(list) GST_BUFFER_LIST_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (list)))
</MACRO>
<FUNCTION>
<NAME>gst_buffer_list_get_type</NAME>
<RETURNS>GType                     </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_new</NAME>
<RETURNS>GstBufferList  *          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_new_sized</NAME>
<RETURNS>GstBufferList  *          </RETURNS>
guint size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_length</NAME>
<RETURNS>guint                     </RETURNS>
GstBufferList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_get</NAME>
<RETURNS>GstBuffer  *              </RETURNS>
GstBufferList *list, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_insert</NAME>
<RETURNS>void                      </RETURNS>
GstBufferList *list, gint idx, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_remove</NAME>
<RETURNS>void                      </RETURNS>
GstBufferList *list, guint idx, guint length
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_foreach</NAME>
<RETURNS>gboolean                  </RETURNS>
GstBufferList *list, GstBufferListFunc func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_list_copy_deep</NAME>
<RETURNS>GstBufferList  *          </RETURNS>
const GstBufferList * list
</FUNCTION>
<MACRO>
<NAME>gst_buffer_list_add</NAME>
#define gst_buffer_list_add(l,b) gst_buffer_list_insert((l),-1,(b));
</MACRO>
<STRUCT>
<NAME>GstBufferList</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_CONTROL_BINDING</NAME>
#define GST_TYPE_CONTROL_BINDING \
  (gst_control_binding_get_type())
</MACRO>
<MACRO>
<NAME>GST_CONTROL_BINDING</NAME>
#define GST_CONTROL_BINDING(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CONTROL_BINDING,GstControlBinding))
</MACRO>
<MACRO>
<NAME>GST_CONTROL_BINDING_CLASS</NAME>
#define GST_CONTROL_BINDING_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CONTROL_BINDING,GstControlBindingClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CONTROL_BINDING</NAME>
#define GST_IS_CONTROL_BINDING(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CONTROL_BINDING))
</MACRO>
<MACRO>
<NAME>GST_IS_CONTROL_BINDING_CLASS</NAME>
#define GST_IS_CONTROL_BINDING_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CONTROL_BINDING))
</MACRO>
<MACRO>
<NAME>GST_CONTROL_BINDING_GET_CLASS</NAME>
#define GST_CONTROL_BINDING_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_CONTOL_SOURCE, GstControlBindingClass))
</MACRO>
<USER_FUNCTION>
<NAME>GstControlBindingConvert</NAME>
<RETURNS>void </RETURNS>
GstControlBinding *binding, gdouble src_value, GValue *dest_value
</USER_FUNCTION>
<STRUCT>
<NAME>GstControlBinding</NAME>
struct _GstControlBinding {
  GstObject parent;
  
  /*< public >*/
  gchar *name;
  GParamSpec *pspec;

  /*< private >*/
  GstObject *object;            /* GstObject owning the property
                                 * (== parent when bound) */
  gboolean disabled;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstControlBindingClass</NAME>
struct _GstControlBindingClass
{
  GstObjectClass parent_class;

  /*< public >*/
  gboolean (* sync_values) (GstControlBinding *binding, GstObject *object, GstClockTime timestamp, GstClockTime last_sync);
  GValue * (* get_value) (GstControlBinding *binding, GstClockTime timestamp);
  gboolean (* get_value_array) (GstControlBinding *binding, GstClockTime timestamp,GstClockTime interval, guint n_values, gpointer values);
  gboolean (* get_g_value_array) (GstControlBinding *binding, GstClockTime timestamp,GstClockTime interval, guint n_values, GValue *values);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_CONTROL_BINDING_PSPEC</NAME>
#define GST_CONTROL_BINDING_PSPEC(cb) (((GstControlBinding *) cb)->pspec)
</MACRO>
<FUNCTION>
<NAME>gst_control_binding_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_sync_values</NAME>
<RETURNS>gboolean             </RETURNS>
GstControlBinding * binding, GstObject *object, GstClockTime timestamp, GstClockTime last_sync
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_get_value</NAME>
<RETURNS>GValue  *            </RETURNS>
GstControlBinding *binding, GstClockTime timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_get_value_array</NAME>
<RETURNS>gboolean             </RETURNS>
GstControlBinding *binding, GstClockTime timestamp, GstClockTime interval, guint n_values, gpointer values
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_get_g_value_array</NAME>
<RETURNS>gboolean             </RETURNS>
GstControlBinding *binding, GstClockTime timestamp, GstClockTime interval, guint n_values, GValue *values
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_set_disabled</NAME>
<RETURNS>void                 </RETURNS>
GstControlBinding * binding, gboolean disabled
</FUNCTION>
<FUNCTION>
<NAME>gst_control_binding_is_disabled</NAME>
<RETURNS>gboolean             </RETURNS>
GstControlBinding * binding
</FUNCTION>
<FUNCTION>
<NAME>gst_init</NAME>
<RETURNS>void 		</RETURNS>
int *argc, char **argv[]
</FUNCTION>
<FUNCTION>
<NAME>gst_init_check</NAME>
<RETURNS>gboolean 	</RETURNS>
int *argc, char **argv[], GError ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_is_initialized</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_init_get_option_group</NAME>
<RETURNS>GOptionGroup  *	</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_deinit</NAME>
<RETURNS>void 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_version</NAME>
<RETURNS>void 		</RETURNS>
guint *major, guint *minor, guint *micro, guint *nano
</FUNCTION>
<FUNCTION>
<NAME>gst_version_string</NAME>
<RETURNS>gchar  *		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_segtrap_is_enabled</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_segtrap_set_enabled</NAME>
<RETURNS>void             </RETURNS>
gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_fork_is_enabled</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_registry_fork_set_enabled</NAME>
<RETURNS>void             </RETURNS>
gboolean enabled
</FUNCTION>
<FUNCTION>
<NAME>gst_update_registry</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MEMORY</NAME>
#define GST_TYPE_MEMORY (_gst_memory_type)
</MACRO>
<FUNCTION>
<NAME>gst_memory_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_MEMORY_CAST</NAME>
#define GST_MEMORY_CAST(mem)   ((GstMemory *)(mem))
</MACRO>
<ENUM>
<NAME>GstMemoryFlags</NAME>
typedef enum {
  GST_MEMORY_FLAG_READONLY      = GST_MINI_OBJECT_FLAG_LOCK_READONLY,
  GST_MEMORY_FLAG_NO_SHARE      = (GST_MINI_OBJECT_FLAG_LAST << 0),
  GST_MEMORY_FLAG_ZERO_PREFIXED = (GST_MINI_OBJECT_FLAG_LAST << 1),
  GST_MEMORY_FLAG_ZERO_PADDED   = (GST_MINI_OBJECT_FLAG_LAST << 2),
  GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS = (GST_MINI_OBJECT_FLAG_LAST << 3),
  GST_MEMORY_FLAG_NOT_MAPPABLE  = (GST_MINI_OBJECT_FLAG_LAST << 4),

  GST_MEMORY_FLAG_LAST          = (GST_MINI_OBJECT_FLAG_LAST << 16)
} GstMemoryFlags;
</ENUM>
<MACRO>
<NAME>GST_MEMORY_FLAGS</NAME>
#define GST_MEMORY_FLAGS(mem)  GST_MINI_OBJECT_FLAGS (mem)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_FLAG_IS_SET</NAME>
#define GST_MEMORY_FLAG_IS_SET(mem,flag)   GST_MINI_OBJECT_FLAG_IS_SET (mem,flag)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_FLAG_UNSET</NAME>
#define GST_MEMORY_FLAG_UNSET(mem,flag)   GST_MINI_OBJECT_FLAG_UNSET (mem, flag)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_READONLY</NAME>
#define GST_MEMORY_IS_READONLY(mem)        GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_READONLY)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_NO_SHARE</NAME>
#define GST_MEMORY_IS_NO_SHARE(mem)        GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_NO_SHARE)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_ZERO_PREFIXED</NAME>
#define GST_MEMORY_IS_ZERO_PREFIXED(mem)   GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_ZERO_PREFIXED)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_ZERO_PADDED</NAME>
#define GST_MEMORY_IS_ZERO_PADDED(mem)     GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_ZERO_PADDED)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_PHYSICALLY_CONTIGUOUS</NAME>
#define GST_MEMORY_IS_PHYSICALLY_CONTIGUOUS(mem)     GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_PHYSICALLY_CONTIGUOUS)
</MACRO>
<MACRO>
<NAME>GST_MEMORY_IS_NOT_MAPPABLE</NAME>
#define GST_MEMORY_IS_NOT_MAPPABLE(mem)     GST_MEMORY_FLAG_IS_SET(mem,GST_MEMORY_FLAG_NOT_MAPPABLE)
</MACRO>
<STRUCT>
<NAME>GstMemory</NAME>
struct _GstMemory {
  GstMiniObject   mini_object;

  GstAllocator   *allocator;

  GstMemory      *parent;
  gsize           maxsize;
  gsize           align;
  gsize           offset;
  gsize           size;
};
</STRUCT>
<ENUM>
<NAME>GstMapFlags</NAME>
typedef enum {
  GST_MAP_READ      = GST_LOCK_FLAG_READ,
  GST_MAP_WRITE     = GST_LOCK_FLAG_WRITE,

  GST_MAP_FLAG_LAST = (1 << 16)
} GstMapFlags;
</ENUM>
<MACRO>
<NAME>GST_MAP_READWRITE</NAME>
#define GST_MAP_READWRITE      (GST_MAP_READ | GST_MAP_WRITE)
</MACRO>
<STRUCT>
<NAME>GstMapInfo</NAME>
typedef struct {
  GstMemory *memory;
  GstMapFlags flags;
  guint8 *data;
  gsize size;
  gsize maxsize;
  /*< protected >*/
  gpointer user_data[4];

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
} GstMapInfo;
</STRUCT>
<MACRO>
<NAME>GST_MAP_INFO_INIT</NAME>
#define GST_MAP_INFO_INIT { NULL, 0, NULL, 0, 0, {0, }, {0, }}
</MACRO>
<USER_FUNCTION>
<NAME>GstMemoryMapFunction</NAME>
<RETURNS>gpointer </RETURNS>
GstMemory *mem, gsize maxsize, GstMapFlags flags
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryMapFullFunction</NAME>
<RETURNS>gpointer </RETURNS>
GstMemory *mem, GstMapInfo * info, gsize maxsize
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryUnmapFunction</NAME>
<RETURNS>void </RETURNS>
GstMemory *mem
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryUnmapFullFunction</NAME>
<RETURNS>void </RETURNS>
GstMemory *mem, GstMapInfo * info
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryCopyFunction</NAME>
<RETURNS>GstMemory *</RETURNS>
GstMemory *mem, gssize offset, gssize size
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryShareFunction</NAME>
<RETURNS>GstMemory *</RETURNS>
GstMemory *mem, gssize offset, gssize size
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMemoryIsSpanFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstMemory *mem1, GstMemory *mem2, gsize *offset
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_memory_init</NAME>
<RETURNS>void            </RETURNS>
GstMemory *mem, GstMemoryFlags flags, GstAllocator *allocator, GstMemory *parent, gsize maxsize, gsize align, gsize offset, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_is_type</NAME>
<RETURNS>gboolean        </RETURNS>
GstMemory *mem, const gchar *mem_type
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_ref</NAME>
<RETURNS>GstMemory  * </RETURNS>
GstMemory * memory
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_unref</NAME>
<RETURNS>void  </RETURNS>
GstMemory * memory
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_get_sizes</NAME>
<RETURNS>gsize           </RETURNS>
GstMemory *mem, gsize *offset, gsize *maxsize
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_resize</NAME>
<RETURNS>void            </RETURNS>
GstMemory *mem, gssize offset, gsize size
</FUNCTION>
<MACRO>
<NAME>gst_memory_lock</NAME>
#define        gst_memory_lock(m,f)        gst_mini_object_lock (GST_MINI_OBJECT_CAST (m), (f))
</MACRO>
<MACRO>
<NAME>gst_memory_unlock</NAME>
#define        gst_memory_unlock(m,f)      gst_mini_object_unlock (GST_MINI_OBJECT_CAST (m), (f))
</MACRO>
<MACRO>
<NAME>gst_memory_is_writable</NAME>
#define        gst_memory_is_writable(m)   gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (m))
</MACRO>
<MACRO>
<NAME>gst_memory_make_writable</NAME>
#define        gst_memory_make_writable(m) GST_MEMORY_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (m)))
</MACRO>
<FUNCTION>
<NAME>gst_memory_make_mapped</NAME>
<RETURNS>GstMemory  *    </RETURNS>
GstMemory *mem, GstMapInfo *info, GstMapFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_map</NAME>
<RETURNS>gboolean        </RETURNS>
GstMemory *mem, GstMapInfo *info, GstMapFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_unmap</NAME>
<RETURNS>void            </RETURNS>
GstMemory *mem, GstMapInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_copy</NAME>
<RETURNS>GstMemory  *    </RETURNS>
GstMemory *mem, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_share</NAME>
<RETURNS>GstMemory  *    </RETURNS>
GstMemory *mem, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_is_span</NAME>
<RETURNS>gboolean        </RETURNS>
GstMemory *mem1, GstMemory *mem2, gsize *offset
</FUNCTION>
<STRUCT>
<NAME>GstAllocator</NAME>
</STRUCT>
<MACRO>
<NAME>GST_VERSION_MAJOR</NAME>
#define GST_VERSION_MAJOR (1)
</MACRO>
<MACRO>
<NAME>GST_VERSION_MINOR</NAME>
#define GST_VERSION_MINOR (6)
</MACRO>
<MACRO>
<NAME>GST_VERSION_MICRO</NAME>
#define GST_VERSION_MICRO (3)
</MACRO>
<MACRO>
<NAME>GST_VERSION_NANO</NAME>
#define GST_VERSION_NANO (0)
</MACRO>
<MACRO>
<NAME>GST_CHECK_VERSION</NAME>
#define	GST_CHECK_VERSION(major,minor,micro)	\
    (GST_VERSION_MAJOR > (major) || \
     (GST_VERSION_MAJOR == (major) && GST_VERSION_MINOR > (minor)) || \
     (GST_VERSION_MAJOR == (major) && GST_VERSION_MINOR == (minor) && \
      GST_VERSION_MICRO >= (micro)) || \
     (GST_VERSION_MAJOR == (major) && GST_VERSION_MINOR == (minor) && \
      GST_VERSION_MICRO + 1 == (micro) && GST_VERSION_NANO > 0))
</MACRO>
<MACRO>
<NAME>gst_buffer_new_and_alloc</NAME>
#define gst_buffer_new_and_alloc(s)            gst_buffer_new_allocate(NULL, s, NULL)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_TIMESTAMP</NAME>
#define GST_BUFFER_TIMESTAMP          GST_BUFFER_PTS
</MACRO>
<MACRO>
<NAME>GST_BUFFER_TIMESTAMP_IS_VALID</NAME>
#define GST_BUFFER_TIMESTAMP_IS_VALID GST_BUFFER_PTS_IS_VALID
</MACRO>
<FUNCTION>
<NAME>gst_pad_set_caps</NAME>
<RETURNS>gboolean </RETURNS>
GstPad * pad, GstCaps * caps
</FUNCTION>
<MACRO>
<NAME>gst_element_class_set_details_simple</NAME>
<DEPRECATED/>
#define gst_element_class_set_details_simple  gst_element_class_set_metadata
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_longname</NAME>
<DEPRECATED/>
#define gst_element_factory_get_longname(f)    gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_LONGNAME)
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_klass</NAME>
<DEPRECATED/>
#define gst_element_factory_get_klass(f)       gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_KLASS)
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_description</NAME>
<DEPRECATED/>
#define gst_element_factory_get_description(f) gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DESCRIPTION)
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_author</NAME>
<DEPRECATED/>
#define gst_element_factory_get_author(f)      gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_AUTHOR)
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_documentation_uri</NAME>
<DEPRECATED/>
#define gst_element_factory_get_documentation_uri(f)  gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_DOC_URI)
</MACRO>
<MACRO>
<NAME>gst_element_factory_get_icon_name</NAME>
<DEPRECATED/>
#define gst_element_factory_get_icon_name(f)   gst_element_factory_get_metadata(f, GST_ELEMENT_METADATA_ICON_NAME)
</MACRO>
<MACRO>
<NAME>gst_pad_get_caps_reffed</NAME>
<DEPRECATED/>
#define gst_pad_get_caps_reffed(p)             gst_pad_get_caps(p)
</MACRO>
<MACRO>
<NAME>gst_pad_peer_get_caps_reffed</NAME>
<DEPRECATED/>
#define gst_pad_peer_get_caps_reffed(p)        gst_pad_peer_get_caps(p)
</MACRO>
<MACRO>
<NAME>gst_adapter_prev_timestamp</NAME>
<DEPRECATED/>
#define gst_adapter_prev_timestamp    gst_adapter_prev_pts
</MACRO>
<MACRO>
<NAME>gst_tag_list_free</NAME>
<DEPRECATED/>
#define gst_tag_list_free(taglist)    gst_tag_list_unref(taglist)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_DURATION</NAME>
<DEPRECATED/>
#define GST_MESSAGE_DURATION GST_MESSAGE_DURATION_CHANGED
</MACRO>
<MACRO>
<NAME>gst_message_new_duration</NAME>
<DEPRECATED/>
#define gst_message_new_duration(src,fmt,dur) \
    gst_message_new_duration_changed(src)
</MACRO>
<MACRO>
<NAME>gst_message_parse_duration</NAME>
<DEPRECATED/>
#define gst_message_parse_duration(msg,fmt,dur) \
G_STMT_START { \
  GstFormat *p_fmt = fmt; \
  gint64 *p_dur = dur; \
  if (p_fmt) \
    *p_fmt = GST_FORMAT_TIME; \
  if (p_dur) \
    *p_dur = GST_CLOCK_TIME_NONE; \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_TYPE_BUS</NAME>
#define GST_TYPE_BUS              (gst_bus_get_type ())
</MACRO>
<MACRO>
<NAME>GST_BUS</NAME>
#define GST_BUS(bus)              (G_TYPE_CHECK_INSTANCE_CAST ((bus), GST_TYPE_BUS, GstBus))
</MACRO>
<MACRO>
<NAME>GST_IS_BUS</NAME>
#define GST_IS_BUS(bus)           (G_TYPE_CHECK_INSTANCE_TYPE ((bus), GST_TYPE_BUS))
</MACRO>
<MACRO>
<NAME>GST_BUS_CLASS</NAME>
#define GST_BUS_CLASS(bclass)     (G_TYPE_CHECK_CLASS_CAST ((bclass), GST_TYPE_BUS, GstBusClass))
</MACRO>
<MACRO>
<NAME>GST_IS_BUS_CLASS</NAME>
#define GST_IS_BUS_CLASS(bclass)  (G_TYPE_CHECK_CLASS_TYPE ((bclass), GST_TYPE_BUS))
</MACRO>
<MACRO>
<NAME>GST_BUS_GET_CLASS</NAME>
#define GST_BUS_GET_CLASS(bus)    (G_TYPE_INSTANCE_GET_CLASS ((bus), GST_TYPE_BUS, GstBusClass))
</MACRO>
<MACRO>
<NAME>GST_BUS_CAST</NAME>
#define GST_BUS_CAST(bus)         ((GstBus*)(bus))
</MACRO>
<ENUM>
<NAME>GstBusFlags</NAME>
typedef enum {
  GST_BUS_FLUSHING      = (GST_OBJECT_FLAG_LAST << 0),
  /* padding */
  GST_BUS_FLAG_LAST     = (GST_OBJECT_FLAG_LAST << 1)
} GstBusFlags;
</ENUM>
<ENUM>
<NAME>GstBusSyncReply</NAME>
typedef enum
{
  GST_BUS_DROP = 0,
  GST_BUS_PASS = 1,
  GST_BUS_ASYNC = 2
} GstBusSyncReply;
</ENUM>
<USER_FUNCTION>
<NAME>GstBusSyncHandler</NAME>
<RETURNS>GstBusSyncReply </RETURNS>
GstBus * bus, GstMessage * message, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstBusFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstBus * bus, GstMessage * message, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstBus</NAME>
struct _GstBus
{
  GstObject         object;

  /*< private >*/
  GstBusPrivate    *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstBusClass</NAME>
struct _GstBusClass
{
  GstObjectClass parent_class;

  /* signals */
  void (*message)       (GstBus *bus, GstMessage *message);
  void (*sync_message)  (GstBus *bus, GstMessage *message);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_bus_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_new</NAME>
<RETURNS>GstBus *                 </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_post</NAME>
<RETURNS>gboolean                 </RETURNS>
GstBus * bus, GstMessage * message
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_have_pending</NAME>
<RETURNS>gboolean                 </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_peek</NAME>
<RETURNS>GstMessage  *            </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_pop</NAME>
<RETURNS>GstMessage  *            </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_pop_filtered</NAME>
<RETURNS>GstMessage  *            </RETURNS>
GstBus * bus, GstMessageType types
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_timed_pop</NAME>
<RETURNS>GstMessage  *            </RETURNS>
GstBus * bus, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_timed_pop_filtered</NAME>
<RETURNS>GstMessage  *            </RETURNS>
GstBus * bus, GstClockTime timeout, GstMessageType types
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_set_flushing</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus, gboolean flushing
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_set_sync_handler</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus, GstBusSyncHandler func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_create_watch</NAME>
<RETURNS>GSource  *               </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_add_watch_full</NAME>
<RETURNS>guint                    </RETURNS>
GstBus * bus, gint priority, GstBusFunc func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_add_watch</NAME>
<RETURNS>guint                    </RETURNS>
GstBus * bus, GstBusFunc func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_remove_watch</NAME>
<RETURNS>gboolean                 </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_poll</NAME>
<RETURNS>GstMessage *             </RETURNS>
GstBus *bus, GstMessageType events, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_async_signal_func</NAME>
<RETURNS>gboolean                 </RETURNS>
GstBus *bus, GstMessage *message, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_sync_signal_handler</NAME>
<RETURNS>GstBusSyncReply          </RETURNS>
GstBus *bus, GstMessage *message, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_add_signal_watch</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_add_signal_watch_full</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus, gint priority
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_remove_signal_watch</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_enable_sync_message_emission</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_bus_disable_sync_message_emission</NAME>
<RETURNS>void                     </RETURNS>
GstBus * bus
</FUNCTION>
<STRUCT>
<NAME>GstBusPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_OBJECT</NAME>
#define GST_TYPE_OBJECT			(gst_object_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_OBJECT</NAME>
#define GST_IS_OBJECT(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>GST_IS_OBJECT_CLASS</NAME>
#define GST_IS_OBJECT_CLASS(klass)	(G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_OBJECT))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_GET_CLASS</NAME>
#define GST_OBJECT_GET_CLASS(obj)	(G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_OBJECT, GstObjectClass))
</MACRO>
<MACRO>
<NAME>GST_OBJECT</NAME>
#define GST_OBJECT(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_OBJECT, GstObject))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_CLASS</NAME>
#define GST_OBJECT_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_OBJECT, GstObjectClass))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_CAST</NAME>
#define GST_OBJECT_CAST(obj)            ((GstObject*)(obj))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_CLASS_CAST</NAME>
#define GST_OBJECT_CLASS_CAST(klass)    ((GstObjectClass*)(klass))
</MACRO>
<ENUM>
<NAME>GstObjectFlags</NAME>
typedef enum
{
  /* padding */
  GST_OBJECT_FLAG_LAST = (1<<4)
} GstObjectFlags;
</ENUM>
<MACRO>
<NAME>GST_OBJECT_REFCOUNT</NAME>
#define GST_OBJECT_REFCOUNT(obj)                (((GObject*)(obj))->ref_count)
</MACRO>
<MACRO>
<NAME>GST_OBJECT_REFCOUNT_VALUE</NAME>
#define GST_OBJECT_REFCOUNT_VALUE(obj)          g_atomic_int_get ((gint *) &GST_OBJECT_REFCOUNT(obj))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_GET_LOCK</NAME>
#define GST_OBJECT_GET_LOCK(obj)               (&GST_OBJECT_CAST(obj)->lock)
</MACRO>
<MACRO>
<NAME>GST_OBJECT_LOCK</NAME>
#define GST_OBJECT_LOCK(obj)                   g_mutex_lock(GST_OBJECT_GET_LOCK(obj))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_TRYLOCK</NAME>
#define GST_OBJECT_TRYLOCK(obj)                g_mutex_trylock(GST_OBJECT_GET_LOCK(obj))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_UNLOCK</NAME>
#define GST_OBJECT_UNLOCK(obj)                 g_mutex_unlock(GST_OBJECT_GET_LOCK(obj))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_NAME</NAME>
#define GST_OBJECT_NAME(obj)            (GST_OBJECT_CAST(obj)->name)
</MACRO>
<MACRO>
<NAME>GST_OBJECT_PARENT</NAME>
#define GST_OBJECT_PARENT(obj)          (GST_OBJECT_CAST(obj)->parent)
</MACRO>
<MACRO>
<NAME>GST_OBJECT_FLAGS</NAME>
#define GST_OBJECT_FLAGS(obj)                  (GST_OBJECT_CAST (obj)->flags)
</MACRO>
<MACRO>
<NAME>GST_OBJECT_FLAG_IS_SET</NAME>
#define GST_OBJECT_FLAG_IS_SET(obj,flag)       ((GST_OBJECT_FLAGS (obj) & (flag)) == (flag))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_FLAG_SET</NAME>
#define GST_OBJECT_FLAG_SET(obj,flag)          (GST_OBJECT_FLAGS (obj) |= (flag))
</MACRO>
<MACRO>
<NAME>GST_OBJECT_FLAG_UNSET</NAME>
#define GST_OBJECT_FLAG_UNSET(obj,flag)        (GST_OBJECT_FLAGS (obj) &= ~(flag))
</MACRO>
<STRUCT>
<NAME>GstObject</NAME>
struct _GstObject {
  GInitiallyUnowned object;

  /*< public >*/ /* with LOCK */
  GMutex         lock;        /* object LOCK */
  gchar         *name;        /* object name */
  GstObject     *parent;      /* this object's parent, weak ref */
  guint32        flags;

  /*< private >*/
  GList         *control_bindings;  /* List of GstControlBinding */
  guint64        control_rate;
  guint64        last_sync;

  gpointer _gst_reserved;
};
</STRUCT>
<STRUCT>
<NAME>GstObjectClass</NAME>
struct _GstObjectClass {
  GInitiallyUnownedClass parent_class;

  const gchar	*path_string_separator;

  /* signals */
  void          (*deep_notify)      (GstObject * object, GstObject * orig, GParamSpec * pspec);

  /*< public >*/
  /* virtual methods for subclasses */

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_object_get_type</NAME>
<RETURNS>GType 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_object_set_name</NAME>
<RETURNS>gboolean 	</RETURNS>
GstObject *object, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_name</NAME>
<RETURNS>gchar *		</RETURNS>
GstObject *object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_set_parent</NAME>
<RETURNS>gboolean 	</RETURNS>
GstObject *object, GstObject *parent
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_parent</NAME>
<RETURNS>GstObject *	</RETURNS>
GstObject *object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_unparent</NAME>
<RETURNS>void 		</RETURNS>
GstObject *object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_has_as_parent</NAME>
<RETURNS>gboolean 	</RETURNS>
GstObject *object, GstObject *parent
</FUNCTION>
<FUNCTION>
<NAME>gst_object_has_as_ancestor</NAME>
<RETURNS>gboolean 	</RETURNS>
GstObject *object, GstObject *ancestor
</FUNCTION>
<FUNCTION>
<NAME>gst_object_has_ancestor</NAME>
<DEPRECATED/>
<RETURNS>gboolean 	</RETURNS>
GstObject *object, GstObject *ancestor
</FUNCTION>
<FUNCTION>
<NAME>gst_object_default_deep_notify</NAME>
<RETURNS>void             </RETURNS>
GObject *object, GstObject *orig, GParamSpec *pspec, gchar **excluded_props
</FUNCTION>
<FUNCTION>
<NAME>gst_object_ref</NAME>
<RETURNS>gpointer 	</RETURNS>
gpointer object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_unref</NAME>
<RETURNS>void 		</RETURNS>
gpointer object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_ref_sink</NAME>
<RETURNS>gpointer         </RETURNS>
gpointer object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_replace</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject **oldobj, GstObject *newobj
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_path_string</NAME>
<RETURNS>gchar  *		</RETURNS>
GstObject *object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_check_uniqueness</NAME>
<RETURNS>gboolean 	</RETURNS>
GList *list, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_object_suggest_next_sync</NAME>
<RETURNS>GstClockTime     </RETURNS>
GstObject * object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_sync_values</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject * object, GstClockTime timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_object_has_active_control_bindings</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject *object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_set_control_bindings_disabled</NAME>
<RETURNS>void             </RETURNS>
GstObject *object, gboolean disabled
</FUNCTION>
<FUNCTION>
<NAME>gst_object_set_control_binding_disabled</NAME>
<RETURNS>void             </RETURNS>
GstObject *object, const gchar * property_name, gboolean disabled
</FUNCTION>
<FUNCTION>
<NAME>gst_object_add_control_binding</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject * object, GstControlBinding * binding
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_control_binding</NAME>
<RETURNS>GstControlBinding  *</RETURNS>
GstObject *object, const gchar * property_name
</FUNCTION>
<FUNCTION>
<NAME>gst_object_remove_control_binding</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject * object, GstControlBinding * binding
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_value</NAME>
<RETURNS>GValue  *        </RETURNS>
GstObject * object, const gchar * property_name, GstClockTime timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_value_array</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject * object, const gchar * property_name, GstClockTime timestamp, GstClockTime interval, guint n_values, gpointer values
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_g_value_array</NAME>
<RETURNS>gboolean         </RETURNS>
GstObject * object, const gchar * property_name, GstClockTime timestamp, GstClockTime interval, guint n_values, GValue *values
</FUNCTION>
<FUNCTION>
<NAME>gst_object_get_control_rate</NAME>
<RETURNS>GstClockTime     </RETURNS>
GstObject * object
</FUNCTION>
<FUNCTION>
<NAME>gst_object_set_control_rate</NAME>
<RETURNS>void             </RETURNS>
GstObject * object, GstClockTime control_rate
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STRUCTURE</NAME>
#define GST_TYPE_STRUCTURE             (_gst_structure_type)
</MACRO>
<MACRO>
<NAME>GST_IS_STRUCTURE</NAME>
#define GST_IS_STRUCTURE(object)       ((object) && (GST_STRUCTURE(object)->type == GST_TYPE_STRUCTURE))
</MACRO>
<MACRO>
<NAME>GST_STRUCTURE_CAST</NAME>
#define GST_STRUCTURE_CAST(object)     ((GstStructure *)(object))
</MACRO>
<MACRO>
<NAME>GST_STRUCTURE</NAME>
#define GST_STRUCTURE(object)          (GST_STRUCTURE_CAST(object))
</MACRO>
<USER_FUNCTION>
<NAME>GstStructureForeachFunc</NAME>
<RETURNS>gboolean </RETURNS>
GQuark   field_id,
                                             const GValue * value,
                                             gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstStructureMapFunc</NAME>
<RETURNS>gboolean </RETURNS>
GQuark   field_id,
                                             GValue * value,
                                             gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstStructureFilterMapFunc</NAME>
<RETURNS>gboolean </RETURNS>
GQuark   field_id,
                                               GValue * value,
                                               gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstStructure</NAME>
struct _GstStructure {
  GType type;

  /*< private >*/
  GQuark name;
};
</STRUCT>
<FUNCTION>
<NAME>gst_structure_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new_empty</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new_id_empty</NAME>
<RETURNS>GstStructure  *        </RETURNS>
GQuark quark
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const gchar * name, const gchar * firstfield, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new_valist</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const gchar * name, const gchar * firstfield, va_list       varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new_id</NAME>
<RETURNS>GstStructure  *        </RETURNS>
GQuark name_quark, GQuark field_quark, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_new_from_string</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const gchar * string
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_copy</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const GstStructure  * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_set_parent_refcount</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure        * structure, gint                * refcount
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_free</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
const GstStructure  * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_name_id</NAME>
<RETURNS>GQuark                 </RETURNS>
const GstStructure  * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_has_name</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * name
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_set_name</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * name
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_set_value</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, GQuark                field, const GValue        * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_set_value</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, const GValue        * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_take_value</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, GQuark                field, GValue              * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_take_value</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, GValue              * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_set</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_set_valist</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, va_list varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_set</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, GQuark                fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_set_valist</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, GQuark                fieldname, va_list varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_valist</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const char          * first_fieldname, va_list              args
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const char          * first_fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_get_valist</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, GQuark                first_field_id, va_list               args
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_get</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, GQuark                first_field_id, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_get_value</NAME>
<RETURNS>const GValue  *        </RETURNS>
const GstStructure  * structure, GQuark                field
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_value</NAME>
<RETURNS>const GValue  *        </RETURNS>
const GstStructure  * structure, const gchar         * fieldname
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_remove_field</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_remove_fields</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_remove_fields_valist</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, const gchar         * fieldname, va_list               varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_remove_all_fields</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_field_type</NAME>
<RETURNS>GType                  </RETURNS>
const GstStructure  * structure, const gchar         * fieldname
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_foreach</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, GstStructureForeachFunc   func, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_map_in_place</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure        * structure, GstStructureMapFunc   func, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_filter_and_map_in_place</NAME>
<RETURNS>void                   </RETURNS>
GstStructure        * structure, GstStructureFilterMapFunc   func, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_n_fields</NAME>
<RETURNS>gint                   </RETURNS>
const GstStructure  * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_nth_field_name</NAME>
<RETURNS>const gchar  *         </RETURNS>
const GstStructure  * structure, guint                 index
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_has_field</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, GQuark                field
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_id_has_field_typed</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, GQuark                field, GType                 type
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_has_field</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_has_field_typed</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, GType                 type
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_boolean</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, gboolean            * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_int</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, gint                * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_uint</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, guint               * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_int64</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, gint64              * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_uint64</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, guint64             * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_double</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, gdouble             * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_date</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, GDate              ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_date_time</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, GstDateTime        ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_clock_time</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, GstClockTime        * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_string</NAME>
<RETURNS>const gchar  *         </RETURNS>
const GstStructure  * structure, const gchar         * fieldname
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_enum</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, GType                 enumtype, gint                * value
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_fraction</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, gint                * value_numerator, gint                * value_denominator
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_get_flagset</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure  * structure, const gchar         * fieldname, guint               * value_flags, guint               * value_mask
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_to_string</NAME>
<RETURNS>gchar  *               </RETURNS>
const GstStructure * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_from_string</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const gchar * string, gchar      ** end
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field_nearest_int</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name, int            target
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field_nearest_double</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name, double         target
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field_boolean</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name, gboolean       target
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field_string</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name, const gchar  * target
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field_nearest_fraction</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name, const gint     target_numerator, const gint     target_denominator
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate_field</NAME>
<RETURNS>gboolean               </RETURNS>
GstStructure * structure, const char   * field_name
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_fixate</NAME>
<RETURNS>void                   </RETURNS>
GstStructure * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_is_equal</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure * structure1, const GstStructure * structure2
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_is_subset</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure * subset, const GstStructure * superset
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_can_intersect</NAME>
<RETURNS>gboolean               </RETURNS>
const GstStructure * struct1, const GstStructure * struct2
</FUNCTION>
<FUNCTION>
<NAME>gst_structure_intersect</NAME>
<RETURNS>GstStructure  *        </RETURNS>
const GstStructure * struct1, const GstStructure * struct2
</FUNCTION>
<FUNCTION>
<NAME>gst_util_set_value_from_string</NAME>
<RETURNS>void             </RETURNS>
GValue *value, const gchar *value_str
</FUNCTION>
<FUNCTION>
<NAME>gst_util_set_object_arg</NAME>
<RETURNS>void             </RETURNS>
GObject *object, const gchar *name, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gst_util_dump_mem</NAME>
<RETURNS>void             </RETURNS>
const guchar *mem, guint size
</FUNCTION>
<FUNCTION>
<NAME>gst_util_gdouble_to_guint64</NAME>
<RETURNS>guint64          </RETURNS>
gdouble value
</FUNCTION>
<FUNCTION>
<NAME>gst_util_guint64_to_gdouble</NAME>
<RETURNS>gdouble          </RETURNS>
guint64 value
</FUNCTION>
<MACRO>
<NAME>gst_gdouble_to_guint64</NAME>
#define         gst_gdouble_to_guint64(value)   gst_util_gdouble_to_guint64(value)
</MACRO>
<MACRO>
<NAME>gst_guint64_to_gdouble</NAME>
#define         gst_guint64_to_gdouble(value)   gst_util_guint64_to_gdouble(value)
</MACRO>
<FUNCTION>
<NAME>gst_util_uint64_scale</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, guint64 num, guint64 denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_uint64_scale_round</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, guint64 num, guint64 denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_uint64_scale_ceil</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, guint64 num, guint64 denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_uint64_scale_int</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, gint num, gint denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_uint64_scale_int_round</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, gint num, gint denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_uint64_scale_int_ceil</NAME>
<RETURNS>guint64          </RETURNS>
guint64 val, gint num, gint denom
</FUNCTION>
<FUNCTION>
<NAME>gst_util_seqnum_next</NAME>
<RETURNS>guint32          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_util_seqnum_compare</NAME>
<RETURNS>gint32           </RETURNS>
guint32 s1, guint32 s2
</FUNCTION>
<FUNCTION>
<NAME>gst_util_group_id_next</NAME>
<RETURNS>guint            </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_CALL_PARENT</NAME>
#define GST_CALL_PARENT(parent_class_cast, name, args)                  \
        ((parent_class_cast(parent_class)->name != NULL) ?              \
         parent_class_cast(parent_class)->name args : (void) 0)
</MACRO>
<MACRO>
<NAME>GST_CALL_PARENT_WITH_DEFAULT</NAME>
#define GST_CALL_PARENT_WITH_DEFAULT(parent_class_cast, name, args, def_return)\
        ((parent_class_cast(parent_class)->name != NULL) ?              \
         parent_class_cast(parent_class)->name args : def_return)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT64_BE</NAME>
#  define GST_READ_UINT64_BE(data)      _GST_FAST_READ (64, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT64_LE</NAME>
#  define GST_READ_UINT64_LE(data)      _GST_FAST_READ_SWAP (64, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT32_BE</NAME>
#  define GST_READ_UINT32_BE(data)      _GST_FAST_READ (32, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT32_LE</NAME>
#  define GST_READ_UINT32_LE(data)      _GST_FAST_READ_SWAP (32, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT24_BE</NAME>
#define GST_READ_UINT24_BE(data) __gst_slow_read24_be((const guint8 *)(data))
</MACRO>
<MACRO>
<NAME>GST_READ_UINT24_LE</NAME>
#define GST_READ_UINT24_LE(data) __gst_slow_read24_le((const guint8 *)(data))
</MACRO>
<MACRO>
<NAME>GST_READ_UINT16_BE</NAME>
#  define GST_READ_UINT16_BE(data)      _GST_FAST_READ (16, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT16_LE</NAME>
#  define GST_READ_UINT16_LE(data)      _GST_FAST_READ_SWAP (16, data)
</MACRO>
<MACRO>
<NAME>GST_READ_UINT8</NAME>
#define GST_READ_UINT8(data)            (_GST_GET (data, 0,  8,  0))
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT64_BE</NAME>
#define GST_WRITE_UINT64_BE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 64, 56, num); \
                                          _GST_PUT (__put_data, 1, 64, 48, num); \
                                          _GST_PUT (__put_data, 2, 64, 40, num); \
                                          _GST_PUT (__put_data, 3, 64, 32, num); \
                                          _GST_PUT (__put_data, 4, 64, 24, num); \
                                          _GST_PUT (__put_data, 5, 64, 16, num); \
                                          _GST_PUT (__put_data, 6, 64,  8, num); \
                                          _GST_PUT (__put_data, 7, 64,  0, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT64_LE</NAME>
#define GST_WRITE_UINT64_LE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 64,  0, num); \
                                          _GST_PUT (__put_data, 1, 64,  8, num); \
                                          _GST_PUT (__put_data, 2, 64, 16, num); \
                                          _GST_PUT (__put_data, 3, 64, 24, num); \
                                          _GST_PUT (__put_data, 4, 64, 32, num); \
                                          _GST_PUT (__put_data, 5, 64, 40, num); \
                                          _GST_PUT (__put_data, 6, 64, 48, num); \
                                          _GST_PUT (__put_data, 7, 64, 56, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT32_BE</NAME>
#define GST_WRITE_UINT32_BE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 32, 24, num); \
                                          _GST_PUT (__put_data, 1, 32, 16, num); \
                                          _GST_PUT (__put_data, 2, 32,  8, num); \
                                          _GST_PUT (__put_data, 3, 32,  0, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT32_LE</NAME>
#define GST_WRITE_UINT32_LE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 32,  0, num); \
                                          _GST_PUT (__put_data, 1, 32,  8, num); \
                                          _GST_PUT (__put_data, 2, 32, 16, num); \
                                          _GST_PUT (__put_data, 3, 32, 24, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT24_BE</NAME>
#define GST_WRITE_UINT24_BE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 32,  16, num); \
                                          _GST_PUT (__put_data, 1, 32,  8, num); \
                                          _GST_PUT (__put_data, 2, 32,  0, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT24_LE</NAME>
#define GST_WRITE_UINT24_LE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 32,  0, num); \
                                          _GST_PUT (__put_data, 1, 32,  8, num); \
                                          _GST_PUT (__put_data, 2, 32,  16, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT16_BE</NAME>
#define GST_WRITE_UINT16_BE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 16,  8, num); \
                                          _GST_PUT (__put_data, 1, 16,  0, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT16_LE</NAME>
#define GST_WRITE_UINT16_LE(data, num)  do { \
                                          gpointer __put_data = data; \
                                          _GST_PUT (__put_data, 0, 16,  0, num); \
                                          _GST_PUT (__put_data, 1, 16,  8, num); \
                                        } while (0)
</MACRO>
<MACRO>
<NAME>GST_WRITE_UINT8</NAME>
#define GST_WRITE_UINT8(data, num)      do { \
                                          _GST_PUT (data, 0,  8,  0, num); \
                                        } while (0)
</MACRO>
<FUNCTION>
<NAME>GFLOAT_SWAP_LE_BE</NAME>
<RETURNS>gfloat  </RETURNS>
gfloat in
</FUNCTION>
<FUNCTION>
<NAME>GDOUBLE_SWAP_LE_BE</NAME>
<RETURNS>gdouble  </RETURNS>
gdouble in
</FUNCTION>
<MACRO>
<NAME>GFLOAT_TO_LE</NAME>
#define GFLOAT_TO_LE(val)    ((gfloat) (val))
</MACRO>
<MACRO>
<NAME>GFLOAT_TO_BE</NAME>
#define GFLOAT_TO_BE(val)    (GFLOAT_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GDOUBLE_TO_LE</NAME>
#define GDOUBLE_TO_LE(val)   ((gdouble) (val))
</MACRO>
<MACRO>
<NAME>GDOUBLE_TO_BE</NAME>
#define GDOUBLE_TO_BE(val)   (GDOUBLE_SWAP_LE_BE (val))
</MACRO>
<MACRO>
<NAME>GFLOAT_FROM_LE</NAME>
#define GFLOAT_FROM_LE(val)  (GFLOAT_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GFLOAT_FROM_BE</NAME>
#define GFLOAT_FROM_BE(val)  (GFLOAT_TO_BE (val))
</MACRO>
<MACRO>
<NAME>GDOUBLE_FROM_LE</NAME>
#define GDOUBLE_FROM_LE(val) (GDOUBLE_TO_LE (val))
</MACRO>
<MACRO>
<NAME>GDOUBLE_FROM_BE</NAME>
#define GDOUBLE_FROM_BE(val) (GDOUBLE_TO_BE (val))
</MACRO>
<FUNCTION>
<NAME>GST_READ_FLOAT_LE</NAME>
<RETURNS>gfloat  </RETURNS>
const guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>GST_READ_FLOAT_BE</NAME>
<RETURNS>gfloat  </RETURNS>
const guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>GST_READ_DOUBLE_LE</NAME>
<RETURNS>gdouble  </RETURNS>
const guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>GST_READ_DOUBLE_BE</NAME>
<RETURNS>gdouble  </RETURNS>
const guint8 *data
</FUNCTION>
<FUNCTION>
<NAME>GST_WRITE_FLOAT_LE</NAME>
<RETURNS>void  </RETURNS>
guint8 *data, gfloat num
</FUNCTION>
<FUNCTION>
<NAME>GST_WRITE_FLOAT_BE</NAME>
<RETURNS>void  </RETURNS>
guint8 *data, gfloat num
</FUNCTION>
<FUNCTION>
<NAME>GST_WRITE_DOUBLE_LE</NAME>
<RETURNS>void  </RETURNS>
guint8 *data, gdouble num
</FUNCTION>
<FUNCTION>
<NAME>GST_WRITE_DOUBLE_BE</NAME>
<RETURNS>void  </RETURNS>
guint8 *data, gdouble num
</FUNCTION>
<MACRO>
<NAME>GST_ROUND_UP_2</NAME>
#define GST_ROUND_UP_2(num)  (((num)+1)&~1)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_4</NAME>
#define GST_ROUND_UP_4(num)  (((num)+3)&~3)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_8</NAME>
#define GST_ROUND_UP_8(num)  (((num)+7)&~7)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_16</NAME>
#define GST_ROUND_UP_16(num) (((num)+15)&~15)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_32</NAME>
#define GST_ROUND_UP_32(num) (((num)+31)&~31)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_64</NAME>
#define GST_ROUND_UP_64(num) (((num)+63)&~63)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_128</NAME>
#define GST_ROUND_UP_128(num) (((num)+127)&~127)
</MACRO>
<MACRO>
<NAME>GST_ROUND_UP_N</NAME>
#define GST_ROUND_UP_N(num,align) ((((num) + ((align) - 1)) & ~((align) - 1)))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_2</NAME>
#define GST_ROUND_DOWN_2(num)  ((num)&(~1))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_4</NAME>
#define GST_ROUND_DOWN_4(num)  ((num)&(~3))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_8</NAME>
#define GST_ROUND_DOWN_8(num)  ((num)&(~7))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_16</NAME>
#define GST_ROUND_DOWN_16(num) ((num)&(~15))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_32</NAME>
#define GST_ROUND_DOWN_32(num) ((num)&(~31))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_64</NAME>
#define GST_ROUND_DOWN_64(num) ((num)&(~63))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_128</NAME>
#define GST_ROUND_DOWN_128(num) ((num)&(~127))
</MACRO>
<MACRO>
<NAME>GST_ROUND_DOWN_N</NAME>
#define GST_ROUND_DOWN_N(num,align) (((num) & ~((align) - 1)))
</MACRO>
<FUNCTION>
<NAME>gst_object_default_error</NAME>
<RETURNS>void                     </RETURNS>
GstObject    * source, const GError * error, const gchar  * debug
</FUNCTION>
<FUNCTION>
<NAME>gst_element_create_all_pads</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_compatible_pad</NAME>
<RETURNS>GstPad *                 </RETURNS>
GstElement *element, GstPad *pad, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_compatible_pad_template</NAME>
<RETURNS>GstPadTemplate *         </RETURNS>
GstElement *element, GstPadTemplate *compattempl
</FUNCTION>
<FUNCTION>
<NAME>gst_element_state_get_name</NAME>
<RETURNS>const gchar *            </RETURNS>
GstState state
</FUNCTION>
<FUNCTION>
<NAME>gst_element_state_change_return_get_name</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstStateChangeReturn state_ret
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *src, GstElement *dest
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link_many</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element_1, GstElement *element_2, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link_filtered</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement * src, GstElement * dest, GstCaps *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_element_unlink</NAME>
<RETURNS>void                     </RETURNS>
GstElement *src, GstElement *dest
</FUNCTION>
<FUNCTION>
<NAME>gst_element_unlink_many</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element_1, GstElement *element_2, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link_pads</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *src, const gchar *srcpadname, GstElement *dest, const gchar *destpadname
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link_pads_full</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *src, const gchar *srcpadname, GstElement *dest, const gchar *destpadname, GstPadLinkCheck flags
</FUNCTION>
<FUNCTION>
<NAME>gst_element_unlink_pads</NAME>
<RETURNS>void                     </RETURNS>
GstElement *src, const gchar *srcpadname, GstElement *dest, const gchar *destpadname
</FUNCTION>
<FUNCTION>
<NAME>gst_element_link_pads_filtered</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement * src, const gchar * srcpadname, GstElement * dest, const gchar * destpadname, GstCaps *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_element_seek_simple</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement   *element, GstFormat     format, GstSeekFlags  seek_flags, gint64        seek_pos
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_can_sink_all_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElementFactory *factory, const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_can_src_all_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElementFactory *factory, const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_can_sink_any_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElementFactory *factory, const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_can_src_any_caps</NAME>
<RETURNS>gboolean  </RETURNS>
GstElementFactory *factory, const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_query_position</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstFormat format, gint64 *cur
</FUNCTION>
<FUNCTION>
<NAME>gst_element_query_duration</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstFormat format, gint64 *duration
</FUNCTION>
<FUNCTION>
<NAME>gst_element_query_convert</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstFormat src_format, gint64 src_val, GstFormat dest_format, gint64 *dest_val
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_use_fixed_caps</NAME>
<RETURNS>void                     </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_parent_element</NAME>
<RETURNS>GstElement *             </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_proxy_query_accept_caps</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_proxy_query_caps</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_position</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat format, gint64 *cur
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_duration</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat format, gint64 *duration
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_convert</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat src_format, gint64 src_val, GstFormat dest_format, gint64 *dest_val
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_caps</NAME>
<RETURNS>GstCaps  *               </RETURNS>
GstPad *pad, GstCaps *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_accept_caps</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query_position</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat format, gint64 *cur
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query_duration</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat format, gint64 *duration
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query_convert</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *pad, GstFormat src_format, gint64 src_val, GstFormat dest_format, gint64 *dest_val
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query_caps</NAME>
<RETURNS>GstCaps  *               </RETURNS>
GstPad * pad, GstCaps *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query_accept_caps</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad * pad, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_create_stream_id</NAME>
<RETURNS>gchar  *                 </RETURNS>
GstPad * pad, GstElement * parent, const gchar *stream_id
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_create_stream_id_printf</NAME>
<RETURNS>gchar  *                 </RETURNS>
GstPad * pad, GstElement * parent, const gchar *stream_id, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_create_stream_id_printf_valist</NAME>
<RETURNS>gchar  *                 </RETURNS>
GstPad * pad, GstElement * parent, const gchar *stream_id, va_list var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_stream_id</NAME>
<RETURNS>gchar  *                 </RETURNS>
GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_add_many</NAME>
<RETURNS>void                     </RETURNS>
GstBin *bin, GstElement *element_1, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_remove_many</NAME>
<RETURNS>void                     </RETURNS>
GstBin *bin, GstElement *element_1, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_find_unlinked_pad</NAME>
<RETURNS>GstPad  *                </RETURNS>
GstBin *bin, GstPadDirection direction
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_sync_children_states</NAME>
<RETURNS>gboolean                 </RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_bin_from_description</NAME>
<RETURNS>GstElement  *            </RETURNS>
const gchar     * bin_description, gboolean          ghost_unlinked_pads, GError         ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_bin_from_description_full</NAME>
<RETURNS>GstElement  *            </RETURNS>
const gchar     * bin_description, gboolean          ghost_unlinked_pads, GstParseContext * context, GstParseFlags     flags, GError         ** err
</FUNCTION>
<FUNCTION>
<NAME>gst_util_get_timestamp</NAME>
<RETURNS>GstClockTime             </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstSearchMode</NAME>
typedef enum {
  GST_SEARCH_MODE_EXACT = 0,
  GST_SEARCH_MODE_BEFORE,
  GST_SEARCH_MODE_AFTER
} GstSearchMode;
</ENUM>
<FUNCTION>
<NAME>gst_util_array_binary_search</NAME>
<RETURNS>gpointer       </RETURNS>
gpointer array, guint num_elements, gsize element_size, GCompareDataFunc search_func, GstSearchMode mode, gconstpointer search_data, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_util_greatest_common_divisor</NAME>
<RETURNS>gint           </RETURNS>
gint a, gint b
</FUNCTION>
<FUNCTION>
<NAME>gst_util_greatest_common_divisor_int64</NAME>
<RETURNS>gint64         </RETURNS>
gint64 a, gint64 b
</FUNCTION>
<FUNCTION>
<NAME>gst_util_fraction_to_double</NAME>
<RETURNS>void           </RETURNS>
gint src_n, gint src_d, gdouble *dest
</FUNCTION>
<FUNCTION>
<NAME>gst_util_double_to_fraction</NAME>
<RETURNS>void           </RETURNS>
gdouble src, gint *dest_n, gint *dest_d
</FUNCTION>
<FUNCTION>
<NAME>gst_util_fraction_multiply</NAME>
<RETURNS>gboolean       </RETURNS>
gint a_n, gint a_d, gint b_n, gint b_d, gint *res_n, gint *res_d
</FUNCTION>
<FUNCTION>
<NAME>gst_util_fraction_add</NAME>
<RETURNS>gboolean       </RETURNS>
gint a_n, gint a_d, gint b_n, gint b_d, gint *res_n, gint *res_d
</FUNCTION>
<FUNCTION>
<NAME>gst_util_fraction_compare</NAME>
<RETURNS>gint           </RETURNS>
gint a_n, gint a_d, gint b_n, gint b_d
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PROXY_PAD</NAME>
#define GST_TYPE_PROXY_PAD              (gst_proxy_pad_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PROXY_PAD</NAME>
#define GST_IS_PROXY_PAD(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PROXY_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_PROXY_PAD_CLASS</NAME>
#define GST_IS_PROXY_PAD_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PROXY_PAD))
</MACRO>
<MACRO>
<NAME>GST_PROXY_PAD</NAME>
#define GST_PROXY_PAD(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PROXY_PAD, GstProxyPad))
</MACRO>
<MACRO>
<NAME>GST_PROXY_PAD_CLASS</NAME>
#define GST_PROXY_PAD_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PROXY_PAD, GstProxyPadClass))
</MACRO>
<STRUCT>
<NAME>GstProxyPad</NAME>
struct _GstProxyPad
{
  GstPad pad;

  /*< private >*/
  GstProxyPadPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstProxyPadClass</NAME>
struct _GstProxyPadClass
{
  GstPadClass parent_class;

  /*< private >*/
  gpointer _gst_reserved[1];
};
</STRUCT>
<FUNCTION>
<NAME>gst_proxy_pad_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_proxy_pad_get_internal</NAME>
<RETURNS>GstProxyPad *     </RETURNS>
GstProxyPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_proxy_pad_iterate_internal_links_default</NAME>
<RETURNS>GstIterator *        </RETURNS>
GstPad *pad, GstObject *parent
</FUNCTION>
<FUNCTION>
<NAME>gst_proxy_pad_chain_default</NAME>
<RETURNS>GstFlowReturn        </RETURNS>
GstPad *pad, GstObject *parent, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_proxy_pad_chain_list_default</NAME>
<RETURNS>GstFlowReturn        </RETURNS>
GstPad *pad, GstObject *parent, GstBufferList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_proxy_pad_getrange_default</NAME>
<RETURNS>GstFlowReturn        </RETURNS>
GstPad *pad, GstObject *parent, guint64 offset, guint size, GstBuffer **buffer
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_GHOST_PAD</NAME>
#define GST_TYPE_GHOST_PAD              (gst_ghost_pad_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_GHOST_PAD</NAME>
#define GST_IS_GHOST_PAD(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_GHOST_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_GHOST_PAD_CLASS</NAME>
#define GST_IS_GHOST_PAD_CLASS(klass)   (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_GHOST_PAD))
</MACRO>
<MACRO>
<NAME>GST_GHOST_PAD</NAME>
#define GST_GHOST_PAD(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_GHOST_PAD, GstGhostPad))
</MACRO>
<MACRO>
<NAME>GST_GHOST_PAD_CLASS</NAME>
#define GST_GHOST_PAD_CLASS(klass)      (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_GHOST_PAD, GstGhostPadClass))
</MACRO>
<MACRO>
<NAME>GST_GHOST_PAD_CAST</NAME>
#define GST_GHOST_PAD_CAST(obj)         ((GstGhostPad*)(obj))
</MACRO>
<STRUCT>
<NAME>GstGhostPad</NAME>
struct _GstGhostPad
{
  GstProxyPad pad;

  /*< private >*/
  GstGhostPadPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstGhostPadClass</NAME>
struct _GstGhostPadClass
{
  GstProxyPadClass parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_ghost_pad_get_type</NAME>
<RETURNS>GType             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_new</NAME>
<RETURNS>GstPad *          </RETURNS>
const gchar *name, GstPad *target
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_new_no_target</NAME>
<RETURNS>GstPad *          </RETURNS>
const gchar *name, GstPadDirection dir
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_new_from_template</NAME>
<RETURNS>GstPad *          </RETURNS>
const gchar *name, GstPad * target, GstPadTemplate * templ
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_new_no_target_from_template</NAME>
<RETURNS>GstPad *          </RETURNS>
const gchar *name, GstPadTemplate * templ
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_get_target</NAME>
<RETURNS>GstPad *          </RETURNS>
GstGhostPad *gpad
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_set_target</NAME>
<RETURNS>gboolean          </RETURNS>
GstGhostPad *gpad, GstPad *newtarget
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_construct</NAME>
<RETURNS>gboolean          </RETURNS>
GstGhostPad *gpad
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_activate_mode_default</NAME>
<RETURNS>gboolean          </RETURNS>
GstPad * pad, GstObject * parent, GstPadMode mode, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_ghost_pad_internal_activate_mode_default</NAME>
<RETURNS>gboolean          </RETURNS>
GstPad * pad, GstObject * parent, GstPadMode mode, gboolean active
</FUNCTION>
<STRUCT>
<NAME>GstGhostPadPrivate</NAME>
</STRUCT>
<STRUCT>
<NAME>GstProxyPadPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_MAKE_FOURCC</NAME>
#define GST_MAKE_FOURCC(a,b,c,d)        ((guint32)((a)|(b)<<8|(c)<<16|(d)<<24))
</MACRO>
<MACRO>
<NAME>GST_STR_FOURCC</NAME>
#define GST_STR_FOURCC(f)               ((guint32)(((f)[0])|((f)[1]<<8)|((f)[2]<<16)|((f)[3]<<24)))
</MACRO>
<MACRO>
<NAME>GST_FOURCC_FORMAT</NAME>
#define GST_FOURCC_FORMAT "c%c%c%c"
</MACRO>
<MACRO>
<NAME>GST_FOURCC_ARGS</NAME>
#define GST_FOURCC_ARGS(fourcc)               \
  __GST_PRINT_CHAR((fourcc) & 0xff),          \
  __GST_PRINT_CHAR(((fourcc) >> 8) & 0xff),   \
  __GST_PRINT_CHAR(((fourcc) >> 16) & 0xff),  \
  __GST_PRINT_CHAR(((fourcc) >> 24) & 0xff)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_INT_RANGE</NAME>
#define GST_VALUE_HOLDS_INT_RANGE(x)      ((x) != NULL && G_VALUE_TYPE(x) == _gst_int_range_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_INT64_RANGE</NAME>
#define GST_VALUE_HOLDS_INT64_RANGE(x)    ((x) != NULL && G_VALUE_TYPE(x) == _gst_int64_range_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_DOUBLE_RANGE</NAME>
#define GST_VALUE_HOLDS_DOUBLE_RANGE(x)   ((x) != NULL && G_VALUE_TYPE(x) == _gst_double_range_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_FRACTION_RANGE</NAME>
#define GST_VALUE_HOLDS_FRACTION_RANGE(x) ((x) != NULL && G_VALUE_TYPE(x) == _gst_fraction_range_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_LIST</NAME>
#define GST_VALUE_HOLDS_LIST(x)         ((x) != NULL && G_VALUE_TYPE(x) == _gst_value_list_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_ARRAY</NAME>
#define GST_VALUE_HOLDS_ARRAY(x)        ((x) != NULL && G_VALUE_TYPE(x) == _gst_value_array_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_CAPS</NAME>
#define GST_VALUE_HOLDS_CAPS(x)         ((x) != NULL && G_VALUE_TYPE(x) == _gst_caps_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_STRUCTURE</NAME>
#define GST_VALUE_HOLDS_STRUCTURE(x)            (G_VALUE_HOLDS((x), _gst_structure_type))
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_CAPS_FEATURES</NAME>
#define GST_VALUE_HOLDS_CAPS_FEATURES(x)        (G_VALUE_HOLDS((x), _gst_caps_features_type))
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_BUFFER</NAME>
#define GST_VALUE_HOLDS_BUFFER(x)       ((x) != NULL && G_VALUE_TYPE(x) == _gst_buffer_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_SAMPLE</NAME>
#define GST_VALUE_HOLDS_SAMPLE(x)       ((x) != NULL && G_VALUE_TYPE(x) == _gst_sample_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_FRACTION</NAME>
#define GST_VALUE_HOLDS_FRACTION(x)     ((x) != NULL && G_VALUE_TYPE(x) == _gst_fraction_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_DATE_TIME</NAME>
#define GST_VALUE_HOLDS_DATE_TIME(x)    ((x) != NULL && G_VALUE_TYPE(x) == _gst_date_time_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_BITMASK</NAME>
#define GST_VALUE_HOLDS_BITMASK(x)      ((x) != NULL && G_VALUE_TYPE(x) == _gst_bitmask_type)
</MACRO>
<MACRO>
<NAME>GST_VALUE_HOLDS_FLAG_SET</NAME>
#define GST_VALUE_HOLDS_FLAG_SET(x)     (G_TYPE_CHECK_VALUE_TYPE ((x), GST_TYPE_FLAG_SET))
</MACRO>
<MACRO>
<NAME>GST_FLAG_SET_MASK_EXACT</NAME>
#define GST_FLAG_SET_MASK_EXACT ((guint)(-1))
</MACRO>
<MACRO>
<NAME>GST_TYPE_INT_RANGE</NAME>
#define GST_TYPE_INT_RANGE               (_gst_int_range_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_INT64_RANGE</NAME>
#define GST_TYPE_INT64_RANGE             (_gst_int64_range_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_DOUBLE_RANGE</NAME>
#define GST_TYPE_DOUBLE_RANGE            (_gst_double_range_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_FRACTION_RANGE</NAME>
#define GST_TYPE_FRACTION_RANGE           (_gst_fraction_range_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_LIST</NAME>
#define GST_TYPE_LIST                    (_gst_value_list_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_ARRAY</NAME>
#define GST_TYPE_ARRAY                   (_gst_value_array_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_FRACTION</NAME>
#define GST_TYPE_FRACTION                (_gst_fraction_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_BITMASK</NAME>
#define GST_TYPE_BITMASK                 (_gst_bitmask_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_FLAG_SET</NAME>
#define GST_TYPE_FLAG_SET                   (_gst_flagset_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_G_THREAD</NAME>
#define GST_TYPE_G_THREAD                gst_g_thread_get_type ()
</MACRO>
<MACRO>
<NAME>GST_VALUE_LESS_THAN</NAME>
#define GST_VALUE_LESS_THAN              (-1)
</MACRO>
<MACRO>
<NAME>GST_VALUE_EQUAL</NAME>
#define GST_VALUE_EQUAL                   0
</MACRO>
<MACRO>
<NAME>GST_VALUE_GREATER_THAN</NAME>
#define GST_VALUE_GREATER_THAN            1
</MACRO>
<MACRO>
<NAME>GST_VALUE_UNORDERED</NAME>
#define GST_VALUE_UNORDERED               2
</MACRO>
<USER_FUNCTION>
<NAME>GstValueCompareFunc</NAME>
<RETURNS>gint </RETURNS>
const GValue *value1,
                                              const GValue *value2
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstValueSerializeFunc</NAME>
<RETURNS>gchar *</RETURNS>
const GValue *value1
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstValueDeserializeFunc</NAME>
<RETURNS>gboolean </RETURNS>
GValue       *dest,
                                              const gchar  *s
</USER_FUNCTION>
<STRUCT>
<NAME>GstValueTable</NAME>
struct _GstValueTable {
  GType type;
  GstValueCompareFunc compare;
  GstValueSerializeFunc serialize;
  GstValueDeserializeFunc deserialize;

  /*< private >*/
  gpointer _gst_reserved [GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_int_range_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_int64_range_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_double_range_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_fraction_range_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_fraction_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_bitmask_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_flagset_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_g_thread_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_value_register</NAME>
<RETURNS>void             </RETURNS>
const GstValueTable   *table
</FUNCTION>
<FUNCTION>
<NAME>gst_value_init_and_copy</NAME>
<RETURNS>void             </RETURNS>
GValue                *dest, const GValue          *src
</FUNCTION>
<FUNCTION>
<NAME>gst_value_serialize</NAME>
<RETURNS>gchar  *         </RETURNS>
const GValue          *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_deserialize</NAME>
<RETURNS>gboolean         </RETURNS>
GValue                *dest, const gchar           *src
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_append_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GValue   *append_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_append_and_take_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, GValue   *append_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_prepend_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GValue   *prepend_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_concat</NAME>
<RETURNS>void             </RETURNS>
GValue         *dest, const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_merge</NAME>
<RETURNS>void             </RETURNS>
GValue         *dest, const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_get_size</NAME>
<RETURNS>guint            </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_list_get_value</NAME>
<RETURNS>const GValue  *  </RETURNS>
const GValue   *value, guint          index
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_append_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GValue   *append_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_append_and_take_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, GValue   *append_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_prepend_value</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GValue   *prepend_value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_get_size</NAME>
<RETURNS>guint            </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_array_get_value</NAME>
<RETURNS>const GValue  *  </RETURNS>
const GValue   *value, guint          index
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_int_range</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gint           start, gint           end
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_int_range_step</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gint           start, gint           end, gint           step
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int_range_min</NAME>
<RETURNS>gint             </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int_range_max</NAME>
<RETURNS>gint             </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int_range_step</NAME>
<RETURNS>gint             </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_int64_range</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gint64         start, gint64         end
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_int64_range_step</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gint64         start, gint64         end, gint64         step
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int64_range_min</NAME>
<RETURNS>gint64           </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int64_range_max</NAME>
<RETURNS>gint64           </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_int64_range_step</NAME>
<RETURNS>gint64           </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_double_range</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gdouble        start, gdouble        end
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_double_range_min</NAME>
<RETURNS>gdouble          </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_double_range_max</NAME>
<RETURNS>gdouble          </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_caps</NAME>
<RETURNS>const GstCaps  * </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_caps</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GstCaps  *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_structure</NAME>
<RETURNS>const GstStructure  *</RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_structure</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GstStructure  *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_caps_features</NAME>
<RETURNS>const GstCapsFeatures  *</RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_caps_features</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GstCapsFeatures  *features
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_fraction</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, gint           numerator, gint           denominator
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_fraction_numerator</NAME>
<RETURNS>gint             </RETURNS>
const GValue  *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_fraction_denominator</NAME>
<RETURNS>gint             </RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_fraction_multiply</NAME>
<RETURNS>gboolean         </RETURNS>
GValue         *product, const GValue   *factor1, const GValue   *factor2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_fraction_subtract</NAME>
<RETURNS>gboolean         </RETURNS>
GValue * dest, const GValue * minuend, const GValue * subtrahend
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_fraction_range</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, const GValue   *start, const GValue   *end
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_fraction_range_full</NAME>
<RETURNS>void             </RETURNS>
GValue       *value, gint numerator_start, gint denominator_start, gint numerator_end, gint denominator_end
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_fraction_range_min</NAME>
<RETURNS>const GValue     *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_fraction_range_max</NAME>
<RETURNS>const GValue     *</RETURNS>
const GValue *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_bitmask</NAME>
<RETURNS>guint64          </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_bitmask</NAME>
<RETURNS>void             </RETURNS>
GValue         *value, guint64         bitmask
</FUNCTION>
<FUNCTION>
<NAME>gst_value_set_flagset</NAME>
<RETURNS>void             </RETURNS>
GValue * value, guint flags, guint mask
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_flagset_flags</NAME>
<RETURNS>guint            </RETURNS>
const GValue * value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_get_flagset_mask</NAME>
<RETURNS>guint            </RETURNS>
const GValue * value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_compare</NAME>
<RETURNS>gint             </RETURNS>
const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_can_compare</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_is_subset</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_union</NAME>
<RETURNS>gboolean         </RETURNS>
GValue         *dest, const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_can_union</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_intersect</NAME>
<RETURNS>gboolean         </RETURNS>
GValue         *dest, const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_can_intersect</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *value1, const GValue   *value2
</FUNCTION>
<FUNCTION>
<NAME>gst_value_subtract</NAME>
<RETURNS>gboolean         </RETURNS>
GValue         *dest, const GValue   *minuend, const GValue   *subtrahend
</FUNCTION>
<FUNCTION>
<NAME>gst_value_can_subtract</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *minuend, const GValue   *subtrahend
</FUNCTION>
<FUNCTION>
<NAME>gst_value_is_fixed</NAME>
<RETURNS>gboolean         </RETURNS>
const GValue   *value
</FUNCTION>
<FUNCTION>
<NAME>gst_value_fixate</NAME>
<RETURNS>gboolean         </RETURNS>
GValue         *dest, const GValue   *src
</FUNCTION>
<FUNCTION>
<NAME>gst_flagset_register</NAME>
<RETURNS>GType 		</RETURNS>
GType flags_type
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TOC_SETTER</NAME>
#define GST_TYPE_TOC_SETTER              (gst_toc_setter_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TOC_SETTER</NAME>
#define GST_TOC_SETTER(obj)              (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TOC_SETTER, GstTocSetter))
</MACRO>
<MACRO>
<NAME>GST_IS_TOC_SETTER</NAME>
#define GST_IS_TOC_SETTER(obj)           (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TOC_SETTER))
</MACRO>
<MACRO>
<NAME>GST_TOC_SETTER_GET_IFACE</NAME>
#define GST_TOC_SETTER_GET_IFACE(obj)    (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_TOC_SETTER, GstTocSetterInterface))
</MACRO>
<STRUCT>
<NAME>GstTocSetterInterface</NAME>
struct _GstTocSetterInterface
{
  GTypeInterface g_iface;

  /* signals */

  /* virtual table */
};
</STRUCT>
<FUNCTION>
<NAME>gst_toc_setter_get_type</NAME>
<RETURNS>GType          </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_setter_reset</NAME>
<RETURNS>void           </RETURNS>
GstTocSetter *setter
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_setter_get_toc</NAME>
<RETURNS>GstToc  *      </RETURNS>
GstTocSetter *setter
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_setter_set_toc</NAME>
<RETURNS>void           </RETURNS>
GstTocSetter *setter, GstToc *toc
</FUNCTION>
<STRUCT>
<NAME>GstTocSetter</NAME>
</STRUCT>
<MACRO>
<NAME>GST_DISABLE_GST_DEBUG</NAME>
#define GST_DISABLE_GST_DEBUG 1
</MACRO>
<MACRO>
<NAME>GST_DISABLE_PARSE</NAME>
#define GST_DISABLE_PARSE 1
</MACRO>
<MACRO>
<NAME>GST_DISABLE_TRACE</NAME>
#define GST_DISABLE_TRACE 1
</MACRO>
<MACRO>
<NAME>GST_DISABLE_ALLOC_TRACE</NAME>
#define GST_DISABLE_ALLOC_TRACE 1
</MACRO>
<MACRO>
<NAME>GST_DISABLE_REGISTRY</NAME>
#define GST_DISABLE_REGISTRY 1
</MACRO>
<MACRO>
<NAME>GST_DISABLE_PLUGIN</NAME>
#define GST_DISABLE_PLUGIN 1
</MACRO>
<MACRO>
<NAME>GST_HAVE_GLIB_2_8</NAME>
#define GST_HAVE_GLIB_2_8 1
</MACRO>
<MACRO>
<NAME>GST_PADDING</NAME>
#define GST_PADDING		4
</MACRO>
<MACRO>
<NAME>GST_PADDING_INIT</NAME>
#define GST_PADDING_INIT	{ NULL }
</MACRO>
<MACRO>
<NAME>GST_PADDING_LARGE</NAME>
#define GST_PADDING_LARGE	20
</MACRO>
<MACRO>
<NAME>GST_HAVE_UNALIGNED_ACCESS</NAME>
#define GST_HAVE_UNALIGNED_ACCESS 1
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_EXPORT</NAME>
#define GST_PLUGIN_EXPORT __declspec(dllexport) extern
</MACRO>
<MACRO>
<NAME>GST_EXPORT</NAME>
#define GST_EXPORT __declspec(dllexport) extern
</MACRO>
<MACRO>
<NAME>GST_TYPE_ATOMIC_QUEUE</NAME>
#define GST_TYPE_ATOMIC_QUEUE (gst_atomic_queue_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_atomic_queue_get_type</NAME>
<RETURNS>GType               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_new</NAME>
<RETURNS>GstAtomicQueue  *   </RETURNS>
guint initial_size
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_ref</NAME>
<RETURNS>void                </RETURNS>
GstAtomicQueue * queue
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_unref</NAME>
<RETURNS>void                </RETURNS>
GstAtomicQueue * queue
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_push</NAME>
<RETURNS>void                </RETURNS>
GstAtomicQueue* queue, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_pop</NAME>
<RETURNS>gpointer            </RETURNS>
GstAtomicQueue* queue
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_peek</NAME>
<RETURNS>gpointer            </RETURNS>
GstAtomicQueue* queue
</FUNCTION>
<FUNCTION>
<NAME>gst_atomic_queue_length</NAME>
<RETURNS>guint               </RETURNS>
GstAtomicQueue * queue
</FUNCTION>
<STRUCT>
<NAME>GstAtomicQueue</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_ALLOCATOR</NAME>
#define GST_TYPE_ALLOCATOR                 (gst_allocator_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_ALLOCATOR</NAME>
#define GST_IS_ALLOCATOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_IS_ALLOCATOR_CLASS</NAME>
#define GST_IS_ALLOCATOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_ALLOCATOR))
</MACRO>
<MACRO>
<NAME>GST_ALLOCATOR_GET_CLASS</NAME>
#define GST_ALLOCATOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_ALLOCATOR, GstAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_ALLOCATOR</NAME>
#define GST_ALLOCATOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_ALLOCATOR, GstAllocator))
</MACRO>
<MACRO>
<NAME>GST_ALLOCATOR_CLASS</NAME>
#define GST_ALLOCATOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_ALLOCATOR, GstAllocatorClass))
</MACRO>
<MACRO>
<NAME>GST_ALLOCATOR_CAST</NAME>
#define GST_ALLOCATOR_CAST(obj)            ((GstAllocator *)(obj))
</MACRO>
<MACRO>
<NAME>GST_TYPE_ALLOCATION_PARAMS</NAME>
#define GST_TYPE_ALLOCATION_PARAMS (gst_allocation_params_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_allocation_params_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<VARIABLE>
<NAME>gst_memory_alignment</NAME>
GST_EXPORT gsize gst_memory_alignment;
</VARIABLE>
<MACRO>
<NAME>GST_ALLOCATOR_SYSMEM</NAME>
#define GST_ALLOCATOR_SYSMEM   "SystemMemory"
</MACRO>
<STRUCT>
<NAME>GstAllocationParams</NAME>
struct _GstAllocationParams {
  GstMemoryFlags flags;
  gsize          align;
  gsize          prefix;
  gsize          padding;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<ENUM>
<NAME>GstAllocatorFlags</NAME>
typedef enum {
  GST_ALLOCATOR_FLAG_CUSTOM_ALLOC  = (GST_OBJECT_FLAG_LAST << 0),

  GST_ALLOCATOR_FLAG_LAST          = (GST_OBJECT_FLAG_LAST << 16)
} GstAllocatorFlags;
</ENUM>
<STRUCT>
<NAME>GstAllocator</NAME>
struct _GstAllocator
{
  GstObject  object;

  const gchar               *mem_type;

  /*< public >*/
  GstMemoryMapFunction       mem_map;
  GstMemoryUnmapFunction     mem_unmap;

  GstMemoryCopyFunction      mem_copy;
  GstMemoryShareFunction     mem_share;
  GstMemoryIsSpanFunction    mem_is_span;

  GstMemoryMapFullFunction   mem_map_full;
  GstMemoryUnmapFullFunction mem_unmap_full;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING - 2];

  GstAllocatorPrivate *priv;
};
</STRUCT>
<STRUCT>
<NAME>GstAllocatorClass</NAME>
struct _GstAllocatorClass {
  GstObjectClass object_class;

  /*< public >*/
  GstMemory *  (*alloc)      (GstAllocator *allocator, gsize size,
                              GstAllocationParams *params);
  void         (*free)       (GstAllocator *allocator, GstMemory *memory);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_allocator_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_allocator_register</NAME>
<RETURNS>void            </RETURNS>
const gchar *name, GstAllocator *allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_allocator_find</NAME>
<RETURNS>GstAllocator  * </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_allocator_set_default</NAME>
<RETURNS>void            </RETURNS>
GstAllocator * allocator
</FUNCTION>
<FUNCTION>
<NAME>gst_allocation_params_init</NAME>
<RETURNS>void            </RETURNS>
GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_allocation_params_copy</NAME>
<RETURNS>GstAllocationParams  *</RETURNS>
const GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_allocation_params_free</NAME>
<RETURNS>void            </RETURNS>
GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_allocator_alloc</NAME>
<RETURNS>GstMemory  *    </RETURNS>
GstAllocator * allocator, gsize size, GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_allocator_free</NAME>
<RETURNS>void            </RETURNS>
GstAllocator * allocator, GstMemory *memory
</FUNCTION>
<FUNCTION>
<NAME>gst_memory_new_wrapped</NAME>
<RETURNS>GstMemory  *    </RETURNS>
GstMemoryFlags flags, gpointer data, gsize maxsize, gsize offset, gsize size, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<STRUCT>
<NAME>GstAllocatorPrivate</NAME>
</STRUCT>
<USER_FUNCTION>
<NAME>GstTaskFunction</NAME>
<RETURNS>void </RETURNS>
gpointer user_data
</USER_FUNCTION>
<MACRO>
<NAME>GST_TYPE_TASK</NAME>
#define GST_TYPE_TASK                   (gst_task_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TASK</NAME>
#define GST_TASK(task)                  (G_TYPE_CHECK_INSTANCE_CAST ((task), GST_TYPE_TASK, GstTask))
</MACRO>
<MACRO>
<NAME>GST_IS_TASK</NAME>
#define GST_IS_TASK(task)               (G_TYPE_CHECK_INSTANCE_TYPE ((task), GST_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>GST_TASK_CLASS</NAME>
#define GST_TASK_CLASS(tclass)          (G_TYPE_CHECK_CLASS_CAST ((tclass), GST_TYPE_TASK, GstTaskClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TASK_CLASS</NAME>
#define GST_IS_TASK_CLASS(tclass)       (G_TYPE_CHECK_CLASS_TYPE ((tclass), GST_TYPE_TASK))
</MACRO>
<MACRO>
<NAME>GST_TASK_GET_CLASS</NAME>
#define GST_TASK_GET_CLASS(task)        (G_TYPE_INSTANCE_GET_CLASS ((task), GST_TYPE_TASK, GstTaskClass))
</MACRO>
<MACRO>
<NAME>GST_TASK_CAST</NAME>
#define GST_TASK_CAST(task)             ((GstTask*)(task))
</MACRO>
<ENUM>
<NAME>GstTaskState</NAME>
typedef enum {
  GST_TASK_STARTED,
  GST_TASK_STOPPED,
  GST_TASK_PAUSED
} GstTaskState;
</ENUM>
<MACRO>
<NAME>GST_TASK_STATE</NAME>
#define GST_TASK_STATE(task)            (GST_TASK_CAST(task)->state)
</MACRO>
<MACRO>
<NAME>GST_TASK_GET_COND</NAME>
#define GST_TASK_GET_COND(task)         (&GST_TASK_CAST(task)->cond)
</MACRO>
<MACRO>
<NAME>GST_TASK_WAIT</NAME>
#define GST_TASK_WAIT(task)             g_cond_wait(GST_TASK_GET_COND (task), GST_OBJECT_GET_LOCK (task))
</MACRO>
<MACRO>
<NAME>GST_TASK_SIGNAL</NAME>
#define GST_TASK_SIGNAL(task)           g_cond_signal(GST_TASK_GET_COND (task))
</MACRO>
<MACRO>
<NAME>GST_TASK_BROADCAST</NAME>
#define GST_TASK_BROADCAST(task)        g_cond_broadcast(GST_TASK_GET_COND (task))
</MACRO>
<MACRO>
<NAME>GST_TASK_GET_LOCK</NAME>
#define GST_TASK_GET_LOCK(task)         (GST_TASK_CAST(task)->lock)
</MACRO>
<USER_FUNCTION>
<NAME>GstTaskThreadFunc</NAME>
<RETURNS>void </RETURNS>
GstTask *task, GThread *thread, gpointer user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstTask</NAME>
struct _GstTask {
  GstObject      object;

  /*< public >*/ /* with LOCK */
  GstTaskState     state;
  GCond            cond;

  GRecMutex       *lock;

  GstTaskFunction  func;
  gpointer         user_data;
  GDestroyNotify   notify;

  gboolean         running;

  /*< private >*/
  GThread         *thread;

  GstTaskPrivate  *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstTaskClass</NAME>
struct _GstTaskClass {
  GstObjectClass parent_class;

  /*< private >*/
  GstTaskPool *pool;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_task_cleanup_all</NAME>
<RETURNS>void             </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_task_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_task_new</NAME>
<RETURNS>GstTask *        </RETURNS>
GstTaskFunction func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_task_set_lock</NAME>
<RETURNS>void             </RETURNS>
GstTask *task, GRecMutex *mutex
</FUNCTION>
<FUNCTION>
<NAME>gst_task_get_pool</NAME>
<RETURNS>GstTaskPool  *   </RETURNS>
GstTask *task
</FUNCTION>
<FUNCTION>
<NAME>gst_task_set_pool</NAME>
<RETURNS>void             </RETURNS>
GstTask *task, GstTaskPool *pool
</FUNCTION>
<FUNCTION>
<NAME>gst_task_set_enter_callback</NAME>
<RETURNS>void             </RETURNS>
GstTask *task, GstTaskThreadFunc enter_func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_task_set_leave_callback</NAME>
<RETURNS>void             </RETURNS>
GstTask *task, GstTaskThreadFunc leave_func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_task_get_state</NAME>
<RETURNS>GstTaskState     </RETURNS>
GstTask *task
</FUNCTION>
<FUNCTION>
<NAME>gst_task_set_state</NAME>
<RETURNS>gboolean         </RETURNS>
GstTask *task, GstTaskState state
</FUNCTION>
<FUNCTION>
<NAME>gst_task_start</NAME>
<RETURNS>gboolean         </RETURNS>
GstTask *task
</FUNCTION>
<FUNCTION>
<NAME>gst_task_stop</NAME>
<RETURNS>gboolean         </RETURNS>
GstTask *task
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pause</NAME>
<RETURNS>gboolean         </RETURNS>
GstTask *task
</FUNCTION>
<FUNCTION>
<NAME>gst_task_join</NAME>
<RETURNS>gboolean         </RETURNS>
GstTask *task
</FUNCTION>
<STRUCT>
<NAME>GstTaskPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PRESET</NAME>
#define GST_TYPE_PRESET               (gst_preset_get_type())
</MACRO>
<MACRO>
<NAME>GST_PRESET</NAME>
#define GST_PRESET(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PRESET, GstPreset))
</MACRO>
<MACRO>
<NAME>GST_IS_PRESET</NAME>
#define GST_IS_PRESET(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PRESET))
</MACRO>
<MACRO>
<NAME>GST_PRESET_GET_INTERFACE</NAME>
#define GST_PRESET_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_PRESET, GstPresetInterface))
</MACRO>
<STRUCT>
<NAME>GstPresetInterface</NAME>
struct _GstPresetInterface
{
  GTypeInterface parent;

  /* methods */
  gchar**      (*get_preset_names)    (GstPreset *preset);

  gchar**      (*get_property_names)  (GstPreset *preset);

  gboolean     (*load_preset)         (GstPreset *preset, const gchar *name);
  gboolean     (*save_preset)         (GstPreset *preset, const gchar *name);
  gboolean     (*rename_preset)       (GstPreset *preset, const gchar *old_name,
                                       const gchar *new_name);
  gboolean     (*delete_preset)       (GstPreset *preset, const gchar *name);

  gboolean     (*set_meta)            (GstPreset *preset, const gchar *name,
                                       const gchar *tag, const gchar *value);
  gboolean     (*get_meta)            (GstPreset *preset, const gchar *name,
                                       const gchar *tag, gchar **value);
  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_preset_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_get_preset_names</NAME>
<RETURNS>gchar **      </RETURNS>
GstPreset *preset
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_get_property_names</NAME>
<RETURNS>gchar **      </RETURNS>
GstPreset *preset
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_load_preset</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_save_preset</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_rename_preset</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *old_name, const gchar *new_name
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_delete_preset</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_set_meta</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *name, const gchar *tag, const gchar *value
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_get_meta</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset, const gchar *name, const gchar *tag, gchar **value
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_set_app_dir</NAME>
<RETURNS>gboolean      </RETURNS>
const gchar *app_dir
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_get_app_dir</NAME>
<RETURNS>const gchar  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_preset_is_editable</NAME>
<RETURNS>gboolean      </RETURNS>
GstPreset *preset
</FUNCTION>
<STRUCT>
<NAME>GstPreset</NAME>
</STRUCT>
<MACRO>
<NAME>GST_PROTECTION_SYSTEM_ID_CAPS_FIELD</NAME>
#define GST_PROTECTION_SYSTEM_ID_CAPS_FIELD "protection-system"
</MACRO>
<STRUCT>
<NAME>GstProtectionMeta</NAME>
struct _GstProtectionMeta
{
  GstMeta meta;

  GstStructure *info;
};
</STRUCT>
<FUNCTION>
<NAME>gst_protection_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_PROTECTION_META_API_TYPE</NAME>
#define GST_PROTECTION_META_API_TYPE (gst_protection_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_protection_meta</NAME>
#define gst_buffer_get_protection_meta(b) \
    ((GstProtectionMeta*)gst_buffer_get_meta ((b), GST_PROTECTION_META_API_TYPE))
</MACRO>
<MACRO>
<NAME>GST_PROTECTION_META_INFO</NAME>
#define GST_PROTECTION_META_INFO (gst_protection_meta_get_info())
</MACRO>
<FUNCTION>
<NAME>gst_protection_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  *</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_add_protection_meta</NAME>
<RETURNS>GstProtectionMeta  *</RETURNS>
GstBuffer * buffer, GstStructure * info
</FUNCTION>
<FUNCTION>
<NAME>gst_protection_select_system</NAME>
<RETURNS>const gchar  *</RETURNS>
const gchar ** system_identifiers
</FUNCTION>
<MACRO>
<NAME>GST_META_CAST</NAME>
#define GST_META_CAST(meta)   ((GstMeta *)(meta))
</MACRO>
<ENUM>
<NAME>GstMetaFlags</NAME>
typedef enum {
  GST_META_FLAG_NONE        = 0,
  GST_META_FLAG_READONLY    = (1 << 0),
  GST_META_FLAG_POOLED      = (1 << 1),
  GST_META_FLAG_LOCKED      = (1 << 2),

  GST_META_FLAG_LAST        = (1 << 16)
} GstMetaFlags;
</ENUM>
<MACRO>
<NAME>GST_META_FLAGS</NAME>
#define GST_META_FLAGS(meta)  (GST_META_CAST (meta)->flags)
</MACRO>
<MACRO>
<NAME>GST_META_FLAG_IS_SET</NAME>
#define GST_META_FLAG_IS_SET(meta,flag)        !!(GST_META_FLAGS (meta) & (flag))
</MACRO>
<MACRO>
<NAME>GST_META_FLAG_SET</NAME>
#define GST_META_FLAG_SET(meta,flag)           (GST_META_FLAGS (meta) |= (flag))
</MACRO>
<MACRO>
<NAME>GST_META_FLAG_UNSET</NAME>
#define GST_META_FLAG_UNSET(meta,flag)         (GST_META_FLAGS (meta) &= ~(flag))
</MACRO>
<MACRO>
<NAME>GST_META_TAG_MEMORY_STR</NAME>
#define GST_META_TAG_MEMORY_STR "memory"
</MACRO>
<STRUCT>
<NAME>GstMeta</NAME>
struct _GstMeta {
  GstMetaFlags       flags;
  const GstMetaInfo *info;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstMetaInitFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstMeta *meta, gpointer params, GstBuffer *buffer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMetaFreeFunction</NAME>
<RETURNS>void </RETURNS>
GstMeta *meta, GstBuffer *buffer
</USER_FUNCTION>
<MACRO>
<NAME>GST_META_TRANSFORM_IS_COPY</NAME>
#define GST_META_TRANSFORM_IS_COPY(type) ((type) == _gst_meta_transform_copy)
</MACRO>
<STRUCT>
<NAME>GstMetaTransformCopy</NAME>
typedef struct {
  gboolean region;
  gsize offset;
  gsize size;
} GstMetaTransformCopy;
</STRUCT>
<USER_FUNCTION>
<NAME>GstMetaTransformFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstBuffer *transbuf,
                                              GstMeta *meta, GstBuffer *buffer,
                                              GQuark type, gpointer data
</USER_FUNCTION>
<STRUCT>
<NAME>GstMetaInfo</NAME>
struct _GstMetaInfo {
  GType                      api;
  GType                      type;
  gsize                      size;

  GstMetaInitFunction        init_func;
  GstMetaFreeFunction        free_func;
  GstMetaTransformFunction   transform_func;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_meta_api_type_register</NAME>
<RETURNS>GType                 </RETURNS>
const gchar *api, const gchar **tags
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_api_type_has_tag</NAME>
<RETURNS>gboolean              </RETURNS>
GType api, GQuark tag
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_register</NAME>
<RETURNS>const GstMetaInfo  *  </RETURNS>
GType api, const gchar *impl, gsize size, GstMetaInitFunction      init_func, GstMetaFreeFunction      free_func, GstMetaTransformFunction transform_func
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  *  </RETURNS>
const gchar * impl
</FUNCTION>
<FUNCTION>
<NAME>gst_meta_api_type_get_tags</NAME>
<RETURNS>const gchar * const*</RETURNS>
GType api
</FUNCTION>
<MACRO>
<NAME>GST_META_TAG_MEMORY</NAME>
<DEPRECATED/>
#define GST_META_TAG_MEMORY (_gst_meta_tag_memory)
</MACRO>
<MACRO>
<NAME>GST_TYPE_CONTEXT</NAME>
#define GST_TYPE_CONTEXT                         (_gst_context_type)
</MACRO>
<MACRO>
<NAME>GST_IS_CONTEXT</NAME>
#define GST_IS_CONTEXT(obj)                      (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_CONTEXT))
</MACRO>
<MACRO>
<NAME>GST_CONTEXT_CAST</NAME>
#define GST_CONTEXT_CAST(obj)                    ((GstContext*)(obj))
</MACRO>
<MACRO>
<NAME>GST_CONTEXT</NAME>
#define GST_CONTEXT(obj)                         (GST_CONTEXT_CAST(obj))
</MACRO>
<FUNCTION>
<NAME>gst_context_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_context_ref</NAME>
<RETURNS>GstContext  * </RETURNS>
GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_unref</NAME>
<RETURNS>void  </RETURNS>
GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_copy</NAME>
<RETURNS>GstContext  * </RETURNS>
const GstContext * context
</FUNCTION>
<MACRO>
<NAME>gst_context_is_writable</NAME>
#define         gst_context_is_writable(context)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (context))
</MACRO>
<MACRO>
<NAME>gst_context_make_writable</NAME>
#define         gst_context_make_writable(context)  GST_CONTEXT_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (context)))
</MACRO>
<FUNCTION>
<NAME>gst_context_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstContext **old_context, GstContext *new_context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_new</NAME>
<RETURNS>GstContext  *          </RETURNS>
const gchar * context_type, gboolean persistent
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_context_type</NAME>
<RETURNS>const gchar  *         </RETURNS>
const GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_has_context_type</NAME>
<RETURNS>gboolean               </RETURNS>
const GstContext * context, const gchar * context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_context_get_structure</NAME>
<RETURNS>const GstStructure  *  </RETURNS>
const GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_writable_structure</NAME>
<RETURNS>GstStructure  *        </RETURNS>
GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_context_is_persistent</NAME>
<RETURNS>gboolean               </RETURNS>
const GstContext * context
</FUNCTION>
<STRUCT>
<NAME>GstContext</NAME>
</STRUCT>
<MACRO>
<NAME>GST_PARAM_CONTROLLABLE</NAME>
#define	GST_PARAM_CONTROLLABLE	(1 << (G_PARAM_USER_SHIFT + 1))
</MACRO>
<MACRO>
<NAME>GST_PARAM_MUTABLE_READY</NAME>
#define GST_PARAM_MUTABLE_READY  (1 << (G_PARAM_USER_SHIFT + 2))
</MACRO>
<MACRO>
<NAME>GST_PARAM_MUTABLE_PAUSED</NAME>
#define GST_PARAM_MUTABLE_PAUSED  (1 << (G_PARAM_USER_SHIFT + 3))
</MACRO>
<MACRO>
<NAME>GST_PARAM_MUTABLE_PLAYING</NAME>
#define GST_PARAM_MUTABLE_PLAYING  (1 << (G_PARAM_USER_SHIFT + 4))
</MACRO>
<MACRO>
<NAME>GST_PARAM_USER_SHIFT</NAME>
#define	GST_PARAM_USER_SHIFT	(1 << (G_PARAM_USER_SHIFT + 8))
</MACRO>
<MACRO>
<NAME>GST_TYPE_PARAM_FRACTION</NAME>
#define GST_TYPE_PARAM_FRACTION           (gst_param_spec_fraction_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PARAM_SPEC_FRACTION</NAME>
#define GST_IS_PARAM_SPEC_FRACTION(pspec) (G_TYPE_CHECK_INSTANCE_TYPE ((pspec), GST_TYPE_PARAM_FRACTION))
</MACRO>
<MACRO>
<NAME>GST_PARAM_SPEC_FRACTION</NAME>
#define GST_PARAM_SPEC_FRACTION(pspec)    (G_TYPE_CHECK_INSTANCE_CAST ((pspec), GST_TYPE_PARAM_FRACTION, GstParamSpecFraction))
</MACRO>
<FUNCTION>
<NAME>gst_param_spec_fraction_get_type</NAME>
<RETURNS>GType   </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstParamSpecFraction</NAME>
struct _GstParamSpecFraction {
  GParamSpec    parent_instance;

  gint          min_num, min_den;
  gint          max_num, max_den;
  gint          def_num, def_den;
};
</STRUCT>
<FUNCTION>
<NAME>gst_param_spec_fraction</NAME>
<RETURNS>GParamSpec   * </RETURNS>
const gchar * name, const gchar * nick, const gchar * blurb, gint min_num, gint min_denom, gint max_num, gint max_denom, gint default_num, gint default_denom, GParamFlags flags
</FUNCTION>
<ENUM>
<NAME>GstCoreError</NAME>
typedef enum
{
  GST_CORE_ERROR_FAILED = 1,
  GST_CORE_ERROR_TOO_LAZY,
  GST_CORE_ERROR_NOT_IMPLEMENTED,
  GST_CORE_ERROR_STATE_CHANGE,
  GST_CORE_ERROR_PAD,
  GST_CORE_ERROR_THREAD,
  GST_CORE_ERROR_NEGOTIATION,
  GST_CORE_ERROR_EVENT,
  GST_CORE_ERROR_SEEK,
  GST_CORE_ERROR_CAPS,
  GST_CORE_ERROR_TAG,
  GST_CORE_ERROR_MISSING_PLUGIN,
  GST_CORE_ERROR_CLOCK,
  GST_CORE_ERROR_DISABLED,
  GST_CORE_ERROR_NUM_ERRORS
} GstCoreError;
</ENUM>
<ENUM>
<NAME>GstLibraryError</NAME>
typedef enum
{
  GST_LIBRARY_ERROR_FAILED = 1,
  GST_LIBRARY_ERROR_TOO_LAZY,
  GST_LIBRARY_ERROR_INIT,
  GST_LIBRARY_ERROR_SHUTDOWN,
  GST_LIBRARY_ERROR_SETTINGS,
  GST_LIBRARY_ERROR_ENCODE,
  GST_LIBRARY_ERROR_NUM_ERRORS
} GstLibraryError;
</ENUM>
<ENUM>
<NAME>GstResourceError</NAME>
typedef enum
{
  GST_RESOURCE_ERROR_FAILED = 1,
  GST_RESOURCE_ERROR_TOO_LAZY,
  GST_RESOURCE_ERROR_NOT_FOUND,
  GST_RESOURCE_ERROR_BUSY,
  GST_RESOURCE_ERROR_OPEN_READ,
  GST_RESOURCE_ERROR_OPEN_WRITE,
  GST_RESOURCE_ERROR_OPEN_READ_WRITE,
  GST_RESOURCE_ERROR_CLOSE,
  GST_RESOURCE_ERROR_READ,
  GST_RESOURCE_ERROR_WRITE,
  GST_RESOURCE_ERROR_SEEK,
  GST_RESOURCE_ERROR_SYNC,
  GST_RESOURCE_ERROR_SETTINGS,
  GST_RESOURCE_ERROR_NO_SPACE_LEFT,
  GST_RESOURCE_ERROR_NOT_AUTHORIZED,
  GST_RESOURCE_ERROR_NUM_ERRORS
} GstResourceError;
</ENUM>
<ENUM>
<NAME>GstStreamError</NAME>
typedef enum
{
  GST_STREAM_ERROR_FAILED = 1,
  GST_STREAM_ERROR_TOO_LAZY,
  GST_STREAM_ERROR_NOT_IMPLEMENTED,
  GST_STREAM_ERROR_TYPE_NOT_FOUND,
  GST_STREAM_ERROR_WRONG_TYPE,
  GST_STREAM_ERROR_CODEC_NOT_FOUND,
  GST_STREAM_ERROR_DECODE,
  GST_STREAM_ERROR_ENCODE,
  GST_STREAM_ERROR_DEMUX,
  GST_STREAM_ERROR_MUX,
  GST_STREAM_ERROR_FORMAT,
  GST_STREAM_ERROR_DECRYPT,
  GST_STREAM_ERROR_DECRYPT_NOKEY,
  GST_STREAM_ERROR_NUM_ERRORS
} GstStreamError;
</ENUM>
<MACRO>
<NAME>GST_LIBRARY_ERROR</NAME>
#define GST_LIBRARY_ERROR   gst_library_error_quark ()
</MACRO>
<MACRO>
<NAME>GST_RESOURCE_ERROR</NAME>
#define GST_RESOURCE_ERROR  gst_resource_error_quark ()
</MACRO>
<MACRO>
<NAME>GST_CORE_ERROR</NAME>
#define GST_CORE_ERROR      gst_core_error_quark ()
</MACRO>
<MACRO>
<NAME>GST_STREAM_ERROR</NAME>
#define GST_STREAM_ERROR    gst_stream_error_quark ()
</MACRO>
<MACRO>
<NAME>GST_ERROR_SYSTEM</NAME>
#define GST_ERROR_SYSTEM    ("system error: %s", g_strerror (errno))
</MACRO>
<FUNCTION>
<NAME>gst_error_get_message</NAME>
<RETURNS>gchar  *</RETURNS>
GQuark domain, gint code
</FUNCTION>
<FUNCTION>
<NAME>gst_stream_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_core_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_resource_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_library_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstMessageType</NAME>
typedef enum
{
  GST_MESSAGE_UNKNOWN           = 0,
  GST_MESSAGE_EOS               = (1 << 0),
  GST_MESSAGE_ERROR             = (1 << 1),
  GST_MESSAGE_WARNING           = (1 << 2),
  GST_MESSAGE_INFO              = (1 << 3),
  GST_MESSAGE_TAG               = (1 << 4),
  GST_MESSAGE_BUFFERING         = (1 << 5),
  GST_MESSAGE_STATE_CHANGED     = (1 << 6),
  GST_MESSAGE_STATE_DIRTY       = (1 << 7),
  GST_MESSAGE_STEP_DONE         = (1 << 8),
  GST_MESSAGE_CLOCK_PROVIDE     = (1 << 9),
  GST_MESSAGE_CLOCK_LOST        = (1 << 10),
  GST_MESSAGE_NEW_CLOCK         = (1 << 11),
  GST_MESSAGE_STRUCTURE_CHANGE  = (1 << 12),
  GST_MESSAGE_STREAM_STATUS     = (1 << 13),
  GST_MESSAGE_APPLICATION       = (1 << 14),
  GST_MESSAGE_ELEMENT           = (1 << 15),
  GST_MESSAGE_SEGMENT_START     = (1 << 16),
  GST_MESSAGE_SEGMENT_DONE      = (1 << 17),
  GST_MESSAGE_DURATION_CHANGED  = (1 << 18),
  GST_MESSAGE_LATENCY           = (1 << 19),
  GST_MESSAGE_ASYNC_START       = (1 << 20),
  GST_MESSAGE_ASYNC_DONE        = (1 << 21),
  GST_MESSAGE_REQUEST_STATE     = (1 << 22),
  GST_MESSAGE_STEP_START        = (1 << 23),
  GST_MESSAGE_QOS               = (1 << 24),
  GST_MESSAGE_PROGRESS          = (1 << 25),
  GST_MESSAGE_TOC               = (1 << 26),
  GST_MESSAGE_RESET_TIME        = (1 << 27),
  GST_MESSAGE_STREAM_START      = (1 << 28),
  GST_MESSAGE_NEED_CONTEXT      = (1 << 29),
  GST_MESSAGE_HAVE_CONTEXT      = (1 << 30),
  GST_MESSAGE_EXTENDED          = (1 << 31),
  GST_MESSAGE_DEVICE_ADDED      = GST_MESSAGE_EXTENDED + 1,
  GST_MESSAGE_DEVICE_REMOVED    = GST_MESSAGE_EXTENDED + 2,
  GST_MESSAGE_ANY               = (gint) (0xffffffff)
} GstMessageType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_MESSAGE</NAME>
#define GST_TYPE_MESSAGE                         (_gst_message_type)
</MACRO>
<MACRO>
<NAME>GST_IS_MESSAGE</NAME>
#define GST_IS_MESSAGE(obj)                      (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_MESSAGE))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_CAST</NAME>
#define GST_MESSAGE_CAST(obj)                    ((GstMessage*)(obj))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE</NAME>
#define GST_MESSAGE(obj)                         (GST_MESSAGE_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_GET_LOCK</NAME>
#define GST_MESSAGE_GET_LOCK(message)   (&GST_MESSAGE_CAST(message)->lock)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_LOCK</NAME>
#define GST_MESSAGE_LOCK(message)       g_mutex_lock(GST_MESSAGE_GET_LOCK(message))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_UNLOCK</NAME>
#define GST_MESSAGE_UNLOCK(message)     g_mutex_unlock(GST_MESSAGE_GET_LOCK(message))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_GET_COND</NAME>
#define GST_MESSAGE_GET_COND(message)   (&GST_MESSAGE_CAST(message)->cond)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_WAIT</NAME>
#define GST_MESSAGE_WAIT(message)       g_cond_wait(GST_MESSAGE_GET_COND(message),GST_MESSAGE_GET_LOCK(message))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_SIGNAL</NAME>
#define GST_MESSAGE_SIGNAL(message)     g_cond_signal(GST_MESSAGE_GET_COND(message))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_TYPE</NAME>
#define GST_MESSAGE_TYPE(message)       (GST_MESSAGE_CAST(message)->type)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_TYPE_IS_EXTENDED</NAME>
#define GST_MESSAGE_TYPE_IS_EXTENDED(message)       (!!(GST_MESSAGE_CAST(message)->type & GST_MESSAGE_EXTENDED))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_TYPE_NAME</NAME>
#define GST_MESSAGE_TYPE_NAME(message)  gst_message_type_get_name(GST_MESSAGE_TYPE(message))
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_TIMESTAMP</NAME>
#define GST_MESSAGE_TIMESTAMP(message)  (GST_MESSAGE_CAST(message)->timestamp)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_SRC</NAME>
#define GST_MESSAGE_SRC(message)        (GST_MESSAGE_CAST(message)->src)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_SEQNUM</NAME>
#define GST_MESSAGE_SEQNUM(message)     (GST_MESSAGE_CAST(message)->seqnum)
</MACRO>
<MACRO>
<NAME>GST_MESSAGE_SRC_NAME</NAME>
#define GST_MESSAGE_SRC_NAME(message)   (GST_MESSAGE_SRC(message) ? \
    GST_OBJECT_NAME (GST_MESSAGE_SRC(message)) : "(NULL)")
</MACRO>
<ENUM>
<NAME>GstStructureChangeType</NAME>
typedef enum {
  GST_STRUCTURE_CHANGE_TYPE_PAD_LINK   = 0,
  GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK = 1
} GstStructureChangeType;
</ENUM>
<ENUM>
<NAME>GstStreamStatusType</NAME>
typedef enum {
  GST_STREAM_STATUS_TYPE_CREATE   = 0,
  GST_STREAM_STATUS_TYPE_ENTER    = 1,
  GST_STREAM_STATUS_TYPE_LEAVE    = 2,
  GST_STREAM_STATUS_TYPE_DESTROY  = 3,

  GST_STREAM_STATUS_TYPE_START    = 8,
  GST_STREAM_STATUS_TYPE_PAUSE    = 9,
  GST_STREAM_STATUS_TYPE_STOP     = 10
} GstStreamStatusType;
</ENUM>
<ENUM>
<NAME>GstProgressType</NAME>
typedef enum {
  GST_PROGRESS_TYPE_START    = 0,
  GST_PROGRESS_TYPE_CONTINUE = 1,
  GST_PROGRESS_TYPE_COMPLETE = 2,
  GST_PROGRESS_TYPE_CANCELED = 3,
  GST_PROGRESS_TYPE_ERROR    = 4
} GstProgressType;
</ENUM>
<STRUCT>
<NAME>GstMessage</NAME>
struct _GstMessage
{
  GstMiniObject   mini_object;

  /*< public > *//* with COW */
  GstMessageType  type;
  guint64         timestamp;
  GstObject      *src;
  guint32         seqnum;

  /*< private >*//* with MESSAGE_LOCK */
  GMutex          lock;                 /* lock and cond for async delivery */
  GCond           cond;
};
</STRUCT>
<FUNCTION>
<NAME>gst_message_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_message_type_get_name</NAME>
<RETURNS>const gchar *    </RETURNS>
GstMessageType type
</FUNCTION>
<FUNCTION>
<NAME>gst_message_type_to_quark</NAME>
<RETURNS>GQuark           </RETURNS>
GstMessageType type
</FUNCTION>
<FUNCTION>
<NAME>gst_message_ref</NAME>
<RETURNS>GstMessage  * </RETURNS>
GstMessage * msg
</FUNCTION>
<FUNCTION>
<NAME>gst_message_unref</NAME>
<RETURNS>void  </RETURNS>
GstMessage * msg
</FUNCTION>
<FUNCTION>
<NAME>gst_message_copy</NAME>
<RETURNS>GstMessage  * </RETURNS>
const GstMessage * msg
</FUNCTION>
<MACRO>
<NAME>gst_message_is_writable</NAME>
#define         gst_message_is_writable(msg)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (msg))
</MACRO>
<MACRO>
<NAME>gst_message_make_writable</NAME>
#define         gst_message_make_writable(msg)  GST_MESSAGE_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (msg)))
</MACRO>
<FUNCTION>
<NAME>gst_message_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstMessage **old_message, GstMessage *new_message
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_custom</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstMessageType type, GstObject    * src, GstStructure * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_message_get_structure</NAME>
<RETURNS>const GstStructure  *</RETURNS>
GstMessage *message
</FUNCTION>
<FUNCTION>
<NAME>gst_message_has_name</NAME>
<RETURNS>gboolean         </RETURNS>
GstMessage *message, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_message_get_seqnum</NAME>
<RETURNS>guint32          </RETURNS>
GstMessage *message
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_seqnum</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, guint32 seqnum
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_eos</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_error</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GError * error, const gchar * debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_error</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GError **gerror, gchar **debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_warning</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GError * error, const gchar * debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_warning</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GError **gerror, gchar **debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_info</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GError * error, const gchar * debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_info</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GError **gerror, gchar **debug
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_tag</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstTagList * tag_list
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_tag</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstTagList **tag_list
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_buffering</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, gint percent
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_buffering</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, gint *percent
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_buffering_stats</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstBufferingMode mode, gint avg_in, gint avg_out, gint64 buffering_left
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_buffering_stats</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstBufferingMode *mode, gint *avg_in, gint *avg_out, gint64 *buffering_left
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_state_changed</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstState oldstate, GstState newstate, GstState pending
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_state_changed</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstState *oldstate, GstState *newstate, GstState *pending
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_state_dirty</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_step_done</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstFormat format, guint64 amount, gdouble rate, gboolean flush, gboolean intermediate, guint64 duration, gboolean eos
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_step_done</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstFormat *format, guint64 *amount, gdouble *rate, gboolean *flush, gboolean *intermediate, guint64 *duration, gboolean *eos
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_clock_provide</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstClock *clock, gboolean ready
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_clock_provide</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstClock **clock, gboolean *ready
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_clock_lost</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_clock_lost</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstClock **clock
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_new_clock</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_new_clock</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstClock **clock
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_application</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstStructure * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_element</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstStructure * structure
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_segment_start</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstFormat format, gint64 position
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_segment_start</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstFormat *format, gint64 *position
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_segment_done</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstFormat format, gint64 position
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_segment_done</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstFormat *format, gint64 *position
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_duration_changed</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_latency</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_async_start</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_async_done</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstClockTime running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_async_done</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstClockTime *running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_structure_change</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstStructureChangeType type, GstElement *owner, gboolean busy
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_structure_change</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstStructureChangeType *type, GstElement **owner, gboolean *busy
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_stream_status</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstStreamStatusType type, GstElement *owner
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_stream_status</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstStreamStatusType *type, GstElement **owner
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_stream_status_object</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, const GValue *object
</FUNCTION>
<FUNCTION>
<NAME>gst_message_get_stream_status_object</NAME>
<RETURNS>const GValue  *  </RETURNS>
GstMessage *message
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_request_state</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstState state
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_request_state</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstState *state
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_step_start</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, gboolean active, GstFormat format, guint64 amount, gdouble rate, gboolean flush, gboolean intermediate
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_step_start</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, gboolean *active, GstFormat *format, guint64 *amount, gdouble *rate, gboolean *flush, gboolean *intermediate
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_qos</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, gboolean live, guint64 running_time, guint64 stream_time, guint64 timestamp, guint64 duration
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_qos_values</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, gint64 jitter, gdouble proportion, gint quality
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_qos_stats</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstFormat format, guint64 processed, guint64 dropped
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_qos</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, gboolean * live, guint64 * running_time, guint64 * stream_time, guint64 * timestamp, guint64 * duration
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_qos_values</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, gint64 * jitter, gdouble * proportion, gint * quality
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_qos_stats</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstFormat * format, guint64 * processed, guint64 * dropped
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_progress</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstProgressType type, const gchar *code, const gchar *text
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_progress</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstProgressType * type, gchar ** code, gchar ** text
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_toc</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject *src, GstToc *toc, gboolean updated
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_toc</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstToc **toc, gboolean *updated
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_reset_time</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstClockTime running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_reset_time</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstClockTime *running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_stream_start</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src
</FUNCTION>
<FUNCTION>
<NAME>gst_message_set_group_id</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, guint group_id
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_group_id</NAME>
<RETURNS>gboolean         </RETURNS>
GstMessage *message, guint *group_id
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_need_context</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, const gchar * context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_context_type</NAME>
<RETURNS>gboolean         </RETURNS>
GstMessage * message, const gchar ** context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_have_context</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_have_context</NAME>
<RETURNS>void             </RETURNS>
GstMessage *message, GstContext **context
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_device_added</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_device_added</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstDevice ** device
</FUNCTION>
<FUNCTION>
<NAME>gst_message_new_device_removed</NAME>
<RETURNS>GstMessage  *    </RETURNS>
GstObject * src, GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_message_parse_device_removed</NAME>
<RETURNS>void             </RETURNS>
GstMessage * message, GstDevice ** device
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ITERATOR</NAME>
#define GST_TYPE_ITERATOR (gst_iterator_get_type ())
</MACRO>
<ENUM>
<NAME>GstIteratorResult</NAME>
typedef enum {
  GST_ITERATOR_DONE     = 0,
  GST_ITERATOR_OK       = 1,
  GST_ITERATOR_RESYNC   = 2,
  GST_ITERATOR_ERROR    = 3
} GstIteratorResult;
</ENUM>
<ENUM>
<NAME>GstIteratorItem</NAME>
typedef enum {
  GST_ITERATOR_ITEM_SKIP        = 0,
  GST_ITERATOR_ITEM_PASS        = 1,
  GST_ITERATOR_ITEM_END         = 2
} GstIteratorItem;
</ENUM>
<USER_FUNCTION>
<NAME>GstIteratorCopyFunction</NAME>
<RETURNS>void </RETURNS>
const GstIterator *it, GstIterator *copy
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorItemFunction</NAME>
<RETURNS>GstIteratorItem </RETURNS>
GstIterator *it, const GValue * item
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorNextFunction</NAME>
<RETURNS>GstIteratorResult </RETURNS>
GstIterator *it, GValue *result
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorResyncFunction</NAME>
<RETURNS>void </RETURNS>
GstIterator *it
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorFreeFunction</NAME>
<RETURNS>void </RETURNS>
GstIterator *it
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorForeachFunction</NAME>
<RETURNS>void </RETURNS>
const GValue * item, gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstIteratorFoldFunction</NAME>
<RETURNS>gboolean </RETURNS>
const GValue * item, GValue * ret, gpointer user_data
</USER_FUNCTION>
<MACRO>
<NAME>GST_ITERATOR</NAME>
#define GST_ITERATOR(it)                ((GstIterator*)(it))
</MACRO>
<MACRO>
<NAME>GST_ITERATOR_LOCK</NAME>
#define GST_ITERATOR_LOCK(it)           (GST_ITERATOR(it)->lock)
</MACRO>
<MACRO>
<NAME>GST_ITERATOR_COOKIE</NAME>
#define GST_ITERATOR_COOKIE(it)         (GST_ITERATOR(it)->cookie)
</MACRO>
<MACRO>
<NAME>GST_ITERATOR_ORIG_COOKIE</NAME>
#define GST_ITERATOR_ORIG_COOKIE(it)    (GST_ITERATOR(it)->master_cookie)
</MACRO>
<STRUCT>
<NAME>GstIterator</NAME>
struct _GstIterator {
  /*< protected >*/
  GstIteratorCopyFunction copy;
  GstIteratorNextFunction next;
  GstIteratorItemFunction item;
  GstIteratorResyncFunction resync;
  GstIteratorFreeFunction free;

  GstIterator *pushed;          /* pushed iterator */

  GType     type;
  GMutex   *lock;
  guint32   cookie;             /* cookie of the iterator */
  guint32  *master_cookie;      /* pointer to guint32 holding the cookie when this
                                   iterator was created */
  guint     size;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_iterator_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_new</NAME>
<RETURNS>GstIterator *            </RETURNS>
guint size, GType type, GMutex *lock, guint32 *master_cookie, GstIteratorCopyFunction copy, GstIteratorNextFunction next, GstIteratorItemFunction item, GstIteratorResyncFunction resync, GstIteratorFreeFunction free
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_new_list</NAME>
<RETURNS>GstIterator *            </RETURNS>
GType type, GMutex *lock, guint32 *master_cookie, GList **list, GObject * owner, GstIteratorItemFunction item
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_new_single</NAME>
<RETURNS>GstIterator *            </RETURNS>
GType type, const GValue * object
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_copy</NAME>
<RETURNS>GstIterator *            </RETURNS>
const GstIterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_next</NAME>
<RETURNS>GstIteratorResult        </RETURNS>
GstIterator *it, GValue * elem
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_resync</NAME>
<RETURNS>void                     </RETURNS>
GstIterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_free</NAME>
<RETURNS>void                     </RETURNS>
GstIterator *it
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_push</NAME>
<RETURNS>void                     </RETURNS>
GstIterator *it, GstIterator *other
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_filter</NAME>
<RETURNS>GstIterator *            </RETURNS>
GstIterator *it, GCompareFunc func, const GValue * user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_fold</NAME>
<RETURNS>GstIteratorResult        </RETURNS>
GstIterator *it, GstIteratorFoldFunction func, GValue *ret, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_foreach</NAME>
<RETURNS>GstIteratorResult        </RETURNS>
GstIterator *it, GstIteratorForeachFunction func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_iterator_find_custom</NAME>
<RETURNS>gboolean                 </RETURNS>
GstIterator *it, GCompareFunc func, GValue *elem, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_object_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_OBJECT_FLAGS</NAME>
#define GST_TYPE_OBJECT_FLAGS (gst_object_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_allocator_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ALLOCATOR_FLAGS</NAME>
#define GST_TYPE_ALLOCATOR_FLAGS (gst_allocator_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_bin_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BIN_FLAGS</NAME>
#define GST_TYPE_BIN_FLAGS (gst_bin_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_buffer_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFER_FLAGS</NAME>
#define GST_TYPE_BUFFER_FLAGS (gst_buffer_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_buffer_copy_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFER_COPY_FLAGS</NAME>
#define GST_TYPE_BUFFER_COPY_FLAGS (gst_buffer_copy_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_buffer_pool_acquire_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFER_POOL_ACQUIRE_FLAGS</NAME>
#define GST_TYPE_BUFFER_POOL_ACQUIRE_FLAGS (gst_buffer_pool_acquire_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_bus_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUS_FLAGS</NAME>
#define GST_TYPE_BUS_FLAGS (gst_bus_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_bus_sync_reply_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUS_SYNC_REPLY</NAME>
#define GST_TYPE_BUS_SYNC_REPLY (gst_bus_sync_reply_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_caps_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CAPS_FLAGS</NAME>
#define GST_TYPE_CAPS_FLAGS (gst_caps_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_caps_intersect_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CAPS_INTERSECT_MODE</NAME>
#define GST_TYPE_CAPS_INTERSECT_MODE (gst_caps_intersect_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_clock_return_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CLOCK_RETURN</NAME>
#define GST_TYPE_CLOCK_RETURN (gst_clock_return_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_clock_entry_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CLOCK_ENTRY_TYPE</NAME>
#define GST_TYPE_CLOCK_ENTRY_TYPE (gst_clock_entry_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_clock_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CLOCK_FLAGS</NAME>
#define GST_TYPE_CLOCK_FLAGS (gst_clock_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_debug_graph_details_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEBUG_GRAPH_DETAILS</NAME>
#define GST_TYPE_DEBUG_GRAPH_DETAILS (gst_debug_graph_details_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_state_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STATE</NAME>
#define GST_TYPE_STATE (gst_state_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_state_change_return_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STATE_CHANGE_RETURN</NAME>
#define GST_TYPE_STATE_CHANGE_RETURN (gst_state_change_return_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_state_change_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STATE_CHANGE</NAME>
#define GST_TYPE_STATE_CHANGE (gst_state_change_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_element_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ELEMENT_FLAGS</NAME>
#define GST_TYPE_ELEMENT_FLAGS (gst_element_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_core_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CORE_ERROR</NAME>
#define GST_TYPE_CORE_ERROR (gst_core_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_library_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LIBRARY_ERROR</NAME>
#define GST_TYPE_LIBRARY_ERROR (gst_library_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_resource_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RESOURCE_ERROR</NAME>
#define GST_TYPE_RESOURCE_ERROR (gst_resource_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_stream_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STREAM_ERROR</NAME>
#define GST_TYPE_STREAM_ERROR (gst_stream_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_event_type_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EVENT_TYPE_FLAGS</NAME>
#define GST_TYPE_EVENT_TYPE_FLAGS (gst_event_type_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_event_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_EVENT_TYPE</NAME>
#define GST_TYPE_EVENT_TYPE (gst_event_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_qos_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QOS_TYPE</NAME>
#define GST_TYPE_QOS_TYPE (gst_qos_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_stream_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STREAM_FLAGS</NAME>
#define GST_TYPE_STREAM_FLAGS (gst_stream_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_format_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FORMAT</NAME>
#define GST_TYPE_FORMAT (gst_format_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_debug_level_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEBUG_LEVEL</NAME>
#define GST_TYPE_DEBUG_LEVEL (gst_debug_level_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_debug_color_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEBUG_COLOR_FLAGS</NAME>
#define GST_TYPE_DEBUG_COLOR_FLAGS (gst_debug_color_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_debug_color_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEBUG_COLOR_MODE</NAME>
#define GST_TYPE_DEBUG_COLOR_MODE (gst_debug_color_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_iterator_result_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ITERATOR_RESULT</NAME>
#define GST_TYPE_ITERATOR_RESULT (gst_iterator_result_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_iterator_item_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ITERATOR_ITEM</NAME>
#define GST_TYPE_ITERATOR_ITEM (gst_iterator_item_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_message_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MESSAGE_TYPE</NAME>
#define GST_TYPE_MESSAGE_TYPE (gst_message_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_structure_change_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STRUCTURE_CHANGE_TYPE</NAME>
#define GST_TYPE_STRUCTURE_CHANGE_TYPE (gst_structure_change_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_stream_status_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_STREAM_STATUS_TYPE</NAME>
#define GST_TYPE_STREAM_STATUS_TYPE (gst_stream_status_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_progress_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PROGRESS_TYPE</NAME>
#define GST_TYPE_PROGRESS_TYPE (gst_progress_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_meta_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_META_FLAGS</NAME>
#define GST_TYPE_META_FLAGS (gst_meta_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_memory_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MEMORY_FLAGS</NAME>
#define GST_TYPE_MEMORY_FLAGS (gst_memory_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_map_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MAP_FLAGS</NAME>
#define GST_TYPE_MAP_FLAGS (gst_map_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_mini_object_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_MINI_OBJECT_FLAGS</NAME>
#define GST_TYPE_MINI_OBJECT_FLAGS (gst_mini_object_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_lock_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_LOCK_FLAGS</NAME>
#define GST_TYPE_LOCK_FLAGS (gst_lock_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_direction_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_DIRECTION</NAME>
#define GST_TYPE_PAD_DIRECTION (gst_pad_direction_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_MODE</NAME>
#define GST_TYPE_PAD_MODE (gst_pad_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_link_return_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_LINK_RETURN</NAME>
#define GST_TYPE_PAD_LINK_RETURN (gst_pad_link_return_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_flow_return_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_FLOW_RETURN</NAME>
#define GST_TYPE_FLOW_RETURN (gst_flow_return_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_link_check_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_LINK_CHECK</NAME>
#define GST_TYPE_PAD_LINK_CHECK (gst_pad_link_check_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_probe_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_PROBE_TYPE</NAME>
#define GST_TYPE_PAD_PROBE_TYPE (gst_pad_probe_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_probe_return_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_PROBE_RETURN</NAME>
#define GST_TYPE_PAD_PROBE_RETURN (gst_pad_probe_return_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_FLAGS</NAME>
#define GST_TYPE_PAD_FLAGS (gst_pad_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_presence_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_PRESENCE</NAME>
#define GST_TYPE_PAD_PRESENCE (gst_pad_presence_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pad_template_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD_TEMPLATE_FLAGS</NAME>
#define GST_TYPE_PAD_TEMPLATE_FLAGS (gst_pad_template_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_pipeline_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PIPELINE_FLAGS</NAME>
#define GST_TYPE_PIPELINE_FLAGS (gst_pipeline_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_plugin_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLUGIN_ERROR</NAME>
#define GST_TYPE_PLUGIN_ERROR (gst_plugin_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_plugin_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLUGIN_FLAGS</NAME>
#define GST_TYPE_PLUGIN_FLAGS (gst_plugin_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_plugin_dependency_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PLUGIN_DEPENDENCY_FLAGS</NAME>
#define GST_TYPE_PLUGIN_DEPENDENCY_FLAGS (gst_plugin_dependency_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_rank_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_RANK</NAME>
#define GST_TYPE_RANK (gst_rank_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_query_type_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QUERY_TYPE_FLAGS</NAME>
#define GST_TYPE_QUERY_TYPE_FLAGS (gst_query_type_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_query_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_QUERY_TYPE</NAME>
#define GST_TYPE_QUERY_TYPE (gst_query_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_buffering_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFERING_MODE</NAME>
#define GST_TYPE_BUFFERING_MODE (gst_buffering_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_scheduling_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SCHEDULING_FLAGS</NAME>
#define GST_TYPE_SCHEDULING_FLAGS (gst_scheduling_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_seek_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEEK_TYPE</NAME>
#define GST_TYPE_SEEK_TYPE (gst_seek_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_seek_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEEK_FLAGS</NAME>
#define GST_TYPE_SEEK_FLAGS (gst_seek_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_segment_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEGMENT_FLAGS</NAME>
#define GST_TYPE_SEGMENT_FLAGS (gst_segment_flags_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_clock_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CLOCK_TYPE</NAME>
#define GST_TYPE_CLOCK_TYPE (gst_clock_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_tag_merge_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TAG_MERGE_MODE</NAME>
#define GST_TYPE_TAG_MERGE_MODE (gst_tag_merge_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_tag_flag_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TAG_FLAG</NAME>
#define GST_TYPE_TAG_FLAG (gst_tag_flag_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_tag_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TAG_SCOPE</NAME>
#define GST_TYPE_TAG_SCOPE (gst_tag_scope_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_task_state_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TASK_STATE</NAME>
#define GST_TYPE_TASK_STATE (gst_task_state_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_toc_scope_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TOC_SCOPE</NAME>
#define GST_TYPE_TOC_SCOPE (gst_toc_scope_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_toc_entry_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TOC_ENTRY_TYPE</NAME>
#define GST_TYPE_TOC_ENTRY_TYPE (gst_toc_entry_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_toc_loop_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TOC_LOOP_TYPE</NAME>
#define GST_TYPE_TOC_LOOP_TYPE (gst_toc_loop_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_type_find_probability_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_TYPE_FIND_PROBABILITY</NAME>
#define GST_TYPE_TYPE_FIND_PROBABILITY (gst_type_find_probability_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_uri_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_URI_ERROR</NAME>
#define GST_TYPE_URI_ERROR (gst_uri_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_uri_type_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_URI_TYPE</NAME>
#define GST_TYPE_URI_TYPE (gst_uri_type_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_search_mode_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_SEARCH_MODE</NAME>
#define GST_TYPE_SEARCH_MODE (gst_search_mode_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_parse_error_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PARSE_ERROR</NAME>
#define GST_TYPE_PARSE_ERROR (gst_parse_error_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_parse_flags_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PARSE_FLAGS</NAME>
#define GST_TYPE_PARSE_FLAGS (gst_parse_flags_get_type())
</MACRO>
<ENUM>
<NAME>GstFormat</NAME>
typedef enum {
  GST_FORMAT_UNDEFINED  =  0, /* must be first in list */
  GST_FORMAT_DEFAULT    =  1,
  GST_FORMAT_BYTES      =  2,
  GST_FORMAT_TIME       =  3,
  GST_FORMAT_BUFFERS    =  4,
  GST_FORMAT_PERCENT    =  5
} GstFormat;
</ENUM>
<MACRO>
<NAME>GST_FORMAT_PERCENT_MAX</NAME>
#define GST_FORMAT_PERCENT_MAX          G_GINT64_CONSTANT (1000000)
</MACRO>
<MACRO>
<NAME>GST_FORMAT_PERCENT_SCALE</NAME>
#define GST_FORMAT_PERCENT_SCALE        G_GINT64_CONSTANT (10000)
</MACRO>
<STRUCT>
<NAME>GstFormatDefinition</NAME>
struct _GstFormatDefinition
{
  GstFormat    value;
  const gchar *nick;
  const gchar *description;
  GQuark       quark;
};
</STRUCT>
<FUNCTION>
<NAME>gst_format_get_name</NAME>
<RETURNS>const gchar *    </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_format_to_quark</NAME>
<RETURNS>GQuark           </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_format_register</NAME>
<RETURNS>GstFormat        </RETURNS>
const gchar *nick, const gchar *description
</FUNCTION>
<FUNCTION>
<NAME>gst_format_get_by_nick</NAME>
<RETURNS>GstFormat        </RETURNS>
const gchar *nick
</FUNCTION>
<FUNCTION>
<NAME>gst_formats_contains</NAME>
<RETURNS>gboolean         </RETURNS>
const GstFormat *formats, GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_format_get_details</NAME>
<RETURNS>const GstFormatDefinition *</RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_format_iterate_definitions</NAME>
<RETURNS>GstIterator *    </RETURNS>
void
</FUNCTION>
<ENUM>
<NAME>GstQuarkId</NAME>
typedef enum _GstQuarkId
{
  GST_QUARK_FORMAT = 0,
  GST_QUARK_CURRENT = 1,
  GST_QUARK_DURATION = 2,
  GST_QUARK_RATE = 3,
  GST_QUARK_SEEKABLE = 4,
  GST_QUARK_SEGMENT_START = 5,
  GST_QUARK_SEGMENT_END = 6,
  GST_QUARK_SRC_FORMAT = 7,
  GST_QUARK_SRC_VALUE = 8,
  GST_QUARK_DEST_FORMAT = 9,
  GST_QUARK_DEST_VALUE = 10,
  GST_QUARK_START_FORMAT = 11,
  GST_QUARK_START_VALUE = 12,
  GST_QUARK_STOP_FORMAT = 13,
  GST_QUARK_STOP_VALUE = 14,
  GST_QUARK_GERROR = 15,
  GST_QUARK_DEBUG = 16,
  GST_QUARK_BUFFER_PERCENT = 17,
  GST_QUARK_BUFFERING_MODE = 18,
  GST_QUARK_AVG_IN_RATE = 19,
  GST_QUARK_AVG_OUT_RATE = 20,
  GST_QUARK_BUFFERING_LEFT = 21,
  GST_QUARK_ESTIMATED_TOTAL = 22,
  GST_QUARK_OLD_STATE = 23,
  GST_QUARK_NEW_STATE = 24,
  GST_QUARK_PENDING_STATE = 25,
  GST_QUARK_CLOCK = 26,
  GST_QUARK_READY = 27,
  GST_QUARK_POSITION = 28,
  GST_QUARK_RESET_TIME = 29,
  GST_QUARK_LIVE = 30,
  GST_QUARK_MIN_LATENCY = 31,
  GST_QUARK_MAX_LATENCY = 32,
  GST_QUARK_BUSY = 33,
  GST_QUARK_TYPE = 34,
  GST_QUARK_OWNER = 35,
  GST_QUARK_UPDATE = 36,
  GST_QUARK_APPLIED_RATE = 37,
  GST_QUARK_START = 38,
  GST_QUARK_STOP = 39,
  GST_QUARK_MINSIZE = 40,
  GST_QUARK_MAXSIZE = 41,
  GST_QUARK_ASYNC = 42,
  GST_QUARK_PROPORTION = 43,
  GST_QUARK_DIFF = 44,
  GST_QUARK_TIMESTAMP = 45,
  GST_QUARK_FLAGS = 46,
  GST_QUARK_CUR_TYPE = 47,
  GST_QUARK_CUR = 48,
  GST_QUARK_STOP_TYPE = 49,
  GST_QUARK_LATENCY = 50,
  GST_QUARK_URI = 51,
  GST_QUARK_OBJECT = 52,
  GST_QUARK_TAGLIST = 53,
  GST_QUARK_EVENT_SEGMENT = 54,
  GST_QUARK_EVENT_BUFFER_SIZE = 55,
  GST_QUARK_EVENT_QOS = 56,
  GST_QUARK_EVENT_SEEK = 57,
  GST_QUARK_EVENT_LATENCY = 58,
  GST_QUARK_MESSAGE_ERROR = 59,
  GST_QUARK_MESSAGE_WARNING = 60,
  GST_QUARK_MESSAGE_INFO = 61,
  GST_QUARK_MESSAGE_BUFFERING = 62,
  GST_QUARK_MESSAGE_STATE_CHANGED = 63,
  GST_QUARK_MESSAGE_CLOCK_PROVIDE = 64,
  GST_QUARK_MESSAGE_CLOCK_LOST = 65,
  GST_QUARK_MESSAGE_NEW_CLOCK = 66,
  GST_QUARK_MESSAGE_STRUCTURE_CHANGE = 67,
  GST_QUARK_MESSAGE_SEGMENT_START = 68,
  GST_QUARK_MESSAGE_SEGMENT_DONE = 69,
  GST_QUARK_MESSAGE_DURATION_CHANGED = 70,
  GST_QUARK_MESSAGE_ASYNC_DONE = 71,
  GST_QUARK_MESSAGE_REQUEST_STATE = 72,
  GST_QUARK_MESSAGE_STREAM_STATUS = 73,
  GST_QUARK_QUERY_POSITION = 74,
  GST_QUARK_QUERY_DURATION = 75,
  GST_QUARK_QUERY_LATENCY = 76,
  GST_QUARK_QUERY_CONVERT = 77,
  GST_QUARK_QUERY_SEGMENT = 78,
  GST_QUARK_QUERY_SEEKING = 79,
  GST_QUARK_QUERY_FORMATS = 80,
  GST_QUARK_QUERY_BUFFERING = 81,
  GST_QUARK_QUERY_URI = 82,
  GST_QUARK_EVENT_STEP = 83,
  GST_QUARK_MESSAGE_STEP_DONE = 84,
  GST_QUARK_AMOUNT = 85,
  GST_QUARK_FLUSH = 86,
  GST_QUARK_INTERMEDIATE = 87,
  GST_QUARK_MESSAGE_STEP_START = 88,
  GST_QUARK_ACTIVE = 89,
  GST_QUARK_EOS = 90,
  GST_QUARK_EVENT_SINK_MESSAGE = 91,
  GST_QUARK_MESSAGE = 92,
  GST_QUARK_MESSAGE_QOS = 93,
  GST_QUARK_RUNNING_TIME = 94,
  GST_QUARK_STREAM_TIME = 95,
  GST_QUARK_JITTER = 96,
  GST_QUARK_QUALITY = 97,
  GST_QUARK_PROCESSED = 98,
  GST_QUARK_DROPPED = 99,
  GST_QUARK_BUFFERING_RANGES = 100,
  GST_QUARK_MESSAGE_PROGRESS = 101,
  GST_QUARK_CODE = 102,
  GST_QUARK_TEXT = 103,
  GST_QUARK_PERCENT = 104,
  GST_QUARK_TIMEOUT = 105,
  GST_QUARK_BUFFER_POOL_CONFIG = 106,
  GST_QUARK_CAPS = 107,
  GST_QUARK_SIZE = 108,
  GST_QUARK_MIN_BUFFERS = 109,
  GST_QUARK_MAX_BUFFERS = 110,
  GST_QUARK_PREFIX = 111,
  GST_QUARK_PADDING = 112,
  GST_QUARK_ALIGN = 113,
  GST_QUARK_TIME = 114,
  GST_QUARK_QUERY_ALLOCATION = 115,
  GST_QUARK_NEED_POOL = 116,
  GST_QUARK_META = 117,
  GST_QUARK_POOL = 118,
  GST_QUARK_EVENT_CAPS = 119,
  GST_QUARK_EVENT_RECONFIGURE = 120,
  GST_QUARK_SEGMENT = 121,
  GST_QUARK_QUERY_SCHEDULING = 122,
  GST_QUARK_PULL_MODE = 123,
  GST_QUARK_ALLOCATOR = 124,
  GST_QUARK_EVENT_FLUSH_STOP = 125,
  GST_QUARK_OPTIONS = 126,
  GST_QUARK_QUERY_ACCEPT_CAPS = 127,
  GST_QUARK_RESULT = 128,
  GST_QUARK_QUERY_CAPS = 129,
  GST_QUARK_FILTER = 130,
  GST_QUARK_MODES = 131,
  GST_QUARK_EVENT_STREAM_CONFIG = 132,
  GST_QUARK_SETUP_DATA = 133,
  GST_QUARK_STREAM_HEADERS = 134,
  GST_QUARK_EVENT_GAP = 135,
  GST_QUARK_QUERY_DRAIN = 136,
  GST_QUARK_PARAMS = 137,
  GST_QUARK_EVENT_TOC_SELECT = 138,
  GST_QUARK_UID = 139,
  GST_QUARK_QUERY_TOC = 140,
  GST_QUARK_ELEMENT_METADATA_LONGNAME = 141,
  GST_QUARK_ELEMENT_METADATA_KLASS = 142,
  GST_QUARK_ELEMENT_METADATA_DESCRIPTION = 143,
  GST_QUARK_ELEMENT_METADATA_AUTHOR = 144,
  GST_QUARK_TOC = 145,
  GST_QUARK_TOC_ENTRY = 146,
  GST_QUARK_UPDATED = 147,
  GST_QUARK_EXTEND_UID = 148,
  GST_QUARK_TOC_UID = 149,
  GST_QUARK_TAGS = 150,
  GST_QUARK_SUB_ENTRIES = 151,
  GST_QUARK_INFO = 152,
  GST_QUARK_MESSAGE_TAG = 153,
  GST_QUARK_EVENT_TAG = 154,
  GST_QUARK_MESSAGE_RESET_TIME = 155,
  GST_QUARK_MESSAGE_TOC = 156,
  GST_QUARK_EVENT_TOC_GLOBAL = 157,
  GST_QUARK_EVENT_TOC_CURRENT = 158,
  GST_QUARK_EVENT_SEGMENT_DONE = 159,
  GST_QUARK_EVENT_STREAM_START = 160,
  GST_QUARK_STREAM_ID = 161,
  GST_QUARK_QUERY_CONTEXT = 162,
  GST_QUARK_MESSAGE_NEED_CONTEXT = 163,
  GST_QUARK_MESSAGE_HAVE_CONTEXT = 164,
  GST_QUARK_CONTEXT = 165,
  GST_QUARK_CONTEXT_TYPE = 166,
  GST_QUARK_MESSAGE_STREAM_START = 167,
  GST_QUARK_GROUP_ID = 168,
  GST_QUARK_URI_REDIRECTION = 169,
  GST_QUARK_MESSAGE_DEVICE_ADDED = 170,
  GST_QUARK_MESSAGE_DEVICE_REMOVED = 171,
  GST_QUARK_DEVICE = 172,
  GST_QUARK_URI_REDIRECTION_PERMANENT = 173,
  GST_QUARK_MAX = 174
} GstQuarkId;
</ENUM>
<MACRO>
<NAME>GST_QUARK</NAME>
#define GST_QUARK(q) _priv_gst_quark_table[GST_QUARK_##q]
</MACRO>
<ENUM>
<NAME>GstDebugGraphDetails</NAME>
typedef enum {
  GST_DEBUG_GRAPH_SHOW_MEDIA_TYPE         = (1<<0),
  GST_DEBUG_GRAPH_SHOW_CAPS_DETAILS       = (1<<1),
  GST_DEBUG_GRAPH_SHOW_NON_DEFAULT_PARAMS = (1<<2),
  GST_DEBUG_GRAPH_SHOW_STATES             = (1<<3),
  GST_DEBUG_GRAPH_SHOW_FULL_PARAMS        = (1<<4),
  GST_DEBUG_GRAPH_SHOW_ALL                = ((1<<4)-1),
  GST_DEBUG_GRAPH_SHOW_VERBOSE            = (-1)
} GstDebugGraphDetails;
</ENUM>
<FUNCTION>
<NAME>gst_debug_bin_to_dot_data</NAME>
<RETURNS>gchar  * </RETURNS>
GstBin *bin, GstDebugGraphDetails details
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_bin_to_dot_file</NAME>
<RETURNS>void  </RETURNS>
GstBin *bin, GstDebugGraphDetails details, const gchar *file_name
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_bin_to_dot_file_with_ts</NAME>
<RETURNS>void  </RETURNS>
GstBin *bin, GstDebugGraphDetails details, const gchar *file_name
</FUNCTION>
<MACRO>
<NAME>GST_DEBUG_BIN_TO_DOT_FILE</NAME>
#define GST_DEBUG_BIN_TO_DOT_FILE(bin, details, file_name) gst_debug_bin_to_dot_file (bin, details, file_name)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS</NAME>
#define GST_DEBUG_BIN_TO_DOT_FILE_WITH_TS(bin, details, file_name) gst_debug_bin_to_dot_file_with_ts (bin, details, file_name)
</MACRO>
<MACRO>
<NAME>GST_TYPE_TYPE_FIND_FACTORY</NAME>
#define GST_TYPE_TYPE_FIND_FACTORY                 (gst_type_find_factory_get_type())
</MACRO>
<MACRO>
<NAME>GST_TYPE_FIND_FACTORY</NAME>
#define GST_TYPE_FIND_FACTORY(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactory))
</MACRO>
<MACRO>
<NAME>GST_IS_TYPE_FIND_FACTORY</NAME>
#define GST_IS_TYPE_FIND_FACTORY(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TYPE_FIND_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_TYPE_FIND_FACTORY_CLASS</NAME>
#define GST_TYPE_FIND_FACTORY_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TYPE_FIND_FACTORY_CLASS</NAME>
#define GST_IS_TYPE_FIND_FACTORY_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_TYPE_FIND_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_TYPE_FIND_FACTORY_GET_CLASS</NAME>
#define GST_TYPE_FIND_FACTORY_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_TYPE_FIND_FACTORY, GstTypeFindFactoryClass))
</MACRO>
<FUNCTION>
<NAME>gst_type_find_factory_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_factory_get_list</NAME>
<RETURNS>GList  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_factory_get_extensions</NAME>
<RETURNS>const gchar  * const *</RETURNS>
GstTypeFindFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_factory_get_caps</NAME>
<RETURNS>GstCaps  *       </RETURNS>
GstTypeFindFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_factory_has_function</NAME>
<RETURNS>gboolean         </RETURNS>
GstTypeFindFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_factory_call_function</NAME>
<RETURNS>void             </RETURNS>
GstTypeFindFactory *factory, GstTypeFind *find
</FUNCTION>
<STRUCT>
<NAME>GstTypeFindFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTypeFindFactoryClass</NAME>
</STRUCT>
<ENUM>
<NAME>GstTagMergeMode</NAME>
typedef enum {
  GST_TAG_MERGE_UNDEFINED,
  GST_TAG_MERGE_REPLACE_ALL,
  GST_TAG_MERGE_REPLACE,
  GST_TAG_MERGE_APPEND,
  GST_TAG_MERGE_PREPEND,
  GST_TAG_MERGE_KEEP,
  GST_TAG_MERGE_KEEP_ALL,
  /* add more */
  GST_TAG_MERGE_COUNT
} GstTagMergeMode;
</ENUM>
<MACRO>
<NAME>GST_TAG_MODE_IS_VALID</NAME>
#define GST_TAG_MODE_IS_VALID(mode)     (((mode) > GST_TAG_MERGE_UNDEFINED) && ((mode) < GST_TAG_MERGE_COUNT))
</MACRO>
<ENUM>
<NAME>GstTagFlag</NAME>
typedef enum {
  GST_TAG_FLAG_UNDEFINED,
  GST_TAG_FLAG_META,
  GST_TAG_FLAG_ENCODED,
  GST_TAG_FLAG_DECODED,
  GST_TAG_FLAG_COUNT
} GstTagFlag;
</ENUM>
<MACRO>
<NAME>GST_TAG_FLAG_IS_VALID</NAME>
#define GST_TAG_FLAG_IS_VALID(flag)     (((flag) > GST_TAG_FLAG_UNDEFINED) && ((flag) < GST_TAG_FLAG_COUNT))
</MACRO>
<STRUCT>
<NAME>GstTagList</NAME>
struct _GstTagList {
  GstMiniObject mini_object;
};
</STRUCT>
<MACRO>
<NAME>GST_TAG_LIST</NAME>
#define GST_TAG_LIST(x)       ((GstTagList *) (x))
</MACRO>
<MACRO>
<NAME>GST_TYPE_TAG_LIST</NAME>
#define GST_TYPE_TAG_LIST     (_gst_tag_list_type)
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_LIST</NAME>
#define GST_IS_TAG_LIST(obj)  (GST_IS_MINI_OBJECT_TYPE((obj), GST_TYPE_TAG_LIST))
</MACRO>
<USER_FUNCTION>
<NAME>GstTagForeachFunc</NAME>
<RETURNS>void </RETURNS>
const GstTagList * list,
                                   const gchar      * tag,
                                   gpointer           user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstTagMergeFunc</NAME>
<RETURNS>void </RETURNS>
GValue *dest, const GValue *src
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_register</NAME>
<RETURNS>void          </RETURNS>
const gchar     * name, GstTagFlag        flag, GType             type, const gchar     * nick, const gchar     * blurb, GstTagMergeFunc   func
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_register_static</NAME>
<RETURNS>void          </RETURNS>
const gchar   * name, GstTagFlag      flag, GType           type, const gchar   * nick, const gchar   * blurb, GstTagMergeFunc func
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_merge_use_first</NAME>
<RETURNS>void       </RETURNS>
GValue * dest, const GValue * src
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_merge_strings_with_comma</NAME>
<RETURNS>void       </RETURNS>
GValue * dest, const GValue * src
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_exists</NAME>
<RETURNS>gboolean                </RETURNS>
const gchar * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_get_type</NAME>
<RETURNS>GType                   </RETURNS>
const gchar * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_get_nick</NAME>
<RETURNS>const gchar  *          </RETURNS>
const gchar * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_get_description</NAME>
<RETURNS>const gchar  *          </RETURNS>
const gchar * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_get_flag</NAME>
<RETURNS>GstTagFlag              </RETURNS>
const gchar * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_is_fixed</NAME>
<RETURNS>gboolean                </RETURNS>
const gchar * tag
</FUNCTION>
<ENUM>
<NAME>GstTagScope</NAME>
typedef enum {
  GST_TAG_SCOPE_STREAM,
  GST_TAG_SCOPE_GLOBAL
} GstTagScope;
</ENUM>
<FUNCTION>
<NAME>gst_tag_list_new_empty</NAME>
<RETURNS>GstTagList  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_new</NAME>
<RETURNS>GstTagList  * </RETURNS>
const gchar * tag, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_new_valist</NAME>
<RETURNS>GstTagList  * </RETURNS>
va_list var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_set_scope</NAME>
<RETURNS>void          </RETURNS>
GstTagList * list, GstTagScope scope
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_scope</NAME>
<RETURNS>GstTagScope   </RETURNS>
const GstTagList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_to_string</NAME>
<RETURNS>gchar       * </RETURNS>
const GstTagList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_new_from_string</NAME>
<RETURNS>GstTagList  * </RETURNS>
const gchar      * str
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_n_tags</NAME>
<RETURNS>gint          </RETURNS>
const GstTagList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_nth_tag_name</NAME>
<RETURNS>const gchar * </RETURNS>
const GstTagList * list, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_is_empty</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_is_equal</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list1, const GstTagList * list2
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_insert</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * into, const GstTagList * from, GstTagMergeMode    mode
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_merge</NAME>
<RETURNS>GstTagList  * </RETURNS>
const GstTagList * list1, const GstTagList * list2, GstTagMergeMode    mode
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_tag_size</NAME>
<RETURNS>guint         </RETURNS>
const GstTagList * list, const gchar      * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_add</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, GstTagMergeMode    mode, const gchar      * tag, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_add_values</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, GstTagMergeMode    mode, const gchar      * tag, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_add_valist</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, GstTagMergeMode    mode, const gchar      * tag, va_list        var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_add_valist_values</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, GstTagMergeMode    mode, const gchar      * tag, va_list            var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_add_value</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, GstTagMergeMode    mode, const gchar      * tag, const GValue     * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_remove_tag</NAME>
<RETURNS>void          </RETURNS>
GstTagList       * list, const gchar      * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_foreach</NAME>
<RETURNS>void          </RETURNS>
const GstTagList * list, GstTagForeachFunc  func, gpointer           user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_value_index</NAME>
<RETURNS>const GValue  *</RETURNS>
const GstTagList * list, const gchar      * tag, guint              index
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_copy_value</NAME>
<RETURNS>gboolean      </RETURNS>
GValue           * dest, const GstTagList * list, const gchar      * tag
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_boolean</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gboolean         * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_boolean_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gboolean         * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_int</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gint             * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_int_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gint             * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_uint</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint            * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_uint_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, guint            * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_int64</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gint64           * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_int64_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gint64           * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_uint64</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint64          * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_uint64_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, guint64          * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_float</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gfloat           * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_float_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gfloat           * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_double</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gdouble          * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_double_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gdouble          * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_string</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gchar           ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_string_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gchar           ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_peek_string_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, const gchar     ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_pointer</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, gpointer         * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_pointer_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, gpointer         * value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_date</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, GDate           ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_date_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, GDate           ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_date_time</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, GstDateTime     ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_date_time_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, GstDateTime     ** value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_sample</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, GstSample       ** sample
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_get_sample_index</NAME>
<RETURNS>gboolean      </RETURNS>
const GstTagList * list, const gchar      * tag, guint              index, GstSample       ** sample
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_ref</NAME>
<RETURNS>GstTagList  * </RETURNS>
GstTagList * taglist
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_unref</NAME>
<RETURNS>void  </RETURNS>
GstTagList * taglist
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_list_copy</NAME>
<RETURNS>GstTagList  * </RETURNS>
const GstTagList * taglist
</FUNCTION>
<MACRO>
<NAME>gst_tag_list_is_writable</NAME>
#define gst_tag_list_is_writable(taglist)    gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (taglist))
</MACRO>
<MACRO>
<NAME>gst_tag_list_make_writable</NAME>
#define gst_tag_list_make_writable(taglist)   GST_TAG_LIST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (taglist)))
</MACRO>
<MACRO>
<NAME>GST_TAG_TITLE</NAME>
#define GST_TAG_TITLE                  "title"
</MACRO>
<MACRO>
<NAME>GST_TAG_TITLE_SORTNAME</NAME>
#define GST_TAG_TITLE_SORTNAME         "title-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_ARTIST</NAME>
#define GST_TAG_ARTIST                 "artist"
</MACRO>
<MACRO>
<NAME>GST_TAG_ARTIST_SORTNAME</NAME>
#define GST_TAG_ARTIST_SORTNAME        "artist-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM</NAME>
#define GST_TAG_ALBUM                  "album"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_SORTNAME</NAME>
#define GST_TAG_ALBUM_SORTNAME         "album-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_ARTIST</NAME>
#define GST_TAG_ALBUM_ARTIST           "album-artist"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_ARTIST_SORTNAME</NAME>
#define GST_TAG_ALBUM_ARTIST_SORTNAME  "album-artist-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_COMPOSER</NAME>
#define GST_TAG_COMPOSER               "composer"
</MACRO>
<MACRO>
<NAME>GST_TAG_DATE</NAME>
#define GST_TAG_DATE                   "date"
</MACRO>
<MACRO>
<NAME>GST_TAG_DATE_TIME</NAME>
#define GST_TAG_DATE_TIME              "datetime"
</MACRO>
<MACRO>
<NAME>GST_TAG_GENRE</NAME>
#define GST_TAG_GENRE                  "genre"
</MACRO>
<MACRO>
<NAME>GST_TAG_COMMENT</NAME>
#define GST_TAG_COMMENT                "comment"
</MACRO>
<MACRO>
<NAME>GST_TAG_EXTENDED_COMMENT</NAME>
#define GST_TAG_EXTENDED_COMMENT       "extended-comment"
</MACRO>
<MACRO>
<NAME>GST_TAG_TRACK_NUMBER</NAME>
#define GST_TAG_TRACK_NUMBER           "track-number"
</MACRO>
<MACRO>
<NAME>GST_TAG_TRACK_COUNT</NAME>
#define GST_TAG_TRACK_COUNT            "track-count"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_VOLUME_NUMBER</NAME>
#define GST_TAG_ALBUM_VOLUME_NUMBER    "album-disc-number"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_VOLUME_COUNT</NAME>
#define GST_TAG_ALBUM_VOLUME_COUNT    "album-disc-count"
</MACRO>
<MACRO>
<NAME>GST_TAG_LOCATION</NAME>
#define GST_TAG_LOCATION               "location"
</MACRO>
<MACRO>
<NAME>GST_TAG_HOMEPAGE</NAME>
#define GST_TAG_HOMEPAGE               "homepage"
</MACRO>
<MACRO>
<NAME>GST_TAG_DESCRIPTION</NAME>
#define GST_TAG_DESCRIPTION            "description"
</MACRO>
<MACRO>
<NAME>GST_TAG_VERSION</NAME>
#define GST_TAG_VERSION                "version"
</MACRO>
<MACRO>
<NAME>GST_TAG_ISRC</NAME>
#define GST_TAG_ISRC                   "isrc"
</MACRO>
<MACRO>
<NAME>GST_TAG_ORGANIZATION</NAME>
#define GST_TAG_ORGANIZATION           "organization"
</MACRO>
<MACRO>
<NAME>GST_TAG_COPYRIGHT</NAME>
#define GST_TAG_COPYRIGHT              "copyright"
</MACRO>
<MACRO>
<NAME>GST_TAG_COPYRIGHT_URI</NAME>
#define GST_TAG_COPYRIGHT_URI          "copyright-uri"
</MACRO>
<MACRO>
<NAME>GST_TAG_ENCODED_BY</NAME>
#define GST_TAG_ENCODED_BY             "encoded-by"
</MACRO>
<MACRO>
<NAME>GST_TAG_CONTACT</NAME>
#define GST_TAG_CONTACT                "contact"
</MACRO>
<MACRO>
<NAME>GST_TAG_LICENSE</NAME>
#define GST_TAG_LICENSE                "license"
</MACRO>
<MACRO>
<NAME>GST_TAG_LICENSE_URI</NAME>
#define GST_TAG_LICENSE_URI            "license-uri"
</MACRO>
<MACRO>
<NAME>GST_TAG_PERFORMER</NAME>
#define GST_TAG_PERFORMER              "performer"
</MACRO>
<MACRO>
<NAME>GST_TAG_DURATION</NAME>
#define GST_TAG_DURATION               "duration"
</MACRO>
<MACRO>
<NAME>GST_TAG_CODEC</NAME>
#define GST_TAG_CODEC                  "codec"
</MACRO>
<MACRO>
<NAME>GST_TAG_VIDEO_CODEC</NAME>
#define GST_TAG_VIDEO_CODEC            "video-codec"
</MACRO>
<MACRO>
<NAME>GST_TAG_AUDIO_CODEC</NAME>
#define GST_TAG_AUDIO_CODEC            "audio-codec"
</MACRO>
<MACRO>
<NAME>GST_TAG_SUBTITLE_CODEC</NAME>
#define GST_TAG_SUBTITLE_CODEC         "subtitle-codec"
</MACRO>
<MACRO>
<NAME>GST_TAG_CONTAINER_FORMAT</NAME>
#define GST_TAG_CONTAINER_FORMAT       "container-format"
</MACRO>
<MACRO>
<NAME>GST_TAG_BITRATE</NAME>
#define GST_TAG_BITRATE                "bitrate"
</MACRO>
<MACRO>
<NAME>GST_TAG_NOMINAL_BITRATE</NAME>
#define GST_TAG_NOMINAL_BITRATE        "nominal-bitrate"
</MACRO>
<MACRO>
<NAME>GST_TAG_MINIMUM_BITRATE</NAME>
#define GST_TAG_MINIMUM_BITRATE        "minimum-bitrate"
</MACRO>
<MACRO>
<NAME>GST_TAG_MAXIMUM_BITRATE</NAME>
#define GST_TAG_MAXIMUM_BITRATE        "maximum-bitrate"
</MACRO>
<MACRO>
<NAME>GST_TAG_SERIAL</NAME>
#define GST_TAG_SERIAL                 "serial"
</MACRO>
<MACRO>
<NAME>GST_TAG_ENCODER</NAME>
#define GST_TAG_ENCODER                "encoder"
</MACRO>
<MACRO>
<NAME>GST_TAG_ENCODER_VERSION</NAME>
#define GST_TAG_ENCODER_VERSION        "encoder-version"
</MACRO>
<MACRO>
<NAME>GST_TAG_TRACK_GAIN</NAME>
#define GST_TAG_TRACK_GAIN             "replaygain-track-gain"
</MACRO>
<MACRO>
<NAME>GST_TAG_TRACK_PEAK</NAME>
#define GST_TAG_TRACK_PEAK             "replaygain-track-peak"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_GAIN</NAME>
#define GST_TAG_ALBUM_GAIN             "replaygain-album-gain"
</MACRO>
<MACRO>
<NAME>GST_TAG_ALBUM_PEAK</NAME>
#define GST_TAG_ALBUM_PEAK             "replaygain-album-peak"
</MACRO>
<MACRO>
<NAME>GST_TAG_REFERENCE_LEVEL</NAME>
#define GST_TAG_REFERENCE_LEVEL        "replaygain-reference-level"
</MACRO>
<MACRO>
<NAME>GST_TAG_LANGUAGE_CODE</NAME>
#define GST_TAG_LANGUAGE_CODE          "language-code"
</MACRO>
<MACRO>
<NAME>GST_TAG_LANGUAGE_NAME</NAME>
#define GST_TAG_LANGUAGE_NAME          "language-name"
</MACRO>
<MACRO>
<NAME>GST_TAG_IMAGE</NAME>
#define GST_TAG_IMAGE                  "image"
</MACRO>
<MACRO>
<NAME>GST_TAG_PREVIEW_IMAGE</NAME>
#define GST_TAG_PREVIEW_IMAGE          "preview-image"
</MACRO>
<MACRO>
<NAME>GST_TAG_ATTACHMENT</NAME>
#define GST_TAG_ATTACHMENT             "attachment"
</MACRO>
<MACRO>
<NAME>GST_TAG_BEATS_PER_MINUTE</NAME>
#define GST_TAG_BEATS_PER_MINUTE       "beats-per-minute"
</MACRO>
<MACRO>
<NAME>GST_TAG_KEYWORDS</NAME>
#define GST_TAG_KEYWORDS               "keywords"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_NAME</NAME>
#define GST_TAG_GEO_LOCATION_NAME               "geo-location-name"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_LATITUDE</NAME>
#define GST_TAG_GEO_LOCATION_LATITUDE               "geo-location-latitude"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_LONGITUDE</NAME>
#define GST_TAG_GEO_LOCATION_LONGITUDE               "geo-location-longitude"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_ELEVATION</NAME>
#define GST_TAG_GEO_LOCATION_ELEVATION               "geo-location-elevation"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_COUNTRY</NAME>
#define GST_TAG_GEO_LOCATION_COUNTRY                 "geo-location-country"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_CITY</NAME>
#define GST_TAG_GEO_LOCATION_CITY                    "geo-location-city"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_SUBLOCATION</NAME>
#define GST_TAG_GEO_LOCATION_SUBLOCATION             "geo-location-sublocation"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR</NAME>
#define GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR   "geo-location-horizontal-error"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_MOVEMENT_SPEED</NAME>
#define GST_TAG_GEO_LOCATION_MOVEMENT_SPEED       "geo-location-movement-speed"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION</NAME>
#define GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION "geo-location-movement-direction"
</MACRO>
<MACRO>
<NAME>GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION</NAME>
#define GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION  "geo-location-capture-direction"
</MACRO>
<MACRO>
<NAME>GST_TAG_SHOW_NAME</NAME>
#define GST_TAG_SHOW_NAME                         "show-name"
</MACRO>
<MACRO>
<NAME>GST_TAG_SHOW_SORTNAME</NAME>
#define GST_TAG_SHOW_SORTNAME                     "show-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_SHOW_EPISODE_NUMBER</NAME>
#define GST_TAG_SHOW_EPISODE_NUMBER               "show-episode-number"
</MACRO>
<MACRO>
<NAME>GST_TAG_SHOW_SEASON_NUMBER</NAME>
#define GST_TAG_SHOW_SEASON_NUMBER                "show-season-number"
</MACRO>
<MACRO>
<NAME>GST_TAG_LYRICS</NAME>
#define GST_TAG_LYRICS                            "lyrics"
</MACRO>
<MACRO>
<NAME>GST_TAG_COMPOSER_SORTNAME</NAME>
#define GST_TAG_COMPOSER_SORTNAME                 "composer-sortname"
</MACRO>
<MACRO>
<NAME>GST_TAG_GROUPING</NAME>
#define GST_TAG_GROUPING                          "grouping"
</MACRO>
<MACRO>
<NAME>GST_TAG_USER_RATING</NAME>
#define GST_TAG_USER_RATING                       "user-rating"
</MACRO>
<MACRO>
<NAME>GST_TAG_DEVICE_MANUFACTURER</NAME>
#define GST_TAG_DEVICE_MANUFACTURER               "device-manufacturer"
</MACRO>
<MACRO>
<NAME>GST_TAG_DEVICE_MODEL</NAME>
#define GST_TAG_DEVICE_MODEL                      "device-model"
</MACRO>
<MACRO>
<NAME>GST_TAG_APPLICATION_NAME</NAME>
#define GST_TAG_APPLICATION_NAME                  "application-name"
</MACRO>
<MACRO>
<NAME>GST_TAG_APPLICATION_DATA</NAME>
#define GST_TAG_APPLICATION_DATA          "application-data"
</MACRO>
<MACRO>
<NAME>GST_TAG_IMAGE_ORIENTATION</NAME>
#define GST_TAG_IMAGE_ORIENTATION            "image-orientation"
</MACRO>
<MACRO>
<NAME>GST_TAG_PUBLISHER</NAME>
#define GST_TAG_PUBLISHER                         "publisher"
</MACRO>
<MACRO>
<NAME>GST_TAG_INTERPRETED_BY</NAME>
#define GST_TAG_INTERPRETED_BY                    "interpreted-by"
</MACRO>
<MACRO>
<NAME>GST_TAG_MIDI_BASE_NOTE</NAME>
#define GST_TAG_MIDI_BASE_NOTE                    "midi-base-note"
</MACRO>
<MACRO>
<NAME>GST_TYPE_STATIC_PAD_TEMPLATE</NAME>
#define GST_TYPE_STATIC_PAD_TEMPLATE	(gst_static_pad_template_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TYPE_PAD_TEMPLATE</NAME>
#define GST_TYPE_PAD_TEMPLATE		(gst_pad_template_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PAD_TEMPLATE</NAME>
#define GST_PAD_TEMPLATE(obj)		(G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PAD_TEMPLATE,GstPadTemplate))
</MACRO>
<MACRO>
<NAME>GST_PAD_TEMPLATE_CLASS</NAME>
#define GST_PAD_TEMPLATE_CLASS(klass)	(G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PAD_TEMPLATE,GstPadTemplateClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PAD_TEMPLATE</NAME>
#define GST_IS_PAD_TEMPLATE(obj)	(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PAD_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GST_IS_PAD_TEMPLATE_CLASS</NAME>
#define GST_IS_PAD_TEMPLATE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PAD_TEMPLATE))
</MACRO>
<ENUM>
<NAME>GstPadPresence</NAME>
typedef enum {
  GST_PAD_ALWAYS,
  GST_PAD_SOMETIMES,
  GST_PAD_REQUEST
} GstPadPresence;
</ENUM>
<MACRO>
<NAME>GST_PAD_TEMPLATE_NAME_TEMPLATE</NAME>
#define GST_PAD_TEMPLATE_NAME_TEMPLATE(templ)	(((GstPadTemplate *)(templ))->name_template)
</MACRO>
<MACRO>
<NAME>GST_PAD_TEMPLATE_DIRECTION</NAME>
#define GST_PAD_TEMPLATE_DIRECTION(templ)	(((GstPadTemplate *)(templ))->direction)
</MACRO>
<MACRO>
<NAME>GST_PAD_TEMPLATE_PRESENCE</NAME>
#define GST_PAD_TEMPLATE_PRESENCE(templ)	(((GstPadTemplate *)(templ))->presence)
</MACRO>
<MACRO>
<NAME>GST_PAD_TEMPLATE_CAPS</NAME>
#define GST_PAD_TEMPLATE_CAPS(templ)		(((GstPadTemplate *)(templ))->caps)
</MACRO>
<ENUM>
<NAME>GstPadTemplateFlags</NAME>
typedef enum {
  /* padding */
  GST_PAD_TEMPLATE_FLAG_LAST    = (GST_OBJECT_FLAG_LAST << 4)
} GstPadTemplateFlags;
</ENUM>
<MACRO>
<NAME>GST_PAD_TEMPLATE_IS_FIXED</NAME>
#define GST_PAD_TEMPLATE_IS_FIXED(templ)	(GST_OBJECT_FLAG_IS_SET(templ, GST_PAD_TEMPLATE_FIXED))
</MACRO>
<STRUCT>
<NAME>GstPadTemplate</NAME>
struct _GstPadTemplate {
  GstObject	   object;

  gchar           *name_template;
  GstPadDirection  direction;
  GstPadPresence   presence;
  GstCaps	  *caps;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstPadTemplateClass</NAME>
struct _GstPadTemplateClass {
  GstObjectClass   parent_class;

  /* signal callbacks */
  void (*pad_created)	(GstPadTemplate *templ, GstPad *pad);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstStaticPadTemplate</NAME>
struct _GstStaticPadTemplate {
  const gchar     *name_template;
  GstPadDirection  direction;
  GstPadPresence   presence;
  GstStaticCaps    static_caps;
};
</STRUCT>
<MACRO>
<NAME>GST_STATIC_PAD_TEMPLATE</NAME>
#define GST_STATIC_PAD_TEMPLATE(padname, dir, pres, caps) \
{ \
  /* name_template */    padname, \
  /* direction */        dir, \
  /* presence */         pres, \
  /* caps */             caps \
}
</MACRO>
<FUNCTION>
<NAME>gst_pad_template_get_type</NAME>
<RETURNS>GType 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_static_pad_template_get_type</NAME>
<RETURNS>GType 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_template_new</NAME>
<RETURNS>GstPadTemplate *		</RETURNS>
const gchar *name_template, GstPadDirection direction, GstPadPresence presence, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_static_pad_template_get</NAME>
<RETURNS>GstPadTemplate  *	</RETURNS>
GstStaticPadTemplate *pad_template
</FUNCTION>
<FUNCTION>
<NAME>gst_static_pad_template_get_caps</NAME>
<RETURNS>GstCaps *		</RETURNS>
GstStaticPadTemplate *templ
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_template_get_caps</NAME>
<RETURNS>GstCaps *		</RETURNS>
GstPadTemplate *templ
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_template_pad_created</NAME>
<RETURNS>void                     </RETURNS>
GstPadTemplate * templ, GstPad * pad
</FUNCTION>
<MACRO>
<NAME>GST_MAGIC_BINARY_REGISTRY_STR</NAME>
#define GST_MAGIC_BINARY_REGISTRY_STR "\xc0\xde\xf0\x0d"
</MACRO>
<MACRO>
<NAME>GST_MAGIC_BINARY_REGISTRY_LEN</NAME>
#define GST_MAGIC_BINARY_REGISTRY_LEN (4)
</MACRO>
<MACRO>
<NAME>GST_MAGIC_BINARY_VERSION_STR</NAME>
#define GST_MAGIC_BINARY_VERSION_STR "1.0.0"
</MACRO>
<MACRO>
<NAME>GST_MAGIC_BINARY_VERSION_LEN</NAME>
#define GST_MAGIC_BINARY_VERSION_LEN (64)
</MACRO>
<MACRO>
<NAME>GST_TYPE_DEVICE_PROVIDER</NAME>
#define GST_TYPE_DEVICE_PROVIDER                 (gst_device_provider_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_PROVIDER</NAME>
#define GST_IS_DEVICE_PROVIDER(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_PROVIDER_CLASS</NAME>
#define GST_IS_DEVICE_PROVIDER_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DEVICE_PROVIDER))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_GET_CLASS</NAME>
#define GST_DEVICE_PROVIDER_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER</NAME>
#define GST_DEVICE_PROVIDER(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DEVICE_PROVIDER, GstDeviceProvider))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_CLASS</NAME>
#define GST_DEVICE_PROVIDER_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_PROVIDER, GstDeviceProviderClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_CAST</NAME>
#define GST_DEVICE_PROVIDER_CAST(obj)            ((GstDeviceProvider *)(obj))
</MACRO>
<STRUCT>
<NAME>GstDeviceProvider</NAME>
struct _GstDeviceProvider {
  GstObject         parent;

  /* Protected by the Object lock */
  GList *devices;

  /*< private >*/

  GstDeviceProviderPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstDeviceProviderClass</NAME>
struct _GstDeviceProviderClass {
  GstObjectClass    parent_class;

  GstDeviceProviderFactory     *factory;

  GList*      (*probe) (GstDeviceProvider * provider);

  gboolean    (*start) (GstDeviceProvider * provider);
  void        (*stop)  (GstDeviceProvider * provider);

  /*< private >*/
  gpointer metadata;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_device_provider_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_get_devices</NAME>
<RETURNS>GList  *     </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_start</NAME>
<RETURNS>gboolean     </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_stop</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_can_monitor</NAME>
<RETURNS>gboolean     </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_get_bus</NAME>
<RETURNS>GstBus  *    </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_device_add</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProvider * provider, GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_device_remove</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProvider * provider, GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_get_hidden_providers</NAME>
<RETURNS>gchar  **    </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_hide_provider</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProvider * provider, const gchar       * name
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_unhide_provider</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProvider * provider, const gchar       * name
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_class_set_metadata</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProviderClass *klass, const gchar     *longname, const gchar     *classification, const gchar     *description, const gchar     *author
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_class_set_static_metadata</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProviderClass *klass, const gchar     *longname, const gchar     *classification, const gchar     *description, const gchar     *author
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_class_add_metadata</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProviderClass * klass, const gchar * key, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_class_add_static_metadata</NAME>
<RETURNS>void         </RETURNS>
GstDeviceProviderClass * klass, const gchar * key, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_class_get_metadata</NAME>
<RETURNS>const gchar  * </RETURNS>
GstDeviceProviderClass * klass, const gchar * key
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_get_factory</NAME>
<RETURNS>GstDeviceProviderFactory  * </RETURNS>
GstDeviceProvider * provider
</FUNCTION>
<STRUCT>
<NAME>GstDeviceProviderPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SAMPLE</NAME>
#define GST_TYPE_SAMPLE      (_gst_sample_type)
</MACRO>
<MACRO>
<NAME>GST_IS_SAMPLE</NAME>
#define GST_IS_SAMPLE(obj)   (GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_SAMPLE))
</MACRO>
<MACRO>
<NAME>GST_SAMPLE_CAST</NAME>
#define GST_SAMPLE_CAST(obj) ((GstSample *)obj)
</MACRO>
<MACRO>
<NAME>GST_SAMPLE</NAME>
#define GST_SAMPLE(obj)      (GST_SAMPLE_CAST(obj))
</MACRO>
<FUNCTION>
<NAME>gst_sample_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_new</NAME>
<RETURNS>GstSample  *          </RETURNS>
GstBuffer          *buffer, GstCaps            *caps, const GstSegment   *segment, GstStructure       *info
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_get_buffer</NAME>
<RETURNS>GstBuffer  *          </RETURNS>
GstSample *sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_get_caps</NAME>
<RETURNS>GstCaps  *            </RETURNS>
GstSample *sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_get_segment</NAME>
<RETURNS>GstSegment  *         </RETURNS>
GstSample *sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_get_info</NAME>
<RETURNS>const GstStructure  * </RETURNS>
GstSample *sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_get_buffer_list</NAME>
<RETURNS>GstBufferList  *      </RETURNS>
GstSample *sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_set_buffer_list</NAME>
<RETURNS>void                  </RETURNS>
GstSample *sample, GstBufferList *buffer_list
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_ref</NAME>
<RETURNS>GstSample  * </RETURNS>
GstSample * sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_unref</NAME>
<RETURNS>void  </RETURNS>
GstSample * sample
</FUNCTION>
<FUNCTION>
<NAME>gst_sample_copy</NAME>
<RETURNS>GstSample  * </RETURNS>
const GstSample * buf
</FUNCTION>
<MACRO>
<NAME>gst_value_set_sample</NAME>
#define         gst_value_set_sample(v,b)       g_value_set_boxed((v),(b))
</MACRO>
<MACRO>
<NAME>gst_value_take_sample</NAME>
#define         gst_value_take_sample(v,b)      g_value_take_boxed(v,(b))
</MACRO>
<MACRO>
<NAME>gst_value_get_sample</NAME>
#define         gst_value_get_sample(v)         GST_SAMPLE_CAST (g_value_get_boxed(v))
</MACRO>
<STRUCT>
<NAME>GstSample</NAME>
</STRUCT>
<ENUM>
<NAME>GstDebugLevel</NAME>
typedef enum {
  GST_LEVEL_NONE = 0,
  GST_LEVEL_ERROR = 1,
  GST_LEVEL_WARNING = 2,
  GST_LEVEL_FIXME = 3,
  GST_LEVEL_INFO = 4,
  GST_LEVEL_DEBUG = 5,
  GST_LEVEL_LOG = 6,
  GST_LEVEL_TRACE = 7,
  /* add more */
  GST_LEVEL_MEMDUMP = 9,
  /* add more */
  GST_LEVEL_COUNT
} GstDebugLevel;
</ENUM>
<MACRO>
<NAME>GST_LEVEL_DEFAULT</NAME>
#define GST_LEVEL_DEFAULT GST_LEVEL_NONE
</MACRO>
<MACRO>
<NAME>GST_LEVEL_MAX</NAME>
#define GST_LEVEL_MAX GST_LEVEL_COUNT
</MACRO>
<ENUM>
<NAME>GstDebugColorFlags</NAME>
typedef enum {
  /* colors */
  GST_DEBUG_FG_BLACK		= 0x0000,
  GST_DEBUG_FG_RED		= 0x0001,
  GST_DEBUG_FG_GREEN		= 0x0002,
  GST_DEBUG_FG_YELLOW		= 0x0003,
  GST_DEBUG_FG_BLUE		= 0x0004,
  GST_DEBUG_FG_MAGENTA		= 0x0005,
  GST_DEBUG_FG_CYAN		= 0x0006,
  GST_DEBUG_FG_WHITE		= 0x0007,
  /* background colors */
  GST_DEBUG_BG_BLACK		= 0x0000,
  GST_DEBUG_BG_RED		= 0x0010,
  GST_DEBUG_BG_GREEN		= 0x0020,
  GST_DEBUG_BG_YELLOW		= 0x0030,
  GST_DEBUG_BG_BLUE		= 0x0040,
  GST_DEBUG_BG_MAGENTA		= 0x0050,
  GST_DEBUG_BG_CYAN		= 0x0060,
  GST_DEBUG_BG_WHITE		= 0x0070,
  /* other formats */
  GST_DEBUG_BOLD		= 0x0100,
  GST_DEBUG_UNDERLINE		= 0x0200
} GstDebugColorFlags;
</ENUM>
<ENUM>
<NAME>GstDebugColorMode</NAME>
typedef enum {
  GST_DEBUG_COLOR_MODE_OFF  = 0,
  GST_DEBUG_COLOR_MODE_ON   = 1,
  GST_DEBUG_COLOR_MODE_UNIX = 2
} GstDebugColorMode;
</ENUM>
<MACRO>
<NAME>GST_DEBUG_FG_MASK</NAME>
#define GST_DEBUG_FG_MASK	(0x000F)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_BG_MASK</NAME>
#define GST_DEBUG_BG_MASK	(0x00F0)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_FORMAT_MASK</NAME>
#define GST_DEBUG_FORMAT_MASK	(0xFF00)
</MACRO>
<STRUCT>
<NAME>GstDebugCategory</NAME>
struct _GstDebugCategory {
  /*< private >*/
  gint                  threshold;
  guint			color;		/* see defines above */

  const gchar *		name;
  const gchar *		description;
};
</STRUCT>
<MACRO>
<NAME>GST_STR_NULL</NAME>
#define GST_STR_NULL(str) ((str) ? (str) : "(NULL)")
</MACRO>
<MACRO>
<NAME>GST_DEBUG_PAD_NAME</NAME>
#define GST_DEBUG_PAD_NAME(pad) \
  (pad != NULL) ?  \
  ((GST_OBJECT_PARENT(pad) != NULL) ? \
  GST_STR_NULL (GST_OBJECT_NAME (GST_OBJECT_PARENT(pad))) : \
  "''" ) : "''", \
  (pad != NULL) ? GST_STR_NULL (GST_OBJECT_NAME (pad)) : "''"
</MACRO>
<MACRO>
<NAME>GST_FUNCTION</NAME>
#  define GST_FUNCTION     ((const char*) (__FUNCTION__))
</MACRO>
<MACRO>
<NAME>GST_PTR_FORMAT</NAME>
#define GST_PTR_FORMAT     "p\aA"
</MACRO>
<MACRO>
<NAME>GST_SEGMENT_FORMAT</NAME>
#define GST_SEGMENT_FORMAT "p\aB"
</MACRO>
<USER_FUNCTION>
<NAME>GstLogFunction</NAME>
<RETURNS>void </RETURNS>
GstDebugCategory * category,
                                 GstDebugLevel      level,
                                 const gchar      * file,
                                 const gchar      * function,
                                 gint               line,
                                 GObject          * object,
                                 GstDebugMessage  * message,
                                 gpointer           user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_debug_log</NAME>
<RETURNS>void 		    </RETURNS>
GstDebugCategory * category, GstDebugLevel      level, const gchar      * file, const gchar      * function, gint               line, GObject          * object, const gchar      * format, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_log_valist</NAME>
<RETURNS>void             </RETURNS>
GstDebugCategory * category, GstDebugLevel      level, const gchar      * file, const gchar      * function, gint	              line, GObject          * object, const gchar      * format, va_list            args
</FUNCTION>
<USER_FUNCTION>
<NAME>GstDebugFuncPtr</NAME>
<RETURNS>void </RETURNS>
void
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_debug_message_get</NAME>
<RETURNS>const gchar    * </RETURNS>
GstDebugMessage  * message
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_log_default</NAME>
<RETURNS>void             </RETURNS>
GstDebugCategory * category, GstDebugLevel      level, const gchar      * file, const gchar      * function, gint               line, GObject          * object, GstDebugMessage  * message, gpointer           user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_level_get_name</NAME>
<RETURNS>const gchar  *   </RETURNS>
GstDebugLevel level
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_add_log_function</NAME>
<RETURNS>void             </RETURNS>
GstLogFunction func, gpointer       user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_remove_log_function</NAME>
<RETURNS>guint            </RETURNS>
GstLogFunction func
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_remove_log_function_by_data</NAME>
<RETURNS>guint            </RETURNS>
gpointer       data
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_active</NAME>
<RETURNS>void             </RETURNS>
gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_is_active</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_colored</NAME>
<RETURNS>void             </RETURNS>
gboolean colored
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_color_mode</NAME>
<RETURNS>void             </RETURNS>
GstDebugColorMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_color_mode_from_string</NAME>
<RETURNS>void             </RETURNS>
const gchar * mode
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_is_colored</NAME>
<RETURNS>gboolean         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_get_color_mode</NAME>
<RETURNS>GstDebugColorMode  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_default_threshold</NAME>
<RETURNS>void             </RETURNS>
GstDebugLevel level
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_get_default_threshold</NAME>
<RETURNS>GstDebugLevel    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_threshold_for_name</NAME>
<RETURNS>void             </RETURNS>
const gchar * name, GstDebugLevel level
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_set_threshold_from_string</NAME>
<RETURNS>void             </RETURNS>
const gchar * list, gboolean reset
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_unset_threshold_for_name</NAME>
<RETURNS>void             </RETURNS>
const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_free</NAME>
<RETURNS>void             </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_set_threshold</NAME>
<RETURNS>void 	            </RETURNS>
GstDebugCategory *	category, GstDebugLevel		level
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_reset_threshold</NAME>
<RETURNS>void             </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_get_threshold</NAME>
<RETURNS>GstDebugLevel    </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_get_name</NAME>
<RETURNS>const gchar  *   </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_get_color</NAME>
<RETURNS>guint            </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_category_get_description</NAME>
<RETURNS>const gchar  *   </RETURNS>
GstDebugCategory *	category
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_get_all_categories</NAME>
<RETURNS>GSList  *        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_construct_term_color</NAME>
<RETURNS>gchar  * </RETURNS>
guint colorinfo
</FUNCTION>
<FUNCTION>
<NAME>gst_debug_construct_win_color</NAME>
<RETURNS>gint     </RETURNS>
guint colorinfo
</FUNCTION>
<MACRO>
<NAME>GST_DEBUG_CATEGORY</NAME>
#define GST_DEBUG_CATEGORY(cat) GstDebugCategory *cat = NULL
</MACRO>
<MACRO>
<NAME>GST_DEBUG_CATEGORY_EXTERN</NAME>
#define GST_DEBUG_CATEGORY_EXTERN(cat) extern GstDebugCategory *cat
</MACRO>
<MACRO>
<NAME>GST_DEBUG_CATEGORY_STATIC</NAME>
#define GST_DEBUG_CATEGORY_STATIC(cat) static GstDebugCategory *cat = NULL
</MACRO>
<MACRO>
<NAME>GST_DEBUG_CATEGORY_INIT</NAME>
#define GST_DEBUG_CATEGORY_INIT(cat,name,color,description) G_STMT_START{\
  if (cat == NULL)							\
    cat = _gst_debug_category_new (name,color,description);		\
}G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_DEBUG_CATEGORY_GET</NAME>
#define GST_DEBUG_CATEGORY_GET(cat,name)  G_STMT_START{\
  cat = _gst_debug_get_category (name);			\
  if (!cat) {						\
    cat = GST_CAT_DEFAULT;				\
  }							\
}G_STMT_END
</MACRO>
<VARIABLE>
<NAME>GST_CAT_DEFAULT</NAME>
GST_EXPORT GstDebugCategory *	GST_CAT_DEFAULT;
</VARIABLE>
<MACRO>
<NAME>GST_CAT_LEVEL_LOG</NAME>
#define GST_CAT_LEVEL_LOG(cat,level,object,...) G_STMT_START{		\
  if (G_UNLIKELY (level <= GST_LEVEL_MAX && level <= _gst_debug_min)) {						\
    gst_debug_log ((cat), (level), __FILE__, GST_FUNCTION, __LINE__,	\
        (GObject *) (object), __VA_ARGS__);				\
  }									\
}G_STMT_END
</MACRO>
<FUNCTION>
<NAME>GST_CAT_LEVEL_LOG_valist</NAME>
<RETURNS>void </RETURNS>
GstDebugCategory * cat, GstDebugLevel level, gpointer object, const char *format, va_list varargs
</FUNCTION>
<MACRO>
<NAME>GST_CAT_MEMDUMP_OBJECT</NAME>
#define GST_CAT_MEMDUMP_OBJECT(cat,obj,msg,data,length)  \
    __GST_CAT_MEMDUMP_LOG(cat,obj,msg,data,length)
</MACRO>
<MACRO>
<NAME>GST_CAT_MEMDUMP</NAME>
#define GST_CAT_MEMDUMP(cat,msg,data,length)             \
    __GST_CAT_MEMDUMP_LOG(cat,NULL,msg,data,length)
</MACRO>
<MACRO>
<NAME>GST_MEMDUMP_OBJECT</NAME>
#define GST_MEMDUMP_OBJECT(obj,msg,data,length)          \
    __GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT,obj,msg,data,length)
</MACRO>
<MACRO>
<NAME>GST_MEMDUMP</NAME>
#define GST_MEMDUMP(msg,data,length)                     \
    __GST_CAT_MEMDUMP_LOG(GST_CAT_DEFAULT,NULL,msg,data,length)
</MACRO>
<MACRO>
<NAME>GST_CAT_ERROR_OBJECT</NAME>
#define GST_CAT_ERROR_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_ERROR,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_WARNING_OBJECT</NAME>
#define GST_CAT_WARNING_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_WARNING, obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_INFO_OBJECT</NAME>
#define GST_CAT_INFO_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_INFO,    obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_DEBUG_OBJECT</NAME>
#define GST_CAT_DEBUG_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_DEBUG,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_LOG_OBJECT</NAME>
#define GST_CAT_LOG_OBJECT(cat,obj,...)		GST_CAT_LEVEL_LOG (cat, GST_LEVEL_LOG,     obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_FIXME_OBJECT</NAME>
#define GST_CAT_FIXME_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_FIXME,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_TRACE_OBJECT</NAME>
#define GST_CAT_TRACE_OBJECT(cat,obj,...)	GST_CAT_LEVEL_LOG (cat, GST_LEVEL_TRACE,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_ERROR</NAME>
#define GST_CAT_ERROR(cat,...)			GST_CAT_LEVEL_LOG (cat, GST_LEVEL_ERROR,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_WARNING</NAME>
#define GST_CAT_WARNING(cat,...)		GST_CAT_LEVEL_LOG (cat, GST_LEVEL_WARNING, NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_INFO</NAME>
#define GST_CAT_INFO(cat,...)			GST_CAT_LEVEL_LOG (cat, GST_LEVEL_INFO,    NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_DEBUG</NAME>
#define GST_CAT_DEBUG(cat,...)			GST_CAT_LEVEL_LOG (cat, GST_LEVEL_DEBUG,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_LOG</NAME>
#define GST_CAT_LOG(cat,...)			GST_CAT_LEVEL_LOG (cat, GST_LEVEL_LOG,     NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_FIXME</NAME>
#define GST_CAT_FIXME(cat,...)			GST_CAT_LEVEL_LOG (cat, GST_LEVEL_FIXME,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_CAT_TRACE</NAME>
#define GST_CAT_TRACE(cat,...)		GST_CAT_LEVEL_LOG (cat, GST_LEVEL_TRACE,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_ERROR_OBJECT</NAME>
#define GST_ERROR_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_ERROR,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_WARNING_OBJECT</NAME>
#define GST_WARNING_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_WARNING, obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_INFO_OBJECT</NAME>
#define GST_INFO_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_INFO,    obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_OBJECT</NAME>
#define GST_DEBUG_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_DEBUG,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_LOG_OBJECT</NAME>
#define GST_LOG_OBJECT(obj,...)		GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_LOG,     obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_FIXME_OBJECT</NAME>
#define GST_FIXME_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_FIXME,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_TRACE_OBJECT</NAME>
#define GST_TRACE_OBJECT(obj,...)	GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_TRACE,   obj,  __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_ERROR</NAME>
#define GST_ERROR(...)			GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_ERROR,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_WARNING</NAME>
#define GST_WARNING(...)		GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_WARNING, NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_INFO</NAME>
#define GST_INFO(...)			GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_INFO,    NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_DEBUG</NAME>
#define GST_DEBUG(...)			GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_DEBUG,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_LOG</NAME>
#define GST_LOG(...)			GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_LOG,     NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_FIXME</NAME>
#define GST_FIXME(...)			GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_FIXME,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_TRACE</NAME>
#define GST_TRACE(...)		GST_CAT_LEVEL_LOG (GST_CAT_DEFAULT, GST_LEVEL_TRACE,   NULL, __VA_ARGS__)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_REGISTER_FUNCPTR</NAME>
#define GST_DEBUG_REGISTER_FUNCPTR(ptr) \
  _gst_debug_register_funcptr((GstDebugFuncPtr)(ptr), #ptr)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_FUNCPTR</NAME>
#define GST_DEBUG_FUNCPTR(ptr) \
  (_gst_debug_register_funcptr((GstDebugFuncPtr)(ptr), #ptr) , ptr)
</MACRO>
<MACRO>
<NAME>GST_DEBUG_FUNCPTR_NAME</NAME>
#define GST_DEBUG_FUNCPTR_NAME(ptr) \
  _gst_debug_nameof_funcptr((GstDebugFuncPtr)ptr)
</MACRO>
<FUNCTION>
<NAME>gst_debug_print_stack_trace</NAME>
<RETURNS>void  </RETURNS>
void
</FUNCTION>
<STRUCT>
<NAME>GstDebugMessage</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DEVICE_PROVIDER_FACTORY</NAME>
#define GST_TYPE_DEVICE_PROVIDER_FACTORY            (gst_device_provider_factory_get_type())
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_FACTORY</NAME>
#define GST_DEVICE_PROVIDER_FACTORY(obj)            (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_DEVICE_PROVIDER_FACTORY,\
                                                 GstDeviceProviderFactory))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_FACTORY_CLASS</NAME>
#define GST_DEVICE_PROVIDER_FACTORY_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_DEVICE_PROVIDER_FACTORY,\
                                                 GstDeviceProviderFactoryClass))
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_PROVIDER_FACTORY</NAME>
#define GST_IS_DEVICE_PROVIDER_FACTORY(obj)         (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_DEVICE_PROVIDER_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_PROVIDER_FACTORY_CLASS</NAME>
#define GST_IS_DEVICE_PROVIDER_FACTORY_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_DEVICE_PROVIDER_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_PROVIDER_FACTORY_CAST</NAME>
#define GST_DEVICE_PROVIDER_FACTORY_CAST(obj)       ((GstDeviceProviderFactory *)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_device_provider_factory_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_find</NAME>
<RETURNS>GstDeviceProviderFactory  * </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_get_device_provider_type</NAME>
<RETURNS>GType                    </RETURNS>
GstDeviceProviderFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_get_metadata</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstDeviceProviderFactory *factory, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_get_metadata_keys</NAME>
<RETURNS>gchar  **                </RETURNS>
GstDeviceProviderFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_get</NAME>
<RETURNS>GstDeviceProvider *       </RETURNS>
GstDeviceProviderFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_get_by_name</NAME>
<RETURNS>GstDeviceProvider *       </RETURNS>
const gchar *factoryname
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_register</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPlugin *plugin, const gchar *name, guint rank, GType type
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_has_classesv</NAME>
<RETURNS>gboolean       </RETURNS>
GstDeviceProviderFactory * factory, gchar ** classes
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_has_classes</NAME>
<RETURNS>gboolean       </RETURNS>
GstDeviceProviderFactory *factory, const gchar * classes
</FUNCTION>
<FUNCTION>
<NAME>gst_device_provider_factory_list_get_device_providers</NAME>
<RETURNS>GList  *       </RETURNS>
 GstRank minrank
</FUNCTION>
<STRUCT>
<NAME>GstDeviceProviderFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstDeviceProviderFactoryClass</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PLUGIN_FEATURE</NAME>
#define GST_TYPE_PLUGIN_FEATURE                 (gst_plugin_feature_get_type())
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_FEATURE</NAME>
#define GST_PLUGIN_FEATURE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PLUGIN_FEATURE, GstPluginFeature))
</MACRO>
<MACRO>
<NAME>GST_IS_PLUGIN_FEATURE</NAME>
#define GST_IS_PLUGIN_FEATURE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PLUGIN_FEATURE))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_FEATURE_CLASS</NAME>
#define GST_PLUGIN_FEATURE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PLUGIN_FEATURE_CLASS</NAME>
#define GST_IS_PLUGIN_FEATURE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PLUGIN_FEATURE))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_FEATURE_GET_CLASS</NAME>
#define GST_PLUGIN_FEATURE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PLUGIN_FEATURE, GstPluginFeatureClass))
</MACRO>
<MACRO>
<NAME>GST_PLUGIN_FEATURE_CAST</NAME>
#define GST_PLUGIN_FEATURE_CAST(obj)            ((GstPluginFeature*)(obj))
</MACRO>
<ENUM>
<NAME>GstRank</NAME>
typedef enum {
  GST_RANK_NONE                 = 0,
  GST_RANK_MARGINAL             = 64,
  GST_RANK_SECONDARY            = 128,
  GST_RANK_PRIMARY              = 256
} GstRank;
</ENUM>
<MACRO>
<NAME>gst_plugin_feature_get_name</NAME>
#define                 gst_plugin_feature_get_name(feature)      GST_OBJECT_NAME(feature)
</MACRO>
<MACRO>
<NAME>gst_plugin_feature_set_name</NAME>
#define                 gst_plugin_feature_set_name(feature,name) gst_object_set_name(GST_OBJECT_CAST(feature),name)
</MACRO>
<USER_FUNCTION>
<NAME>GstPluginFeatureFilter</NAME>
<RETURNS>gboolean </RETURNS>
GstPluginFeature *feature,
                                                         gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_load</NAME>
<RETURNS>GstPluginFeature  *</RETURNS>
GstPluginFeature *feature
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_set_rank</NAME>
<RETURNS>void             </RETURNS>
GstPluginFeature *feature, guint rank
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_get_rank</NAME>
<RETURNS>guint            </RETURNS>
GstPluginFeature *feature
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_get_plugin</NAME>
<RETURNS>GstPlugin      * </RETURNS>
GstPluginFeature *feature
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_get_plugin_name</NAME>
<RETURNS>const gchar    * </RETURNS>
GstPluginFeature *feature
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_list_free</NAME>
<RETURNS>void             </RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_list_copy</NAME>
<RETURNS>GList           *</RETURNS>
GList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_list_debug</NAME>
<RETURNS>void             </RETURNS>
GList *list
</FUNCTION>
<MACRO>
<NAME>GST_PLUGIN_FEATURE_LIST_DEBUG</NAME>
#define GST_PLUGIN_FEATURE_LIST_DEBUG(list) gst_plugin_feature_list_debug(list)
</MACRO>
<FUNCTION>
<NAME>gst_plugin_feature_check_version</NAME>
<RETURNS>gboolean         </RETURNS>
GstPluginFeature *feature, guint             min_major, guint             min_minor, guint             min_micro
</FUNCTION>
<FUNCTION>
<NAME>gst_plugin_feature_rank_compare_func</NAME>
<RETURNS>gint             </RETURNS>
gconstpointer p1, gconstpointer p2
</FUNCTION>
<STRUCT>
<NAME>GstPluginFeature</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPluginFeatureClass</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_uri_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_URI_ERROR</NAME>
#define GST_URI_ERROR gst_uri_error_quark ()
</MACRO>
<ENUM>
<NAME>GstURIError</NAME>
typedef enum
{
  GST_URI_ERROR_UNSUPPORTED_PROTOCOL,
  GST_URI_ERROR_BAD_URI,
  GST_URI_ERROR_BAD_STATE,
  GST_URI_ERROR_BAD_REFERENCE
} GstURIError;
</ENUM>
<ENUM>
<NAME>GstURIType</NAME>
typedef enum {
  GST_URI_UNKNOWN,
  GST_URI_SINK,
  GST_URI_SRC
} GstURIType;
</ENUM>
<MACRO>
<NAME>GST_URI_TYPE_IS_VALID</NAME>
#define GST_URI_TYPE_IS_VALID(type) ((type) == GST_URI_SRC || (type) == GST_URI_SINK)
</MACRO>
<MACRO>
<NAME>GST_TYPE_URI_HANDLER</NAME>
#define GST_TYPE_URI_HANDLER               (gst_uri_handler_get_type ())
</MACRO>
<MACRO>
<NAME>GST_URI_HANDLER</NAME>
#define GST_URI_HANDLER(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_URI_HANDLER, GstURIHandler))
</MACRO>
<MACRO>
<NAME>GST_IS_URI_HANDLER</NAME>
#define GST_IS_URI_HANDLER(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_URI_HANDLER))
</MACRO>
<MACRO>
<NAME>GST_URI_HANDLER_GET_INTERFACE</NAME>
#define GST_URI_HANDLER_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_URI_HANDLER, GstURIHandlerInterface))
</MACRO>
<STRUCT>
<NAME>GstURIHandlerInterface</NAME>
struct _GstURIHandlerInterface {
  GTypeInterface parent;

  /* vtable */
  /*< public >*/
  /* querying capabilities */
  GstURIType             (* get_type)           (GType type);
  const gchar * const *  (* get_protocols)      (GType type);

  /* using the interface */
  gchar *                (* get_uri)            (GstURIHandler * handler);
  gboolean               (* set_uri)            (GstURIHandler * handler,
                                                 const gchar   * uri,
                                                 GError       ** error);
};
</STRUCT>
<FUNCTION>
<NAME>gst_uri_protocol_is_valid</NAME>
<RETURNS>gboolean         </RETURNS>
const gchar * protocol
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_protocol_is_supported</NAME>
<RETURNS>gboolean         </RETURNS>
const GstURIType type, const gchar *protocol
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_is_valid</NAME>
<RETURNS>gboolean         </RETURNS>
const gchar * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_protocol</NAME>
<RETURNS>gchar  *         </RETURNS>
const gchar * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_has_protocol</NAME>
<RETURNS>gboolean         </RETURNS>
const gchar * uri, const gchar * protocol
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_location</NAME>
<RETURNS>gchar  *         </RETURNS>
const gchar * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_construct</NAME>
<RETURNS>gchar  *         </RETURNS>
const gchar * protocol, const gchar * location
</FUNCTION>
<FUNCTION>
<NAME>gst_filename_to_uri</NAME>
<RETURNS>gchar  *         </RETURNS>
const gchar * filename, GError     ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_element_make_from_uri</NAME>
<RETURNS>GstElement  *    </RETURNS>
const GstURIType type, const gchar *    uri, const gchar *    elementname, GError      **   error
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_handler_get_type</NAME>
<RETURNS>GType                  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_handler_get_uri_type</NAME>
<RETURNS>GstURIType             </RETURNS>
GstURIHandler * handler
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_handler_get_protocols</NAME>
<RETURNS>const gchar  * const *</RETURNS>
GstURIHandler * handler
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_handler_get_uri</NAME>
<RETURNS>gchar  *               </RETURNS>
GstURIHandler * handler
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_handler_set_uri</NAME>
<RETURNS>gboolean               </RETURNS>
GstURIHandler * handler, const gchar   * uri, GError       ** error
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_URI</NAME>
#define GST_TYPE_URI        (gst_uri_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_URI</NAME>
#define GST_IS_URI(obj)	    (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_URI))
</MACRO>
<MACRO>
<NAME>GST_URI_CAST</NAME>
#define GST_URI_CAST(obj)   ((GstUri *)(obj))
</MACRO>
<MACRO>
<NAME>GST_URI_CONST_CAST</NAME>
#define GST_URI_CONST_CAST(obj) ((const GstUri *)(obj))
</MACRO>
<MACRO>
<NAME>GST_URI</NAME>
#define GST_URI(obj)        (GST_URI_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_URI_NO_PORT</NAME>
#define GST_URI_NO_PORT 0
</MACRO>
<FUNCTION>
<NAME>gst_uri_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_new</NAME>
<RETURNS>GstUri  * </RETURNS>
const gchar * scheme, const gchar * userinfo, const gchar * host, guint port, const gchar * path, const gchar * query, const gchar * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_new_with_base</NAME>
<RETURNS>GstUri  * </RETURNS>
GstUri * base, const gchar * scheme, const gchar * userinfo, const gchar * host, guint port, const gchar * path, const gchar * query, const gchar * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_from_string</NAME>
<RETURNS>GstUri  * </RETURNS>
const gchar * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_from_string_with_base</NAME>
<RETURNS>GstUri  * </RETURNS>
GstUri * base, const gchar * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_equal</NAME>
<RETURNS>gboolean  </RETURNS>
const GstUri * first, const GstUri * second
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_join</NAME>
<RETURNS>GstUri  * </RETURNS>
GstUri * base_uri, GstUri * ref_uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_join_strings</NAME>
<RETURNS>gchar  *  </RETURNS>
const gchar * base_uri, const gchar * ref_uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_is_writable</NAME>
<RETURNS>gboolean  </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_make_writable</NAME>
<RETURNS>GstUri  * </RETURNS>
GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_to_string</NAME>
<RETURNS>gchar  *  </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_is_normalized</NAME>
<RETURNS>gboolean  </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_normalize</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_scheme</NAME>
<RETURNS>const gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_scheme</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * scheme
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_userinfo</NAME>
<RETURNS>const gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_userinfo</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * userinfo
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_host</NAME>
<RETURNS>const gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_host</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * host
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_port</NAME>
<RETURNS>guint  </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_port</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, guint port
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_path</NAME>
<RETURNS>gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_path</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_path_string</NAME>
<RETURNS>gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_path_string</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * path
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_path_segments</NAME>
<RETURNS>GList  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_path_segments</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, GList * path_segments
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_append_path</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * relative_path
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_append_path_segment</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * path_segment
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_query_string</NAME>
<RETURNS>gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_query_string</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * query
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_query_table</NAME>
<RETURNS>GHashTable  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_query_table</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, GHashTable * query_table
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_query_value</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * query_key, const gchar * query_value
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_remove_query_key</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * query_key
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_query_has_key</NAME>
<RETURNS>gboolean  </RETURNS>
const GstUri * uri, const gchar * query_key
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_query_value</NAME>
<RETURNS>const gchar  * </RETURNS>
const GstUri * uri, const gchar * query_key
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_query_keys</NAME>
<RETURNS>GList  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_get_fragment</NAME>
<RETURNS>const gchar  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_set_fragment</NAME>
<RETURNS>gboolean  </RETURNS>
GstUri * uri, const gchar * fragment
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_copy</NAME>
<RETURNS>GstUri  * </RETURNS>
const GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_ref</NAME>
<RETURNS>GstUri  * </RETURNS>
GstUri * uri
</FUNCTION>
<FUNCTION>
<NAME>gst_uri_unref</NAME>
<RETURNS>void  </RETURNS>
GstUri * uri
</FUNCTION>
<STRUCT>
<NAME>GstURIHandler</NAME>
</STRUCT>
<STRUCT>
<NAME>GstUri</NAME>
</STRUCT>
<ENUM>
<NAME>GstPadDirection</NAME>
typedef enum {
  GST_PAD_UNKNOWN,
  GST_PAD_SRC,
  GST_PAD_SINK
} GstPadDirection;
</ENUM>
<ENUM>
<NAME>GstPadMode</NAME>
typedef enum {
  GST_PAD_MODE_NONE,
  GST_PAD_MODE_PUSH,
  GST_PAD_MODE_PULL
} GstPadMode;
</ENUM>
<FUNCTION>
<NAME>gst_pad_mode_get_name</NAME>
<RETURNS>const gchar    * </RETURNS>
GstPadMode mode
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PAD</NAME>
#define GST_TYPE_PAD			(gst_pad_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_PAD</NAME>
#define GST_IS_PAD(obj)			(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PAD))
</MACRO>
<MACRO>
<NAME>GST_IS_PAD_CLASS</NAME>
#define GST_IS_PAD_CLASS(klass)		(G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PAD))
</MACRO>
<MACRO>
<NAME>GST_PAD</NAME>
#define GST_PAD(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PAD, GstPad))
</MACRO>
<MACRO>
<NAME>GST_PAD_CLASS</NAME>
#define GST_PAD_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PAD, GstPadClass))
</MACRO>
<MACRO>
<NAME>GST_PAD_CAST</NAME>
#define GST_PAD_CAST(obj)		((GstPad*)(obj))
</MACRO>
<ENUM>
<NAME>GstPadLinkReturn</NAME>
typedef enum {
  GST_PAD_LINK_OK               =  0,
  GST_PAD_LINK_WRONG_HIERARCHY  = -1,
  GST_PAD_LINK_WAS_LINKED       = -2,
  GST_PAD_LINK_WRONG_DIRECTION  = -3,
  GST_PAD_LINK_NOFORMAT         = -4,
  GST_PAD_LINK_NOSCHED          = -5,
  GST_PAD_LINK_REFUSED          = -6
} GstPadLinkReturn;
</ENUM>
<MACRO>
<NAME>GST_PAD_LINK_FAILED</NAME>
#define GST_PAD_LINK_FAILED(ret) ((ret) < GST_PAD_LINK_OK)
</MACRO>
<MACRO>
<NAME>GST_PAD_LINK_SUCCESSFUL</NAME>
#define GST_PAD_LINK_SUCCESSFUL(ret) ((ret) >= GST_PAD_LINK_OK)
</MACRO>
<ENUM>
<NAME>GstFlowReturn</NAME>
typedef enum {
  /* custom success starts here */
  GST_FLOW_CUSTOM_SUCCESS_2 = 102,
  GST_FLOW_CUSTOM_SUCCESS_1 = 101,
  GST_FLOW_CUSTOM_SUCCESS = 100,

  /* core predefined */
  GST_FLOW_OK		  =  0,
  /* expected failures */
  GST_FLOW_NOT_LINKED     = -1,
  GST_FLOW_FLUSHING       = -2,
  /* error cases */
  GST_FLOW_EOS            = -3,
  GST_FLOW_NOT_NEGOTIATED = -4,
  GST_FLOW_ERROR	  = -5,
  GST_FLOW_NOT_SUPPORTED  = -6,

  /* custom error starts here */
  GST_FLOW_CUSTOM_ERROR   = -100,
  GST_FLOW_CUSTOM_ERROR_1 = -101,
  GST_FLOW_CUSTOM_ERROR_2 = -102
} GstFlowReturn;
</ENUM>
<FUNCTION>
<NAME>gst_flow_get_name</NAME>
<RETURNS>const gchar *	        </RETURNS>
GstFlowReturn ret
</FUNCTION>
<FUNCTION>
<NAME>gst_flow_to_quark</NAME>
<RETURNS>GQuark 			          </RETURNS>
GstFlowReturn ret
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_link_get_name</NAME>
<RETURNS>const gchar *          </RETURNS>
GstPadLinkReturn ret
</FUNCTION>
<ENUM>
<NAME>GstPadLinkCheck</NAME>
typedef enum {
  GST_PAD_LINK_CHECK_NOTHING       = 0,
  GST_PAD_LINK_CHECK_HIERARCHY     = 1 << 0,
  GST_PAD_LINK_CHECK_TEMPLATE_CAPS = 1 << 1,
  GST_PAD_LINK_CHECK_CAPS          = 1 << 2,

  GST_PAD_LINK_CHECK_DEFAULT       = GST_PAD_LINK_CHECK_HIERARCHY | GST_PAD_LINK_CHECK_CAPS
} GstPadLinkCheck;
</ENUM>
<USER_FUNCTION>
<NAME>GstPadActivateFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstObject *parent
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadActivateModeFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 GstPadMode mode, gboolean active
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadChainFunction</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 GstBuffer *buffer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadChainListFunction</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 GstBufferList *list
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadGetRangeFunction</NAME>
<RETURNS>GstFlowReturn </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 guint64 offset, guint length,
                                                                 GstBuffer **buffer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadEventFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 GstEvent *event
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadIterIntLinkFunction</NAME>
<RETURNS>GstIterator *</RETURNS>
GstPad *pad, GstObject *parent
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadQueryFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstObject *parent,
                                                                 GstQuery *query
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadLinkFunction</NAME>
<RETURNS>GstPadLinkReturn </RETURNS>
GstPad *pad, GstObject *parent, GstPad *peer
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadUnlinkFunction</NAME>
<RETURNS>void </RETURNS>
GstPad *pad, GstObject *parent
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadForwardFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstPadProbeType</NAME>
typedef enum
{
  GST_PAD_PROBE_TYPE_INVALID          = 0,
  /* flags to control blocking */
  GST_PAD_PROBE_TYPE_IDLE             = (1 << 0),
  GST_PAD_PROBE_TYPE_BLOCK            = (1 << 1),
  /* flags to select datatypes */
  GST_PAD_PROBE_TYPE_BUFFER           = (1 << 4),
  GST_PAD_PROBE_TYPE_BUFFER_LIST      = (1 << 5),
  GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM = (1 << 6),
  GST_PAD_PROBE_TYPE_EVENT_UPSTREAM   = (1 << 7),
  GST_PAD_PROBE_TYPE_EVENT_FLUSH      = (1 << 8),
  GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM = (1 << 9),
  GST_PAD_PROBE_TYPE_QUERY_UPSTREAM   = (1 << 10),
  /* flags to select scheduling mode */
  GST_PAD_PROBE_TYPE_PUSH             = (1 << 12),
  GST_PAD_PROBE_TYPE_PULL             = (1 << 13),

  /* flag combinations */
  GST_PAD_PROBE_TYPE_BLOCKING         = GST_PAD_PROBE_TYPE_IDLE | GST_PAD_PROBE_TYPE_BLOCK,
  GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM  = GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_BUFFER_LIST | GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM,
  GST_PAD_PROBE_TYPE_DATA_UPSTREAM    = GST_PAD_PROBE_TYPE_EVENT_UPSTREAM,
  GST_PAD_PROBE_TYPE_DATA_BOTH        = GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM | GST_PAD_PROBE_TYPE_DATA_UPSTREAM,
  GST_PAD_PROBE_TYPE_BLOCK_DOWNSTREAM = GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_DATA_DOWNSTREAM,
  GST_PAD_PROBE_TYPE_BLOCK_UPSTREAM   = GST_PAD_PROBE_TYPE_BLOCK | GST_PAD_PROBE_TYPE_DATA_UPSTREAM,
  GST_PAD_PROBE_TYPE_EVENT_BOTH       = GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM | GST_PAD_PROBE_TYPE_EVENT_UPSTREAM,
  GST_PAD_PROBE_TYPE_QUERY_BOTH       = GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM | GST_PAD_PROBE_TYPE_QUERY_UPSTREAM,
  GST_PAD_PROBE_TYPE_ALL_BOTH         = GST_PAD_PROBE_TYPE_DATA_BOTH | GST_PAD_PROBE_TYPE_QUERY_BOTH,
  GST_PAD_PROBE_TYPE_SCHEDULING       = GST_PAD_PROBE_TYPE_PUSH | GST_PAD_PROBE_TYPE_PULL
} GstPadProbeType;
</ENUM>
<ENUM>
<NAME>GstPadProbeReturn</NAME>
typedef enum
{
  GST_PAD_PROBE_DROP,
  GST_PAD_PROBE_OK,
  GST_PAD_PROBE_REMOVE,
  GST_PAD_PROBE_PASS,
  GST_PAD_PROBE_HANDLED
} GstPadProbeReturn;
</ENUM>
<STRUCT>
<NAME>GstPadProbeInfo</NAME>
struct _GstPadProbeInfo
{
  GstPadProbeType type;
  gulong id;
  gpointer data;
  guint64 offset;
  guint size;

  /*< private >*/
  union {
    gpointer _gst_reserved[GST_PADDING];
    struct {
      GstFlowReturn flow_ret;
    } abi;
  } ABI;
};
</STRUCT>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_TYPE</NAME>
#define GST_PAD_PROBE_INFO_TYPE(d)         ((d)->type)
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_ID</NAME>
#define GST_PAD_PROBE_INFO_ID(d)           ((d)->id)
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_DATA</NAME>
#define GST_PAD_PROBE_INFO_DATA(d)         ((d)->data)
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_FLOW_RETURN</NAME>
#define GST_PAD_PROBE_INFO_FLOW_RETURN(d)  ((d)->ABI.abi.flow_ret)
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_BUFFER</NAME>
#define GST_PAD_PROBE_INFO_BUFFER(d)       GST_BUFFER_CAST(GST_PAD_PROBE_INFO_DATA(d))
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_BUFFER_LIST</NAME>
#define GST_PAD_PROBE_INFO_BUFFER_LIST(d)  GST_BUFFER_LIST_CAST(GST_PAD_PROBE_INFO_DATA(d))
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_EVENT</NAME>
#define GST_PAD_PROBE_INFO_EVENT(d)        GST_EVENT_CAST(GST_PAD_PROBE_INFO_DATA(d))
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_QUERY</NAME>
#define GST_PAD_PROBE_INFO_QUERY(d)        GST_QUERY_CAST(GST_PAD_PROBE_INFO_DATA(d))
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_OFFSET</NAME>
#define GST_PAD_PROBE_INFO_OFFSET(d)       ((d)->offset)
</MACRO>
<MACRO>
<NAME>GST_PAD_PROBE_INFO_SIZE</NAME>
#define GST_PAD_PROBE_INFO_SIZE(d)         ((d)->size)
</MACRO>
<FUNCTION>
<NAME>gst_pad_probe_info_get_event</NAME>
<RETURNS>GstEvent *      </RETURNS>
GstPadProbeInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_probe_info_get_query</NAME>
<RETURNS>GstQuery *      </RETURNS>
GstPadProbeInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_probe_info_get_buffer</NAME>
<RETURNS>GstBuffer *     </RETURNS>
GstPadProbeInfo * info
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_probe_info_get_buffer_list</NAME>
<RETURNS>GstBufferList * </RETURNS>
GstPadProbeInfo * info
</FUNCTION>
<USER_FUNCTION>
<NAME>GstPadProbeCallback</NAME>
<RETURNS>GstPadProbeReturn </RETURNS>
GstPad *pad, GstPadProbeInfo *info,
                                                      gpointer user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstPadStickyEventsForeachFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstPad *pad, GstEvent **event,
                                                        gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstPadFlags</NAME>
typedef enum {
  GST_PAD_FLAG_BLOCKED          = (GST_OBJECT_FLAG_LAST << 0),
  GST_PAD_FLAG_FLUSHING         = (GST_OBJECT_FLAG_LAST << 1),
  GST_PAD_FLAG_EOS              = (GST_OBJECT_FLAG_LAST << 2),
  GST_PAD_FLAG_BLOCKING         = (GST_OBJECT_FLAG_LAST << 3),
  GST_PAD_FLAG_NEED_PARENT      = (GST_OBJECT_FLAG_LAST << 4),
  GST_PAD_FLAG_NEED_RECONFIGURE = (GST_OBJECT_FLAG_LAST << 5),
  GST_PAD_FLAG_PENDING_EVENTS   = (GST_OBJECT_FLAG_LAST << 6),
  GST_PAD_FLAG_FIXED_CAPS       = (GST_OBJECT_FLAG_LAST << 7),
  GST_PAD_FLAG_PROXY_CAPS       = (GST_OBJECT_FLAG_LAST << 8),
  GST_PAD_FLAG_PROXY_ALLOCATION = (GST_OBJECT_FLAG_LAST << 9),
  GST_PAD_FLAG_PROXY_SCHEDULING = (GST_OBJECT_FLAG_LAST << 10),
  GST_PAD_FLAG_ACCEPT_INTERSECT = (GST_OBJECT_FLAG_LAST << 11),
  GST_PAD_FLAG_ACCEPT_TEMPLATE  = (GST_OBJECT_FLAG_LAST << 12),
  /* padding */
  GST_PAD_FLAG_LAST        = (GST_OBJECT_FLAG_LAST << 16)
} GstPadFlags;
</ENUM>
<STRUCT>
<NAME>GstPad</NAME>
struct _GstPad {
  GstObject                      object;

  /*< public >*/
  gpointer                       element_private;

  GstPadTemplate                *padtemplate;

  GstPadDirection                direction;

  /*< private >*/
  /* streaming rec_lock */
  GRecMutex		         stream_rec_lock;
  GstTask			*task;

  /* block cond, mutex is from the object */
  GCond				 block_cond;
  GHookList                      probes;

  GstPadMode		         mode;
  GstPadActivateFunction	 activatefunc;
  gpointer                       activatedata;
  GDestroyNotify                 activatenotify;
  GstPadActivateModeFunction	 activatemodefunc;
  gpointer                       activatemodedata;
  GDestroyNotify                 activatemodenotify;

  /* pad link */
  GstPad			*peer;
  GstPadLinkFunction		 linkfunc;
  gpointer                       linkdata;
  GDestroyNotify                 linknotify;
  GstPadUnlinkFunction		 unlinkfunc;
  gpointer                       unlinkdata;
  GDestroyNotify                 unlinknotify;

  /* data transport functions */
  GstPadChainFunction		 chainfunc;
  gpointer                       chaindata;
  GDestroyNotify                 chainnotify;
  GstPadChainListFunction        chainlistfunc;
  gpointer                       chainlistdata;
  GDestroyNotify                 chainlistnotify;
  GstPadGetRangeFunction	 getrangefunc;
  gpointer                       getrangedata;
  GDestroyNotify                 getrangenotify;
  GstPadEventFunction		 eventfunc;
  gpointer                       eventdata;
  GDestroyNotify                 eventnotify;

  /* pad offset */
  gint64                         offset;

  /* generic query method */
  GstPadQueryFunction		 queryfunc;
  gpointer                       querydata;
  GDestroyNotify                 querynotify;

  /* internal links */
  GstPadIterIntLinkFunction      iterintlinkfunc;
  gpointer                       iterintlinkdata;
  GDestroyNotify                 iterintlinknotify;

  /* counts number of probes attached. */
  gint				 num_probes;
  gint				 num_blocked;

  GstPadPrivate                 *priv;

  union {
    gpointer _gst_reserved[GST_PADDING];
    struct {
      GstFlowReturn last_flowret;
    } abi;
  } ABI;
};
</STRUCT>
<STRUCT>
<NAME>GstPadClass</NAME>
struct _GstPadClass {
  GstObjectClass	parent_class;

  /* signal callbacks */
  void		(*linked)		(GstPad *pad, GstPad *peer);
  void		(*unlinked)		(GstPad *pad, GstPad *peer);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_PAD_NAME</NAME>
#define GST_PAD_NAME(pad)		(GST_OBJECT_NAME(pad))
</MACRO>
<MACRO>
<NAME>GST_PAD_PARENT</NAME>
#define GST_PAD_PARENT(pad)		(GST_ELEMENT_CAST(GST_OBJECT_PARENT(pad)))
</MACRO>
<MACRO>
<NAME>GST_PAD_ELEMENT_PRIVATE</NAME>
#define GST_PAD_ELEMENT_PRIVATE(pad)    (GST_PAD_CAST(pad)->element_private)
</MACRO>
<MACRO>
<NAME>GST_PAD_PAD_TEMPLATE</NAME>
#define GST_PAD_PAD_TEMPLATE(pad)	(GST_PAD_CAST(pad)->padtemplate)
</MACRO>
<MACRO>
<NAME>GST_PAD_DIRECTION</NAME>
#define GST_PAD_DIRECTION(pad)		(GST_PAD_CAST(pad)->direction)
</MACRO>
<MACRO>
<NAME>GST_PAD_TASK</NAME>
#define GST_PAD_TASK(pad)		(GST_PAD_CAST(pad)->task)
</MACRO>
<MACRO>
<NAME>GST_PAD_MODE</NAME>
#define GST_PAD_MODE(pad)	        (GST_PAD_CAST(pad)->mode)
</MACRO>
<MACRO>
<NAME>GST_PAD_ACTIVATEFUNC</NAME>
#define GST_PAD_ACTIVATEFUNC(pad)	(GST_PAD_CAST(pad)->activatefunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_ACTIVATEMODEFUNC</NAME>
#define GST_PAD_ACTIVATEMODEFUNC(pad)	(GST_PAD_CAST(pad)->activatemodefunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_CHAINFUNC</NAME>
#define GST_PAD_CHAINFUNC(pad)		(GST_PAD_CAST(pad)->chainfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_CHAINLISTFUNC</NAME>
#define GST_PAD_CHAINLISTFUNC(pad)      (GST_PAD_CAST(pad)->chainlistfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_GETRANGEFUNC</NAME>
#define GST_PAD_GETRANGEFUNC(pad)	(GST_PAD_CAST(pad)->getrangefunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_EVENTFUNC</NAME>
#define GST_PAD_EVENTFUNC(pad)		(GST_PAD_CAST(pad)->eventfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_QUERYFUNC</NAME>
#define GST_PAD_QUERYFUNC(pad)		(GST_PAD_CAST(pad)->queryfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_ITERINTLINKFUNC</NAME>
#define GST_PAD_ITERINTLINKFUNC(pad)    (GST_PAD_CAST(pad)->iterintlinkfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_PEER</NAME>
#define GST_PAD_PEER(pad)		(GST_PAD_CAST(pad)->peer)
</MACRO>
<MACRO>
<NAME>GST_PAD_LINKFUNC</NAME>
#define GST_PAD_LINKFUNC(pad)		(GST_PAD_CAST(pad)->linkfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_UNLINKFUNC</NAME>
#define GST_PAD_UNLINKFUNC(pad)		(GST_PAD_CAST(pad)->unlinkfunc)
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_SRC</NAME>
#define GST_PAD_IS_SRC(pad)		(GST_PAD_DIRECTION(pad) == GST_PAD_SRC)
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_SINK</NAME>
#define GST_PAD_IS_SINK(pad)		(GST_PAD_DIRECTION(pad) == GST_PAD_SINK)
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_LINKED</NAME>
#define GST_PAD_IS_LINKED(pad)		(GST_PAD_PEER(pad) != NULL)
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_ACTIVE</NAME>
#define GST_PAD_IS_ACTIVE(pad)          (GST_PAD_MODE(pad) != GST_PAD_MODE_NONE)
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_BLOCKED</NAME>
#define GST_PAD_IS_BLOCKED(pad)		(GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_BLOCKED))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_BLOCKING</NAME>
#define GST_PAD_IS_BLOCKING(pad)	(GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_BLOCKING))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_FLUSHING</NAME>
#define GST_PAD_IS_FLUSHING(pad)	(GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_FLUSHING))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_FLUSHING</NAME>
#define GST_PAD_SET_FLUSHING(pad)	(GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_FLUSHING))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_FLUSHING</NAME>
#define GST_PAD_UNSET_FLUSHING(pad)	(GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_FLUSHING))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_EOS</NAME>
#define GST_PAD_IS_EOS(pad)	        (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_EOS))
</MACRO>
<MACRO>
<NAME>GST_PAD_NEEDS_RECONFIGURE</NAME>
#define GST_PAD_NEEDS_RECONFIGURE(pad)  (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE))
</MACRO>
<MACRO>
<NAME>GST_PAD_HAS_PENDING_EVENTS</NAME>
#define GST_PAD_HAS_PENDING_EVENTS(pad) (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_PENDING_EVENTS))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_FIXED_CAPS</NAME>
#define GST_PAD_IS_FIXED_CAPS(pad)	(GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_FIXED_CAPS))
</MACRO>
<MACRO>
<NAME>GST_PAD_NEEDS_PARENT</NAME>
#define GST_PAD_NEEDS_PARENT(pad)       (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_NEED_PARENT))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_PROXY_CAPS</NAME>
#define GST_PAD_IS_PROXY_CAPS(pad)      (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_PROXY_CAPS))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_PROXY_CAPS</NAME>
#define GST_PAD_SET_PROXY_CAPS(pad)     (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PROXY_CAPS))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_PROXY_CAPS</NAME>
#define GST_PAD_UNSET_PROXY_CAPS(pad)   (GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PROXY_CAPS))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_PROXY_ALLOCATION</NAME>
#define GST_PAD_IS_PROXY_ALLOCATION(pad)    (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_PROXY_ALLOCATION))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_PROXY_ALLOCATION</NAME>
#define GST_PAD_SET_PROXY_ALLOCATION(pad)   (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PROXY_ALLOCATION))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_PROXY_ALLOCATION</NAME>
#define GST_PAD_UNSET_PROXY_ALLOCATION(pad) (GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PROXY_ALLOCATION))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_PROXY_SCHEDULING</NAME>
#define GST_PAD_IS_PROXY_SCHEDULING(pad)    (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_PROXY_SCHEDULING))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_PROXY_SCHEDULING</NAME>
#define GST_PAD_SET_PROXY_SCHEDULING(pad)   (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PROXY_SCHEDULING))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_PROXY_SCHEDULING</NAME>
#define GST_PAD_UNSET_PROXY_SCHEDULING(pad) (GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PROXY_SCHEDULING))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_ACCEPT_INTERSECT</NAME>
#define GST_PAD_IS_ACCEPT_INTERSECT(pad)    (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_ACCEPT_INTERSECT))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_ACCEPT_INTERSECT</NAME>
#define GST_PAD_SET_ACCEPT_INTERSECT(pad)   (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_ACCEPT_INTERSECT))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_ACCEPT_INTERSECT</NAME>
#define GST_PAD_UNSET_ACCEPT_INTERSECT(pad) (GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_ACCEPT_INTERSECT))
</MACRO>
<MACRO>
<NAME>GST_PAD_IS_ACCEPT_TEMPLATE</NAME>
#define GST_PAD_IS_ACCEPT_TEMPLATE(pad)    (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_ACCEPT_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GST_PAD_SET_ACCEPT_TEMPLATE</NAME>
#define GST_PAD_SET_ACCEPT_TEMPLATE(pad)   (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_ACCEPT_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GST_PAD_UNSET_ACCEPT_TEMPLATE</NAME>
#define GST_PAD_UNSET_ACCEPT_TEMPLATE(pad) (GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_ACCEPT_TEMPLATE))
</MACRO>
<MACRO>
<NAME>GST_PAD_GET_STREAM_LOCK</NAME>
#define GST_PAD_GET_STREAM_LOCK(pad)    (&(GST_PAD_CAST(pad)->stream_rec_lock))
</MACRO>
<MACRO>
<NAME>GST_PAD_STREAM_LOCK</NAME>
#define GST_PAD_STREAM_LOCK(pad)        g_rec_mutex_lock(GST_PAD_GET_STREAM_LOCK(pad))
</MACRO>
<MACRO>
<NAME>GST_PAD_STREAM_TRYLOCK</NAME>
#define GST_PAD_STREAM_TRYLOCK(pad)     g_rec_mutex_trylock(GST_PAD_GET_STREAM_LOCK(pad))
</MACRO>
<MACRO>
<NAME>GST_PAD_STREAM_UNLOCK</NAME>
#define GST_PAD_STREAM_UNLOCK(pad)      g_rec_mutex_unlock(GST_PAD_GET_STREAM_LOCK(pad))
</MACRO>
<MACRO>
<NAME>GST_PAD_LAST_FLOW_RETURN</NAME>
#define GST_PAD_LAST_FLOW_RETURN(pad)   (GST_PAD_CAST(pad)->ABI.abi.last_flowret)
</MACRO>
<MACRO>
<NAME>GST_PAD_BLOCK_GET_COND</NAME>
#define GST_PAD_BLOCK_GET_COND(pad)     (&GST_PAD_CAST(pad)->block_cond)
</MACRO>
<MACRO>
<NAME>GST_PAD_BLOCK_WAIT</NAME>
#define GST_PAD_BLOCK_WAIT(pad)         (g_cond_wait(GST_PAD_BLOCK_GET_COND (pad), GST_OBJECT_GET_LOCK (pad)))
</MACRO>
<MACRO>
<NAME>GST_PAD_BLOCK_SIGNAL</NAME>
#define GST_PAD_BLOCK_SIGNAL(pad)       (g_cond_signal(GST_PAD_BLOCK_GET_COND (pad)))
</MACRO>
<MACRO>
<NAME>GST_PAD_BLOCK_BROADCAST</NAME>
#define GST_PAD_BLOCK_BROADCAST(pad)    (g_cond_broadcast(GST_PAD_BLOCK_GET_COND (pad)))
</MACRO>
<FUNCTION>
<NAME>gst_pad_get_type</NAME>
<RETURNS>GType 			</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_new</NAME>
<RETURNS>GstPad *			</RETURNS>
const gchar *name, GstPadDirection direction
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_new_from_template</NAME>
<RETURNS>GstPad *			</RETURNS>
GstPadTemplate *templ, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_new_from_static_template</NAME>
<RETURNS>GstPad *			</RETURNS>
GstStaticPadTemplate *templ, const gchar *name
</FUNCTION>
<MACRO>
<NAME>gst_pad_get_name</NAME>
#define gst_pad_get_name(pad) gst_object_get_name (GST_OBJECT_CAST (pad))
</MACRO>
<MACRO>
<NAME>gst_pad_get_parent</NAME>
#define gst_pad_get_parent(pad) gst_object_get_parent (GST_OBJECT_CAST (pad))
</MACRO>
<FUNCTION>
<NAME>gst_pad_get_direction</NAME>
<RETURNS>GstPadDirection 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_active</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_is_active</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_activate_mode</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstPadMode mode, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_add_probe</NAME>
<RETURNS>gulong                   </RETURNS>
GstPad *pad, GstPadProbeType mask, GstPadProbeCallback callback, gpointer user_data, GDestroyNotify destroy_data
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_remove_probe</NAME>
<RETURNS>void                     </RETURNS>
GstPad *pad, gulong id
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_is_blocked</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_is_blocking</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_mark_reconfigure</NAME>
<RETURNS>void                     </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_needs_reconfigure</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_check_reconfigure</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_element_private</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, gpointer priv
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_element_private</NAME>
<RETURNS>gpointer 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_pad_template</NAME>
<RETURNS>GstPadTemplate *		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_store_sticky_event</NAME>
<RETURNS>GstFlowReturn            </RETURNS>
GstPad *pad, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_sticky_event</NAME>
<RETURNS>GstEvent *               </RETURNS>
GstPad *pad, GstEventType event_type, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_sticky_events_foreach</NAME>
<RETURNS>void                     </RETURNS>
GstPad *pad, GstPadStickyEventsForeachFunction foreach_func, gpointer user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_activate_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadActivateFunction activate, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_activatemode_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadActivateModeFunction activatemode, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_chain_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadChainFunction chain, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_chain_list_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadChainListFunction chainlist, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_getrange_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadGetRangeFunction get, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_event_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadEventFunction event, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<MACRO>
<NAME>gst_pad_set_activate_function</NAME>
#define gst_pad_set_activate_function(p,f)      gst_pad_set_activate_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_activatemode_function</NAME>
#define gst_pad_set_activatemode_function(p,f)  gst_pad_set_activatemode_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_chain_function</NAME>
#define gst_pad_set_chain_function(p,f)         gst_pad_set_chain_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_chain_list_function</NAME>
#define gst_pad_set_chain_list_function(p,f)    gst_pad_set_chain_list_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_getrange_function</NAME>
#define gst_pad_set_getrange_function(p,f)      gst_pad_set_getrange_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_event_function</NAME>
#define gst_pad_set_event_function(p,f)         gst_pad_set_event_function_full((p),(f),NULL,NULL)
</MACRO>
<FUNCTION>
<NAME>gst_pad_set_link_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadLinkFunction link, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_unlink_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadUnlinkFunction unlink, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<MACRO>
<NAME>gst_pad_set_link_function</NAME>
#define gst_pad_set_link_function(p,f)          gst_pad_set_link_function_full((p),(f),NULL,NULL)
</MACRO>
<MACRO>
<NAME>gst_pad_set_unlink_function</NAME>
#define gst_pad_set_unlink_function(p,f)        gst_pad_set_unlink_function_full((p),(f),NULL,NULL)
</MACRO>
<FUNCTION>
<NAME>gst_pad_can_link</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPad *srcpad, GstPad *sinkpad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_link</NAME>
<RETURNS>GstPadLinkReturn         </RETURNS>
GstPad *srcpad, GstPad *sinkpad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_link_full</NAME>
<RETURNS>GstPadLinkReturn         </RETURNS>
GstPad *srcpad, GstPad *sinkpad, GstPadLinkCheck flags
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_unlink</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *srcpad, GstPad *sinkpad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_is_linked</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_peer</NAME>
<RETURNS>GstPad *			</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_pad_template_caps</NAME>
<RETURNS>GstCaps *                </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_current_caps</NAME>
<RETURNS>GstCaps  *		</RETURNS>
GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_has_current_caps</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_allowed_caps</NAME>
<RETURNS>GstCaps  *		</RETURNS>
GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_offset</NAME>
<RETURNS>gint64                   </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_offset</NAME>
<RETURNS>void                     </RETURNS>
GstPad *pad, gint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_push</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_push_list</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, GstBufferList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_pull_range</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, guint64 offset, guint size, GstBuffer **buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_push_event</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_event_default</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstObject *parent, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_last_flow_return</NAME>
<RETURNS>GstFlowReturn            </RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_chain</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_chain_list</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, GstBufferList *list
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_get_range</NAME>
<RETURNS>GstFlowReturn 		</RETURNS>
GstPad *pad, guint64 offset, guint size, GstBuffer **buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_send_event</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_start_task</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstTaskFunction func, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_pause_task</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_stop_task</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_iterate_internal_links_function_full</NAME>
<RETURNS>void                     </RETURNS>
GstPad * pad, GstPadIterIntLinkFunction iterintlink, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_iterate_internal_links</NAME>
<RETURNS>GstIterator  *           </RETURNS>
GstPad * pad
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_iterate_internal_links_default</NAME>
<RETURNS>GstIterator  *           </RETURNS>
GstPad * pad, GstObject *parent
</FUNCTION>
<MACRO>
<NAME>gst_pad_set_iterate_internal_links_function</NAME>
#define gst_pad_set_iterate_internal_links_function(p,f) gst_pad_set_iterate_internal_links_function_full((p),(f),NULL,NULL)
</MACRO>
<FUNCTION>
<NAME>gst_pad_query</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_peer_query</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_set_query_function_full</NAME>
<RETURNS>void 			</RETURNS>
GstPad *pad, GstPadQueryFunction query, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_pad_query_default</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstObject *parent, GstQuery *query
</FUNCTION>
<MACRO>
<NAME>gst_pad_set_query_function</NAME>
#define gst_pad_set_query_function(p,f)   gst_pad_set_query_function_full((p),(f),NULL,NULL)
</MACRO>
<FUNCTION>
<NAME>gst_pad_forward</NAME>
<RETURNS>gboolean 		</RETURNS>
GstPad *pad, GstPadForwardFunction forward, gpointer user_data
</FUNCTION>
<STRUCT>
<NAME>GstPadPrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GstState</NAME>
typedef enum {
  GST_STATE_VOID_PENDING        = 0,
  GST_STATE_NULL                = 1,
  GST_STATE_READY               = 2,
  GST_STATE_PAUSED              = 3,
  GST_STATE_PLAYING             = 4
} GstState;
</ENUM>
<MACRO>
<NAME>GST_TYPE_ELEMENT</NAME>
#define GST_TYPE_ELEMENT                (gst_element_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_ELEMENT</NAME>
#define GST_IS_ELEMENT(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_IS_ELEMENT_CLASS</NAME>
#define GST_IS_ELEMENT_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_ELEMENT))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_GET_CLASS</NAME>
#define GST_ELEMENT_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_ELEMENT, GstElementClass))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT</NAME>
#define GST_ELEMENT(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_ELEMENT, GstElement))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_CLASS</NAME>
#define GST_ELEMENT_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_ELEMENT, GstElementClass))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_CAST</NAME>
#define GST_ELEMENT_CAST(obj)           ((GstElement*)(obj))
</MACRO>
<ENUM>
<NAME>GstStateChangeReturn</NAME>
typedef enum {
  GST_STATE_CHANGE_FAILURE             = 0,
  GST_STATE_CHANGE_SUCCESS             = 1,
  GST_STATE_CHANGE_ASYNC               = 2,
  GST_STATE_CHANGE_NO_PREROLL          = 3
} GstStateChangeReturn;
</ENUM>
<MACRO>
<NAME>GST_STATE</NAME>
#define GST_STATE(elem)                 (GST_ELEMENT_CAST(elem)->current_state)
</MACRO>
<MACRO>
<NAME>GST_STATE_NEXT</NAME>
#define GST_STATE_NEXT(elem)            (GST_ELEMENT_CAST(elem)->next_state)
</MACRO>
<MACRO>
<NAME>GST_STATE_PENDING</NAME>
#define GST_STATE_PENDING(elem)         (GST_ELEMENT_CAST(elem)->pending_state)
</MACRO>
<MACRO>
<NAME>GST_STATE_TARGET</NAME>
#define GST_STATE_TARGET(elem)          (GST_ELEMENT_CAST(elem)->target_state)
</MACRO>
<MACRO>
<NAME>GST_STATE_RETURN</NAME>
#define GST_STATE_RETURN(elem)          (GST_ELEMENT_CAST(elem)->last_return)
</MACRO>
<MACRO>
<NAME>GST_STATE_GET_NEXT</NAME>
#define GST_STATE_GET_NEXT(cur,pending)         ((GstState)((cur) + __GST_SIGN ((gint)(pending) - (gint)(cur))))
</MACRO>
<MACRO>
<NAME>GST_STATE_TRANSITION</NAME>
#define GST_STATE_TRANSITION(cur,next)          ((GstStateChange)(((cur)<<3)|(next)))
</MACRO>
<MACRO>
<NAME>GST_STATE_TRANSITION_CURRENT</NAME>
#define GST_STATE_TRANSITION_CURRENT(trans)     ((GstState)((trans)>>3))
</MACRO>
<MACRO>
<NAME>GST_STATE_TRANSITION_NEXT</NAME>
#define GST_STATE_TRANSITION_NEXT(trans)        ((GstState)((trans)&0x7))
</MACRO>
<ENUM>
<NAME>GstStateChange</NAME>
typedef enum /*< flags=0 >*/
{
  GST_STATE_CHANGE_NULL_TO_READY        = (GST_STATE_NULL<<3) | GST_STATE_READY,
  GST_STATE_CHANGE_READY_TO_PAUSED      = (GST_STATE_READY<<3) | GST_STATE_PAUSED,
  GST_STATE_CHANGE_PAUSED_TO_PLAYING    = (GST_STATE_PAUSED<<3) | GST_STATE_PLAYING,
  GST_STATE_CHANGE_PLAYING_TO_PAUSED    = (GST_STATE_PLAYING<<3) | GST_STATE_PAUSED,
  GST_STATE_CHANGE_PAUSED_TO_READY      = (GST_STATE_PAUSED<<3) | GST_STATE_READY,
  GST_STATE_CHANGE_READY_TO_NULL        = (GST_STATE_READY<<3) | GST_STATE_NULL
} GstStateChange;
</ENUM>
<ENUM>
<NAME>GstElementFlags</NAME>
typedef enum
{
  GST_ELEMENT_FLAG_LOCKED_STATE   = (GST_OBJECT_FLAG_LAST << 0),
  GST_ELEMENT_FLAG_SINK           = (GST_OBJECT_FLAG_LAST << 1),
  GST_ELEMENT_FLAG_SOURCE         = (GST_OBJECT_FLAG_LAST << 2),
  GST_ELEMENT_FLAG_PROVIDE_CLOCK  = (GST_OBJECT_FLAG_LAST << 3),
  GST_ELEMENT_FLAG_REQUIRE_CLOCK  = (GST_OBJECT_FLAG_LAST << 4),
  GST_ELEMENT_FLAG_INDEXABLE      = (GST_OBJECT_FLAG_LAST << 5),
  /* padding */
  GST_ELEMENT_FLAG_LAST           = (GST_OBJECT_FLAG_LAST << 10)
} GstElementFlags;
</ENUM>
<MACRO>
<NAME>GST_ELEMENT_IS_LOCKED_STATE</NAME>
#define GST_ELEMENT_IS_LOCKED_STATE(elem)        (GST_OBJECT_FLAG_IS_SET(elem,GST_ELEMENT_FLAG_LOCKED_STATE))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_NAME</NAME>
#define GST_ELEMENT_NAME(elem)                  (GST_OBJECT_NAME(elem))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_PARENT</NAME>
#define GST_ELEMENT_PARENT(elem)                (GST_ELEMENT_CAST(GST_OBJECT_PARENT(elem)))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_BUS</NAME>
#define GST_ELEMENT_BUS(elem)                   (GST_ELEMENT_CAST(elem)->bus)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_CLOCK</NAME>
#define GST_ELEMENT_CLOCK(elem)                 (GST_ELEMENT_CAST(elem)->clock)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_PADS</NAME>
#define GST_ELEMENT_PADS(elem)                  (GST_ELEMENT_CAST(elem)->pads)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_START_TIME</NAME>
#define GST_ELEMENT_START_TIME(elem)            (GST_ELEMENT_CAST(elem)->start_time)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_ERROR</NAME>
#define GST_ELEMENT_ERROR(el, domain, code, text, debug)                \
G_STMT_START {                                                          \
  gchar *__txt = _gst_element_error_printf text;                        \
  gchar *__dbg = _gst_element_error_printf debug;                       \
  if (__txt)                                                            \
    GST_WARNING_OBJECT (el, "error: %s", __txt);                        \
  if (__dbg)                                                            \
    GST_WARNING_OBJECT (el, "error: %s", __dbg);                        \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_ERROR,         \
    GST_ ## domain ## _ERROR, GST_ ## domain ## _ERROR_ ## code,        \
    __txt, __dbg, __FILE__, GST_FUNCTION, __LINE__);                    \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_WARNING</NAME>
#define GST_ELEMENT_WARNING(el, domain, code, text, debug)              \
G_STMT_START {                                                          \
  gchar *__txt = _gst_element_error_printf text;                        \
  gchar *__dbg = _gst_element_error_printf debug;                       \
  if (__txt)                                                            \
    GST_WARNING_OBJECT (el, "warning: %s", __txt);                      \
  if (__dbg)                                                            \
    GST_WARNING_OBJECT (el, "warning: %s", __dbg);                      \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_WARNING,       \
    GST_ ## domain ## _ERROR, GST_ ## domain ## _ERROR_ ## code,        \
  __txt, __dbg, __FILE__, GST_FUNCTION, __LINE__);                      \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_INFO</NAME>
#define GST_ELEMENT_INFO(el, domain, code, text, debug)                 \
G_STMT_START {                                                          \
  gchar *__txt = _gst_element_error_printf text;                        \
  gchar *__dbg = _gst_element_error_printf debug;                       \
  if (__txt)                                                            \
    GST_INFO_OBJECT (el, "info: %s", __txt);                            \
  if (__dbg)                                                            \
    GST_INFO_OBJECT (el, "info: %s", __dbg);                            \
  gst_element_message_full (GST_ELEMENT(el), GST_MESSAGE_INFO,          \
    GST_ ## domain ## _ERROR, GST_ ## domain ## _ERROR_ ## code,        \
  __txt, __dbg, __FILE__, GST_FUNCTION, __LINE__);                      \
} G_STMT_END
</MACRO>
<MACRO>
<NAME>GST_STATE_GET_LOCK</NAME>
#define GST_STATE_GET_LOCK(elem)               (&(GST_ELEMENT_CAST(elem)->state_lock))
</MACRO>
<MACRO>
<NAME>GST_STATE_GET_COND</NAME>
#define GST_STATE_GET_COND(elem)               (&GST_ELEMENT_CAST(elem)->state_cond)
</MACRO>
<MACRO>
<NAME>GST_STATE_LOCK</NAME>
#define GST_STATE_LOCK(elem)                   g_rec_mutex_lock(GST_STATE_GET_LOCK(elem))
</MACRO>
<MACRO>
<NAME>GST_STATE_TRYLOCK</NAME>
#define GST_STATE_TRYLOCK(elem)                g_rec_mutex_trylock(GST_STATE_GET_LOCK(elem))
</MACRO>
<MACRO>
<NAME>GST_STATE_UNLOCK</NAME>
#define GST_STATE_UNLOCK(elem)                 g_rec_mutex_unlock(GST_STATE_GET_LOCK(elem))
</MACRO>
<MACRO>
<NAME>GST_STATE_UNLOCK_FULL</NAME>
#define GST_STATE_UNLOCK_FULL(elem)            g_rec_mutex_unlock_full(GST_STATE_GET_LOCK(elem))
</MACRO>
<MACRO>
<NAME>GST_STATE_LOCK_FULL</NAME>
#define GST_STATE_LOCK_FULL(elem,t)            g_rec_mutex_lock_full(GST_STATE_GET_LOCK(elem), t)
</MACRO>
<MACRO>
<NAME>GST_STATE_WAIT</NAME>
#define GST_STATE_WAIT(elem)                   g_cond_wait (GST_STATE_GET_COND (elem), \
                                                        GST_OBJECT_GET_LOCK (elem))
</MACRO>
<MACRO>
<NAME>GST_STATE_WAIT_UNTIL</NAME>
#define GST_STATE_WAIT_UNTIL(elem, end_time)   g_cond_wait_until (GST_STATE_GET_COND (elem), \
                                                        GST_OBJECT_GET_LOCK (elem), end_time)
</MACRO>
<MACRO>
<NAME>GST_STATE_SIGNAL</NAME>
#define GST_STATE_SIGNAL(elem)                 g_cond_signal (GST_STATE_GET_COND (elem));
</MACRO>
<MACRO>
<NAME>GST_STATE_BROADCAST</NAME>
#define GST_STATE_BROADCAST(elem)              g_cond_broadcast (GST_STATE_GET_COND (elem));
</MACRO>
<STRUCT>
<NAME>GstElement</NAME>
struct _GstElement
{
  GstObject             object;

  /*< public >*/ /* with LOCK */
  GRecMutex             state_lock;

  /* element state */
  GCond                 state_cond;
  guint32               state_cookie;
  GstState              target_state;
  GstState              current_state;
  GstState              next_state;
  GstState              pending_state;
  GstStateChangeReturn  last_return;

  GstBus               *bus;

  /* allocated clock */
  GstClock             *clock;
  GstClockTimeDiff      base_time; /* NULL/READY: 0 - PAUSED: current time - PLAYING: difference to clock */
  GstClockTime          start_time;

  /* element pads, these lists can only be iterated while holding
   * the LOCK or checking the cookie after each LOCK. */
  guint16               numpads;
  GList                *pads;
  guint16               numsrcpads;
  GList                *srcpads;
  guint16               numsinkpads;
  GList                *sinkpads;
  guint32               pads_cookie;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstElementClass</NAME>
struct _GstElementClass
{
  GstObjectClass         parent_class;

  /*< public >*/
  /* the element metadata */
  gpointer		 metadata;

  /* factory that the element was created from */
  GstElementFactory     *elementfactory;

  /* templates for our pads */
  GList                 *padtemplates;
  gint                   numpadtemplates;
  guint32                pad_templ_cookie;

  /*< private >*/
  /* signal callbacks */
  void (*pad_added)     (GstElement *element, GstPad *pad);
  void (*pad_removed)   (GstElement *element, GstPad *pad);
  void (*no_more_pads)  (GstElement *element);

  /*< public >*/
  /* virtual methods for subclasses */

  /* request/release pads */
  /* FIXME 2.0 harmonize naming with gst_element_request_pad */
  GstPad*               (*request_new_pad)      (GstElement *element, GstPadTemplate *templ,
                                                 const gchar* name, const GstCaps *caps);

  void                  (*release_pad)          (GstElement *element, GstPad *pad);

  /* state changes */
  GstStateChangeReturn (*get_state)             (GstElement * element, GstState * state,
                                                 GstState * pending, GstClockTime timeout);
  GstStateChangeReturn (*set_state)             (GstElement *element, GstState state);
  GstStateChangeReturn (*change_state)          (GstElement *element, GstStateChange transition);
  void                 (*state_changed)         (GstElement *element, GstState oldstate,
                                                 GstState newstate, GstState pending);

  /* bus */
  void                  (*set_bus)              (GstElement * element, GstBus * bus);

  /* set/get clocks */
  GstClock*             (*provide_clock)        (GstElement *element);
  gboolean              (*set_clock)            (GstElement *element, GstClock *clock);

  /* query functions */
  gboolean              (*send_event)           (GstElement *element, GstEvent *event);

  gboolean              (*query)                (GstElement *element, GstQuery *query);

  gboolean              (*post_message)         (GstElement *element, GstMessage *message);

  void                  (*set_context)          (GstElement *element, GstContext *context);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING_LARGE-2];
};
</STRUCT>
<FUNCTION>
<NAME>gst_element_class_add_pad_template</NAME>
<RETURNS>void                     </RETURNS>
GstElementClass *klass, GstPadTemplate *templ
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_get_pad_template</NAME>
<RETURNS>GstPadTemplate *         </RETURNS>
GstElementClass *element_class, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_get_pad_template_list</NAME>
<RETURNS>GList *                  </RETURNS>
GstElementClass *element_class
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_set_metadata</NAME>
<RETURNS>void                     </RETURNS>
GstElementClass *klass, const gchar     *longname, const gchar     *classification, const gchar     *description, const gchar     *author
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_set_static_metadata</NAME>
<RETURNS>void                     </RETURNS>
GstElementClass *klass, const gchar     *longname, const gchar     *classification, const gchar     *description, const gchar     *author
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_add_metadata</NAME>
<RETURNS>void                     </RETURNS>
GstElementClass * klass, const gchar * key, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_add_static_metadata</NAME>
<RETURNS>void                     </RETURNS>
GstElementClass * klass, const gchar * key, const gchar * value
</FUNCTION>
<FUNCTION>
<NAME>gst_element_class_get_metadata</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstElementClass * klass, const gchar * key
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>gst_element_get_name</NAME>
#define                 gst_element_get_name(elem)      gst_object_get_name(GST_OBJECT_CAST(elem))
</MACRO>
<MACRO>
<NAME>gst_element_set_name</NAME>
#define                 gst_element_set_name(elem,name) gst_object_set_name(GST_OBJECT_CAST(elem),name)
</MACRO>
<MACRO>
<NAME>gst_element_get_parent</NAME>
#define                 gst_element_get_parent(elem)    gst_object_get_parent(GST_OBJECT_CAST(elem))
</MACRO>
<MACRO>
<NAME>gst_element_set_parent</NAME>
#define                 gst_element_set_parent(elem,parent)     gst_object_set_parent(GST_OBJECT_CAST(elem),parent)
</MACRO>
<FUNCTION>
<NAME>gst_element_provide_clock</NAME>
<RETURNS>GstClock *               </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_clock</NAME>
<RETURNS>GstClock *               </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_clock</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_base_time</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_base_time</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_start_time</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element, GstClockTime time
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_start_time</NAME>
<RETURNS>GstClockTime             </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_bus</NAME>
<RETURNS>void                     </RETURNS>
GstElement * element, GstBus * bus
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_bus</NAME>
<RETURNS>GstBus  *                </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_context</NAME>
<RETURNS>void                     </RETURNS>
GstElement * element, GstContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_element_add_pad</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_element_remove_pad</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_element_no_more_pads</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_static_pad</NAME>
<RETURNS>GstPad *                 </RETURNS>
GstElement *element, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_request_pad</NAME>
<RETURNS>GstPad *                 </RETURNS>
GstElement *element, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_request_pad</NAME>
<RETURNS>GstPad *                 </RETURNS>
GstElement *element, GstPadTemplate *templ, const gchar * name, const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_element_release_request_pad</NAME>
<RETURNS>void                     </RETURNS>
GstElement *element, GstPad *pad
</FUNCTION>
<FUNCTION>
<NAME>gst_element_iterate_pads</NAME>
<RETURNS>GstIterator  *           </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_iterate_src_pads</NAME>
<RETURNS>GstIterator  *           </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_iterate_sink_pads</NAME>
<RETURNS>GstIterator  *           </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_send_event</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_element_seek</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, gdouble rate, GstFormat format, GstSeekFlags flags, GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop
</FUNCTION>
<FUNCTION>
<NAME>gst_element_query</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_element_post_message</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement * element, GstMessage * message
</FUNCTION>
<FUNCTION>
<NAME>gst_element_message_full</NAME>
<RETURNS>void                     </RETURNS>
GstElement * element, GstMessageType type, GQuark domain, gint code, gchar * text, gchar * debug, const gchar * file, const gchar * function, gint line
</FUNCTION>
<FUNCTION>
<NAME>gst_element_is_locked_state</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_locked_state</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element, gboolean locked_state
</FUNCTION>
<FUNCTION>
<NAME>gst_element_sync_state_with_parent</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_state</NAME>
<RETURNS>GstStateChangeReturn     </RETURNS>
GstElement * element, GstState * state, GstState * pending, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_element_set_state</NAME>
<RETURNS>GstStateChangeReturn     </RETURNS>
GstElement *element, GstState state
</FUNCTION>
<FUNCTION>
<NAME>gst_element_abort_state</NAME>
<RETURNS>void                     </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_change_state</NAME>
<RETURNS>GstStateChangeReturn     </RETURNS>
GstElement * element, GstStateChange transition
</FUNCTION>
<FUNCTION>
<NAME>gst_element_continue_state</NAME>
<RETURNS>GstStateChangeReturn     </RETURNS>
GstElement * element, GstStateChangeReturn ret
</FUNCTION>
<FUNCTION>
<NAME>gst_element_lost_state</NAME>
<RETURNS>void                     </RETURNS>
GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_element_get_factory</NAME>
<RETURNS>GstElementFactory *      </RETURNS>
GstElement *element
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_DEVICE_MONITOR</NAME>
#define GST_TYPE_DEVICE_MONITOR                 (gst_device_monitor_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_MONITOR</NAME>
#define GST_IS_DEVICE_MONITOR(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DEVICE_MONITOR))
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_MONITOR_CLASS</NAME>
#define GST_IS_DEVICE_MONITOR_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DEVICE_MONITOR))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_MONITOR_GET_CLASS</NAME>
#define GST_DEVICE_MONITOR_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_MONITOR</NAME>
#define GST_DEVICE_MONITOR(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DEVICE_MONITOR, GstDeviceMonitor))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_MONITOR_CLASS</NAME>
#define GST_DEVICE_MONITOR_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE_MONITOR, GstDeviceMonitorClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_MONITOR_CAST</NAME>
#define GST_DEVICE_MONITOR_CAST(obj)            ((GstDeviceMonitor *)(obj))
</MACRO>
<STRUCT>
<NAME>GstDeviceMonitor</NAME>
struct _GstDeviceMonitor {
  GstObject                parent;

  /*< private >*/

  GstDeviceMonitorPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstDeviceMonitorClass</NAME>
struct _GstDeviceMonitorClass {
  GstObjectClass           parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_device_monitor_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_new</NAME>
<RETURNS>GstDeviceMonitor  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_get_bus</NAME>
<RETURNS>GstBus  *  </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_get_devices</NAME>
<RETURNS>GList  *   </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_start</NAME>
<RETURNS>gboolean   </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_stop</NAME>
<RETURNS>void       </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_add_filter</NAME>
<RETURNS>guint      </RETURNS>
GstDeviceMonitor * monitor, const gchar      * classes, GstCaps          * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_remove_filter</NAME>
<RETURNS>gboolean   </RETURNS>
GstDeviceMonitor * monitor, guint filter_id
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_get_providers</NAME>
<RETURNS>gchar  **  </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_set_show_all_devices</NAME>
<RETURNS>void       </RETURNS>
GstDeviceMonitor * monitor, gboolean show_all
</FUNCTION>
<FUNCTION>
<NAME>gst_device_monitor_get_show_all_devices</NAME>
<RETURNS>gboolean   </RETURNS>
GstDeviceMonitor * monitor
</FUNCTION>
<STRUCT>
<NAME>GstDeviceMonitorPrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GstQueryTypeFlags</NAME>
typedef enum {
  GST_QUERY_TYPE_UPSTREAM       = 1 << 0,
  GST_QUERY_TYPE_DOWNSTREAM     = 1 << 1,
  GST_QUERY_TYPE_SERIALIZED     = 1 << 2
} GstQueryTypeFlags;
</ENUM>
<MACRO>
<NAME>GST_QUERY_TYPE_BOTH</NAME>
#define GST_QUERY_TYPE_BOTH \
    (GST_QUERY_TYPE_UPSTREAM | GST_QUERY_TYPE_DOWNSTREAM)
</MACRO>
<MACRO>
<NAME>GST_QUERY_NUM_SHIFT</NAME>
#define GST_QUERY_NUM_SHIFT     (8)
</MACRO>
<MACRO>
<NAME>GST_QUERY_MAKE_TYPE</NAME>
#define GST_QUERY_MAKE_TYPE(num,flags) \
    (((num) << GST_QUERY_NUM_SHIFT) | (flags))
</MACRO>
<MACRO>
<NAME>FLAG</NAME>
#define FLAG(name) GST_QUERY_TYPE_##name
</MACRO>
<ENUM>
<NAME>GstQueryType</NAME>
typedef enum {
  GST_QUERY_UNKNOWN      = GST_QUERY_MAKE_TYPE (0, 0),
  GST_QUERY_POSITION     = GST_QUERY_MAKE_TYPE (10, FLAG(BOTH)),
  GST_QUERY_DURATION     = GST_QUERY_MAKE_TYPE (20, FLAG(BOTH)),
  GST_QUERY_LATENCY      = GST_QUERY_MAKE_TYPE (30, FLAG(BOTH)),
  GST_QUERY_JITTER       = GST_QUERY_MAKE_TYPE (40, FLAG(BOTH)),
  GST_QUERY_RATE         = GST_QUERY_MAKE_TYPE (50, FLAG(BOTH)),
  GST_QUERY_SEEKING      = GST_QUERY_MAKE_TYPE (60, FLAG(BOTH)),
  GST_QUERY_SEGMENT      = GST_QUERY_MAKE_TYPE (70, FLAG(BOTH)),
  GST_QUERY_CONVERT      = GST_QUERY_MAKE_TYPE (80, FLAG(BOTH)),
  GST_QUERY_FORMATS      = GST_QUERY_MAKE_TYPE (90, FLAG(BOTH)),
  GST_QUERY_BUFFERING    = GST_QUERY_MAKE_TYPE (110, FLAG(BOTH)),
  GST_QUERY_CUSTOM       = GST_QUERY_MAKE_TYPE (120, FLAG(BOTH)),
  GST_QUERY_URI          = GST_QUERY_MAKE_TYPE (130, FLAG(BOTH)),
  GST_QUERY_ALLOCATION   = GST_QUERY_MAKE_TYPE (140, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
  GST_QUERY_SCHEDULING   = GST_QUERY_MAKE_TYPE (150, FLAG(UPSTREAM)),
  GST_QUERY_ACCEPT_CAPS  = GST_QUERY_MAKE_TYPE (160, FLAG(BOTH)),
  GST_QUERY_CAPS         = GST_QUERY_MAKE_TYPE (170, FLAG(BOTH)),
  GST_QUERY_DRAIN        = GST_QUERY_MAKE_TYPE (180, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
  GST_QUERY_CONTEXT      = GST_QUERY_MAKE_TYPE (190, FLAG(BOTH))
} GstQueryType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_QUERY</NAME>
#define GST_TYPE_QUERY                         (_gst_query_type)
</MACRO>
<MACRO>
<NAME>GST_IS_QUERY</NAME>
#define GST_IS_QUERY(obj)                      (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_QUERY))
</MACRO>
<MACRO>
<NAME>GST_QUERY_CAST</NAME>
#define GST_QUERY_CAST(obj)                    ((GstQuery*)(obj))
</MACRO>
<MACRO>
<NAME>GST_QUERY</NAME>
#define GST_QUERY(obj)                         (GST_QUERY_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_QUERY_TYPE</NAME>
#define GST_QUERY_TYPE(query)  (((GstQuery*)(query))->type)
</MACRO>
<MACRO>
<NAME>GST_QUERY_TYPE_NAME</NAME>
#define GST_QUERY_TYPE_NAME(query) (gst_query_type_get_name(GST_QUERY_TYPE(query)))
</MACRO>
<MACRO>
<NAME>GST_QUERY_IS_UPSTREAM</NAME>
#define GST_QUERY_IS_UPSTREAM(ev)       !!(GST_QUERY_TYPE (ev) & GST_QUERY_TYPE_UPSTREAM)
</MACRO>
<MACRO>
<NAME>GST_QUERY_IS_DOWNSTREAM</NAME>
#define GST_QUERY_IS_DOWNSTREAM(ev)     !!(GST_QUERY_TYPE (ev) & GST_QUERY_TYPE_DOWNSTREAM)
</MACRO>
<MACRO>
<NAME>GST_QUERY_IS_SERIALIZED</NAME>
#define GST_QUERY_IS_SERIALIZED(ev)     !!(GST_QUERY_TYPE (ev) & GST_QUERY_TYPE_SERIALIZED)
</MACRO>
<STRUCT>
<NAME>GstQuery</NAME>
struct _GstQuery
{
  GstMiniObject mini_object;

  /*< public > *//* with COW */
  GstQueryType type;
};
</STRUCT>
<FUNCTION>
<NAME>gst_query_type_get_name</NAME>
<RETURNS>const gchar *    </RETURNS>
GstQueryType type
</FUNCTION>
<FUNCTION>
<NAME>gst_query_type_to_quark</NAME>
<RETURNS>GQuark           </RETURNS>
GstQueryType type
</FUNCTION>
<FUNCTION>
<NAME>gst_query_type_get_flags</NAME>
<RETURNS>GstQueryTypeFlags </RETURNS>
GstQueryType type
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_ref</NAME>
<RETURNS>GstQuery  * </RETURNS>
GstQuery * q
</FUNCTION>
<FUNCTION>
<NAME>gst_query_unref</NAME>
<RETURNS>void  </RETURNS>
GstQuery * q
</FUNCTION>
<FUNCTION>
<NAME>gst_query_copy</NAME>
<RETURNS>GstQuery  * </RETURNS>
const GstQuery * q
</FUNCTION>
<MACRO>
<NAME>gst_query_is_writable</NAME>
#define         gst_query_is_writable(q)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (q))
</MACRO>
<MACRO>
<NAME>gst_query_make_writable</NAME>
#define         gst_query_make_writable(q)      GST_QUERY_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (q)))
</MACRO>
<FUNCTION>
<NAME>gst_query_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstQuery **old_query, GstQuery *new_query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_custom</NAME>
<RETURNS>GstQuery  *      </RETURNS>
GstQueryType type, GstStructure *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_structure</NAME>
<RETURNS>const GstStructure  *</RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_writable_structure</NAME>
<RETURNS>GstStructure  *  </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_position</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_position</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat format, gint64 cur
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_position</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat *format, gint64 *cur
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_duration</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_duration</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat format, gint64 duration
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_duration</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat *format, gint64 *duration
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_latency</NAME>
<RETURNS>GstQuery *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_latency</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean live, GstClockTime min_latency, GstClockTime max_latency
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_latency</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean *live, GstClockTime *min_latency, GstClockTime *max_latency
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_convert</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat src_format, gint64 value, GstFormat dest_format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_convert</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat src_format, gint64 src_value, GstFormat dest_format, gint64 dest_value
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_convert</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat *src_format, gint64 *src_value, GstFormat *dest_format, gint64 *dest_value
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_segment</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_segment</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gdouble rate, GstFormat format, gint64 start_value, gint64 stop_value
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_segment</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gdouble *rate, GstFormat *format, gint64 *start_value, gint64 *stop_value
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_seeking</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_seeking</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat format, gboolean seekable, gint64 segment_start, gint64 segment_end
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_seeking</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat *format, gboolean *seekable, gint64 *segment_start, gint64 *segment_end
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_formats</NAME>
<RETURNS>GstQuery *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_formats</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gint n_formats, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_formatsv</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gint n_formats, const GstFormat *formats
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_n_formats</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint *n_formats
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_format</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint nth, GstFormat *format
</FUNCTION>
<ENUM>
<NAME>GstBufferingMode</NAME>
typedef enum {
  GST_BUFFERING_STREAM,
  GST_BUFFERING_DOWNLOAD,
  GST_BUFFERING_TIMESHIFT,
  GST_BUFFERING_LIVE
} GstBufferingMode;
</ENUM>
<FUNCTION>
<NAME>gst_query_new_buffering</NAME>
<RETURNS>GstQuery *       </RETURNS>
GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_buffering_percent</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean busy, gint percent
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_buffering_percent</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean *busy, gint *percent
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_buffering_stats</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstBufferingMode mode, gint avg_in, gint avg_out, gint64 buffering_left
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_buffering_stats</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstBufferingMode *mode, gint *avg_in, gint *avg_out, gint64 *buffering_left
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_buffering_range</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat format, gint64 start, gint64 stop, gint64 estimated_total
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_buffering_range</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstFormat *format, gint64 *start, gint64 *stop, gint64 *estimated_total
</FUNCTION>
<FUNCTION>
<NAME>gst_query_add_buffering_range</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery *query, gint64 start, gint64 stop
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_n_buffering_ranges</NAME>
<RETURNS>guint            </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_buffering_range</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery *query, guint index, gint64 *start, gint64 *stop
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_uri</NAME>
<RETURNS>GstQuery  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_uri</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gchar **uri
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_uri</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, const gchar *uri
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_uri_redirection</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gchar **uri
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_uri_redirection</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, const gchar *uri
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_uri_redirection_permanent</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean * permanent
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_uri_redirection_permanent</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean permanent
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_allocation</NAME>
<RETURNS>GstQuery  *      </RETURNS>
GstCaps *caps, gboolean need_pool
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_allocation</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstCaps **caps, gboolean *need_pool
</FUNCTION>
<FUNCTION>
<NAME>gst_query_add_allocation_pool</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstBufferPool *pool, guint size, guint min_buffers, guint max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_n_allocation_pools</NAME>
<RETURNS>guint            </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_allocation_pool</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index, GstBufferPool **pool, guint *size, guint *min_buffers, guint *max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_nth_allocation_pool</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index, GstBufferPool *pool, guint size, guint min_buffers, guint max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_query_remove_nth_allocation_pool</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_query_add_allocation_param</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstAllocator *allocator, const GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_n_allocation_params</NAME>
<RETURNS>guint            </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_allocation_param</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index, GstAllocator **allocator, GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_nth_allocation_param</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index, GstAllocator *allocator, const GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_query_remove_nth_allocation_param</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_query_add_allocation_meta</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GType api, const GstStructure *params
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_n_allocation_metas</NAME>
<RETURNS>guint            </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_allocation_meta</NAME>
<RETURNS>GType            </RETURNS>
GstQuery *query, guint index, const GstStructure **params
</FUNCTION>
<FUNCTION>
<NAME>gst_query_remove_nth_allocation_meta</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_query_find_allocation_meta</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery *query, GType api, guint *index
</FUNCTION>
<ENUM>
<NAME>GstSchedulingFlags</NAME>
typedef enum {
  GST_SCHEDULING_FLAG_SEEKABLE          = (1 << 0),
  GST_SCHEDULING_FLAG_SEQUENTIAL        = (1 << 1),
  GST_SCHEDULING_FLAG_BANDWIDTH_LIMITED = (1 << 2)
} GstSchedulingFlags;
</ENUM>
<FUNCTION>
<NAME>gst_query_new_scheduling</NAME>
<RETURNS>GstQuery  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_scheduling</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstSchedulingFlags flags, gint minsize, gint maxsize, gint align
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_scheduling</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstSchedulingFlags *flags, gint *minsize, gint *maxsize, gint *align
</FUNCTION>
<FUNCTION>
<NAME>gst_query_add_scheduling_mode</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstPadMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_query_get_n_scheduling_modes</NAME>
<RETURNS>guint            </RETURNS>
GstQuery *query
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_nth_scheduling_mode</NAME>
<RETURNS>GstPadMode       </RETURNS>
GstQuery *query, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_query_has_scheduling_mode</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery *query, GstPadMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_query_has_scheduling_mode_with_flags</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery * query, GstPadMode mode, GstSchedulingFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_accept_caps</NAME>
<RETURNS>GstQuery  *      </RETURNS>
GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_accept_caps</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstCaps **caps
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_accept_caps_result</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean result
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_accept_caps_result</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, gboolean *result
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_caps</NAME>
<RETURNS>GstQuery  *      </RETURNS>
GstCaps *filter
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_caps</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstCaps **filter
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_caps_result</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_caps_result</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstCaps **caps
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_drain</NAME>
<RETURNS>GstQuery  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_query_new_context</NAME>
<RETURNS>GstQuery  *      </RETURNS>
const gchar * context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_context_type</NAME>
<RETURNS>gboolean         </RETURNS>
GstQuery * query, const gchar ** context_type
</FUNCTION>
<FUNCTION>
<NAME>gst_query_set_context</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstContext *context
</FUNCTION>
<FUNCTION>
<NAME>gst_query_parse_context</NAME>
<RETURNS>void             </RETURNS>
GstQuery *query, GstContext **context
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CAPS</NAME>
#define GST_TYPE_CAPS             (_gst_caps_type)
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS</NAME>
#define GST_IS_CAPS(obj)          (GST_IS_MINI_OBJECT_TYPE((obj), GST_TYPE_CAPS))
</MACRO>
<MACRO>
<NAME>GST_CAPS_CAST</NAME>
#define GST_CAPS_CAST(obj)        ((GstCaps*)(obj))
</MACRO>
<MACRO>
<NAME>GST_CAPS</NAME>
#define GST_CAPS(obj)             (GST_CAPS_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_TYPE_STATIC_CAPS</NAME>
#define GST_TYPE_STATIC_CAPS      (gst_static_caps_get_type())
</MACRO>
<ENUM>
<NAME>GstCapsFlags</NAME>
typedef enum {
  GST_CAPS_FLAG_ANY	= (GST_MINI_OBJECT_FLAG_LAST << 0)
} GstCapsFlags;
</ENUM>
<ENUM>
<NAME>GstCapsIntersectMode</NAME>
typedef enum {
  GST_CAPS_INTERSECT_ZIG_ZAG            =  0,
  GST_CAPS_INTERSECT_FIRST              =  1
} GstCapsIntersectMode;
</ENUM>
<MACRO>
<NAME>GST_CAPS_ANY</NAME>
#define GST_CAPS_ANY              _gst_caps_any
</MACRO>
<MACRO>
<NAME>GST_CAPS_NONE</NAME>
#define GST_CAPS_NONE             _gst_caps_none
</MACRO>
<MACRO>
<NAME>GST_STATIC_CAPS_ANY</NAME>
#define GST_STATIC_CAPS_ANY       GST_STATIC_CAPS("ANY")
</MACRO>
<MACRO>
<NAME>GST_STATIC_CAPS_NONE</NAME>
#define GST_STATIC_CAPS_NONE      GST_STATIC_CAPS("NONE")
</MACRO>
<MACRO>
<NAME>GST_CAPS_IS_SIMPLE</NAME>
#define GST_CAPS_IS_SIMPLE(caps) (gst_caps_get_size(caps) == 1)
</MACRO>
<MACRO>
<NAME>GST_STATIC_CAPS</NAME>
#define GST_STATIC_CAPS(string) \
{ \
  /* caps */ NULL, \
  /* string */ string, \
  GST_PADDING_INIT \
}
</MACRO>
<MACRO>
<NAME>GST_CAPS_FLAGS</NAME>
#define GST_CAPS_FLAGS(caps)                    GST_MINI_OBJECT_FLAGS(caps)
</MACRO>
<MACRO>
<NAME>GST_CAPS_REFCOUNT</NAME>
#define GST_CAPS_REFCOUNT(caps)                 GST_MINI_OBJECT_REFCOUNT(caps)
</MACRO>
<MACRO>
<NAME>GST_CAPS_REFCOUNT_VALUE</NAME>
#define GST_CAPS_REFCOUNT_VALUE(caps)           GST_MINI_OBJECT_REFCOUNT_VALUE(caps)
</MACRO>
<MACRO>
<NAME>GST_CAPS_FLAG_IS_SET</NAME>
#define GST_CAPS_FLAG_IS_SET(caps,flag)        GST_MINI_OBJECT_FLAG_IS_SET (caps, flag)
</MACRO>
<MACRO>
<NAME>GST_CAPS_FLAG_SET</NAME>
#define GST_CAPS_FLAG_SET(caps,flag)           GST_MINI_OBJECT_FLAG_SET (caps, flag)
</MACRO>
<MACRO>
<NAME>GST_CAPS_FLAG_UNSET</NAME>
#define GST_CAPS_FLAG_UNSET(caps,flag)         GST_MINI_OBJECT_FLAG_UNSET (caps, flag)
</MACRO>
<FUNCTION>
<NAME>gst_caps_ref</NAME>
<RETURNS>GstCaps  * </RETURNS>
GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_unref</NAME>
<RETURNS>void  </RETURNS>
GstCaps * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_copy</NAME>
<RETURNS>GstCaps  * </RETURNS>
const GstCaps * caps
</FUNCTION>
<MACRO>
<NAME>gst_caps_is_writable</NAME>
#define         gst_caps_is_writable(caps)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (caps))
</MACRO>
<MACRO>
<NAME>gst_caps_make_writable</NAME>
#define         gst_caps_make_writable(caps)   GST_CAPS_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (caps)))
</MACRO>
<FUNCTION>
<NAME>gst_caps_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps **old_caps, GstCaps *new_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_take</NAME>
<RETURNS>gboolean  </RETURNS>
GstCaps **old_caps, GstCaps *new_caps
</FUNCTION>
<STRUCT>
<NAME>GstCaps</NAME>
struct _GstCaps {
  GstMiniObject mini_object;
};
</STRUCT>
<STRUCT>
<NAME>GstStaticCaps</NAME>
struct _GstStaticCaps {
  /*< public >*/
  GstCaps *caps;
  const char *string;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstCapsForeachFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstCapsFeatures *features,
                                        GstStructure    *structure,
                                        gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstCapsMapFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstCapsFeatures *features,
                                        GstStructure    *structure,
                                        gpointer         user_data
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstCapsFilterMapFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstCapsFeatures *features,
                                          GstStructure    *structure,
                                          gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_caps_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_empty</NAME>
<RETURNS>GstCaps  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_any</NAME>
<RETURNS>GstCaps  *         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_empty_simple</NAME>
<RETURNS>GstCaps  *         </RETURNS>
const char    *media_type
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_simple</NAME>
<RETURNS>GstCaps  *         </RETURNS>
const char    *media_type, const char    *fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_full</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstStructure  *struct1, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_new_full_valist</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstStructure  *structure, va_list        var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_static_caps_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_static_caps_get</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstStaticCaps *static_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_static_caps_cleanup</NAME>
<RETURNS>void               </RETURNS>
GstStaticCaps *static_caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_append</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps1, GstCaps       *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_append_structure</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, GstStructure  *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_append_structure_full</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, GstStructure  *structure, GstCapsFeatures *features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_remove_structure</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_merge</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps       *caps1, GstCaps       *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_merge_structure</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps       *caps, GstStructure  *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_merge_structure_full</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps       *caps, GstStructure  *structure, GstCapsFeatures *features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_get_size</NAME>
<RETURNS>guint              </RETURNS>
const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_get_structure</NAME>
<RETURNS>GstStructure  *    </RETURNS>
const GstCaps *caps, guint          index
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_steal_structure</NAME>
<RETURNS>GstStructure  *    </RETURNS>
GstCaps       *caps, guint          index
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_set_features</NAME>
<RETURNS>void               </RETURNS>
GstCaps *caps, guint          index, GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_get_features</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
const GstCaps *caps, guint          index
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_copy_nth</NAME>
<RETURNS>GstCaps  *         </RETURNS>
const GstCaps *caps, guint nth
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_truncate</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps       *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_set_value</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, const char    *field, const GValue  *value
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_set_simple</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, const char    *field, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_set_simple_valist</NAME>
<RETURNS>void               </RETURNS>
GstCaps       *caps, const char    *field, va_list        varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_foreach</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps       *caps, GstCapsForeachFunc   func, gpointer             user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_map_in_place</NAME>
<RETURNS>gboolean           </RETURNS>
GstCaps        *caps, GstCapsMapFunc  func, gpointer        user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_filter_and_map_in_place</NAME>
<RETURNS>void               </RETURNS>
GstCaps              *caps, GstCapsFilterMapFunc  func, gpointer              user_data
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_any</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_empty</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_fixed</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_always_compatible</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps1, const GstCaps *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_subset</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *subset, const GstCaps *superset
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_subset_structure</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps, const GstStructure *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_subset_structure_full</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps, const GstStructure *structure, const GstCapsFeatures *features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_equal</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps1, const GstCaps *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_equal_fixed</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps1, const GstCaps *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_can_intersect</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps * caps1, const GstCaps * caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_is_strictly_equal</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCaps *caps1, const GstCaps *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_intersect</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *caps1, GstCaps *caps2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_intersect_full</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *caps1, GstCaps *caps2, GstCapsIntersectMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_subtract</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *minuend, GstCaps *subtrahend
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_normalize</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_simplify</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_fixate</NAME>
<RETURNS>GstCaps  *         </RETURNS>
GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_to_string</NAME>
<RETURNS>gchar  *           </RETURNS>
const GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_from_string</NAME>
<RETURNS>GstCaps  *         </RETURNS>
const gchar   *string
</FUNCTION>
<STRUCT>
<NAME>GstPollFD</NAME>
typedef struct {
  int fd;

  /*< private >*/
  gint idx;
} GstPollFD;
</STRUCT>
<MACRO>
<NAME>GST_POLL_FD_INIT</NAME>
#define GST_POLL_FD_INIT  { -1, -1 }
</MACRO>
<FUNCTION>
<NAME>gst_poll_new</NAME>
<RETURNS>GstPoll *        </RETURNS>
gboolean controllable
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_new_timer</NAME>
<RETURNS>GstPoll *        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_free</NAME>
<RETURNS>void             </RETURNS>
GstPoll *set
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_get_read_gpollfd</NAME>
<RETURNS>void             </RETURNS>
GstPoll *set, GPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_init</NAME>
<RETURNS>void             </RETURNS>
GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_add_fd</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_remove_fd</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_ctl_write</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set, GstPollFD *fd, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_ctl_read</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set, GstPollFD *fd, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_ignored</NAME>
<RETURNS>void             </RETURNS>
GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_has_closed</NAME>
<RETURNS>gboolean         </RETURNS>
const GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_has_error</NAME>
<RETURNS>gboolean         </RETURNS>
const GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_can_read</NAME>
<RETURNS>gboolean         </RETURNS>
const GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_fd_can_write</NAME>
<RETURNS>gboolean         </RETURNS>
const GstPoll *set, GstPollFD *fd
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_wait</NAME>
<RETURNS>gint             </RETURNS>
GstPoll *set, GstClockTime timeout
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_set_controllable</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set, gboolean controllable
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_restart</NAME>
<RETURNS>void             </RETURNS>
GstPoll *set
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_set_flushing</NAME>
<RETURNS>void             </RETURNS>
GstPoll *set, gboolean flushing
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_write_control</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set
</FUNCTION>
<FUNCTION>
<NAME>gst_poll_read_control</NAME>
<RETURNS>gboolean         </RETURNS>
GstPoll *set
</FUNCTION>
<STRUCT>
<NAME>GstPoll</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DEVICE</NAME>
#define GST_TYPE_DEVICE                 (gst_device_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE</NAME>
#define GST_IS_DEVICE(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_IS_DEVICE_CLASS</NAME>
#define GST_IS_DEVICE_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_DEVICE))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_GET_CLASS</NAME>
#define GST_DEVICE_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_DEVICE, GstDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE</NAME>
#define GST_DEVICE(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_DEVICE, GstDevice))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_CLASS</NAME>
#define GST_DEVICE_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_DEVICE, GstDeviceClass))
</MACRO>
<MACRO>
<NAME>GST_DEVICE_CAST</NAME>
#define GST_DEVICE_CAST(obj)            ((GstDevice *)(obj))
</MACRO>
<STRUCT>
<NAME>GstDevice</NAME>
struct _GstDevice {
  GstObject         parent;

  /*< private >*/
  GstDevicePrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstDeviceClass</NAME>
struct _GstDeviceClass {
  GstObjectClass    parent_class;

  GstElement * (*create_element)      (GstDevice * device, const gchar * name);
  gboolean     (*reconfigure_element) (GstDevice * device, GstElement * element);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_device_get_type</NAME>
<RETURNS>GType           </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_device_create_element</NAME>
<RETURNS>GstElement  *   </RETURNS>
GstDevice * device, const gchar * name
</FUNCTION>
<FUNCTION>
<NAME>gst_device_get_caps</NAME>
<RETURNS>GstCaps  *      </RETURNS>
GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_get_display_name</NAME>
<RETURNS>gchar  *        </RETURNS>
GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_get_device_class</NAME>
<RETURNS>gchar  *        </RETURNS>
GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_get_properties</NAME>
<RETURNS>GstStructure  * </RETURNS>
GstDevice * device
</FUNCTION>
<FUNCTION>
<NAME>gst_device_reconfigure_element</NAME>
<RETURNS>gboolean        </RETURNS>
GstDevice * device, GstElement * element
</FUNCTION>
<FUNCTION>
<NAME>gst_device_has_classesv</NAME>
<RETURNS>gboolean         </RETURNS>
GstDevice * device, gchar ** classes
</FUNCTION>
<FUNCTION>
<NAME>gst_device_has_classes</NAME>
<RETURNS>gboolean         </RETURNS>
GstDevice * device, const gchar * classes
</FUNCTION>
<STRUCT>
<NAME>GstDevicePrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TAG_SETTER</NAME>
#define GST_TYPE_TAG_SETTER             (gst_tag_setter_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TAG_SETTER</NAME>
#define GST_TAG_SETTER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_TAG_SETTER, GstTagSetter))
</MACRO>
<MACRO>
<NAME>GST_IS_TAG_SETTER</NAME>
#define GST_IS_TAG_SETTER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_TAG_SETTER))
</MACRO>
<MACRO>
<NAME>GST_TAG_SETTER_GET_INTERFACE</NAME>
#define GST_TAG_SETTER_GET_INTERFACE(obj)       (G_TYPE_INSTANCE_GET_INTERFACE ((obj), GST_TYPE_TAG_SETTER, GstTagSetterInterface))
</MACRO>
<STRUCT>
<NAME>GstTagSetterInterface</NAME>
struct _GstTagSetterInterface
{
  GTypeInterface g_iface;

  /* signals */

  /* virtual table */
};
</STRUCT>
<FUNCTION>
<NAME>gst_tag_setter_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_reset_tags</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter * setter
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_merge_tags</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, const GstTagList * list, GstTagMergeMode    mode
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_add_tags</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, GstTagMergeMode    mode, const gchar *      tag, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_add_tag_values</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, GstTagMergeMode    mode, const gchar *      tag, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_add_tag_valist</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, GstTagMergeMode    mode, const gchar *      tag, va_list            var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_add_tag_valist_values</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, GstTagMergeMode    mode, const gchar *      tag, va_list            var_args
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_add_tag_value</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *     setter, GstTagMergeMode    mode, const gchar *      tag, const GValue *     value
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_get_tag_list</NAME>
<RETURNS>const GstTagList  *</RETURNS>
GstTagSetter *    setter
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_set_tag_merge_mode</NAME>
<RETURNS>void             </RETURNS>
GstTagSetter *    setter, GstTagMergeMode   mode
</FUNCTION>
<FUNCTION>
<NAME>gst_tag_setter_get_tag_merge_mode</NAME>
<RETURNS>GstTagMergeMode  </RETURNS>
GstTagSetter *    setter
</FUNCTION>
<STRUCT>
<NAME>GstTagSetter</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TYPE_FIND</NAME>
#define GST_TYPE_TYPE_FIND  (gst_type_find_get_type())
</MACRO>
<USER_FUNCTION>
<NAME>GstTypeFindFunction</NAME>
<RETURNS>void </RETURNS>
GstTypeFind *find, gpointer user_data
</USER_FUNCTION>
<ENUM>
<NAME>GstTypeFindProbability</NAME>
typedef enum {
  GST_TYPE_FIND_NONE = 0,
  GST_TYPE_FIND_MINIMUM = 1,
  GST_TYPE_FIND_POSSIBLE = 50,
  GST_TYPE_FIND_LIKELY = 80,
  GST_TYPE_FIND_NEARLY_CERTAIN = 99,
  GST_TYPE_FIND_MAXIMUM = 100
} GstTypeFindProbability;
</ENUM>
<STRUCT>
<NAME>GstTypeFind</NAME>
struct _GstTypeFind {
  /* private to the caller of the typefind function */
  const guint8 *  (* peek)       (gpointer         data,
                                  gint64           offset,
                                  guint            size);

  void            (* suggest)    (gpointer         data,
                                  guint            probability,
                                  GstCaps         *caps);

  gpointer         data;

  /* optional */
  guint64         (* get_length) (gpointer data);

  /* <private> */
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_type_find_get_type</NAME>
<RETURNS>GType      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_peek</NAME>
<RETURNS>const guint8  *  </RETURNS>
GstTypeFind   * find, gint64          offset, guint           size
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_suggest</NAME>
<RETURNS>void             </RETURNS>
GstTypeFind   * find, guint           probability, GstCaps       * caps
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_suggest_simple</NAME>
<RETURNS>void             </RETURNS>
GstTypeFind * find, guint         probability, const char  * media_type, const char  * fieldname, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_get_length</NAME>
<RETURNS>guint64    </RETURNS>
GstTypeFind   * find
</FUNCTION>
<FUNCTION>
<NAME>gst_type_find_register</NAME>
<RETURNS>gboolean   </RETURNS>
GstPlugin            * plugin, const gchar          * name, guint                  rank, GstTypeFindFunction    func, const gchar          * extensions, GstCaps              * possible_caps, gpointer               data, GDestroyNotify         data_notify
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFER_POOL</NAME>
#define GST_TYPE_BUFFER_POOL                 (gst_buffer_pool_get_type())
</MACRO>
<MACRO>
<NAME>GST_IS_BUFFER_POOL</NAME>
#define GST_IS_BUFFER_POOL(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_IS_BUFFER_POOL_CLASS</NAME>
#define GST_IS_BUFFER_POOL_CLASS(klass)      (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_BUFFER_POOL))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_GET_CLASS</NAME>
#define GST_BUFFER_POOL_GET_CLASS(obj)       (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_BUFFER_POOL, GstBufferPoolClass))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL</NAME>
#define GST_BUFFER_POOL(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_BUFFER_POOL, GstBufferPool))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_CLASS</NAME>
#define GST_BUFFER_POOL_CLASS(klass)         (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_BUFFER_POOL, GstBufferPoolClass))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_POOL_CAST</NAME>
#define GST_BUFFER_POOL_CAST(obj)            ((GstBufferPool *)(obj))
</MACRO>
<ENUM>
<NAME>GstBufferPoolAcquireFlags</NAME>
typedef enum {
  GST_BUFFER_POOL_ACQUIRE_FLAG_NONE     = 0,
  GST_BUFFER_POOL_ACQUIRE_FLAG_KEY_UNIT = (1 << 0),
  GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT = (1 << 1),
  GST_BUFFER_POOL_ACQUIRE_FLAG_DISCONT  = (1 << 2),
  GST_BUFFER_POOL_ACQUIRE_FLAG_LAST     = (1 << 16),
} GstBufferPoolAcquireFlags;
</ENUM>
<STRUCT>
<NAME>GstBufferPoolAcquireParams</NAME>
struct _GstBufferPoolAcquireParams {
  GstFormat                 format;
  gint64                    start;
  gint64                    stop;
  GstBufferPoolAcquireFlags flags;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<MACRO>
<NAME>GST_BUFFER_POOL_IS_FLUSHING</NAME>
#define GST_BUFFER_POOL_IS_FLUSHING(pool)  (g_atomic_int_get (&pool->flushing))
</MACRO>
<STRUCT>
<NAME>GstBufferPool</NAME>
struct _GstBufferPool {
  GstObject            object;

  /*< protected >*/
  gint                 flushing;

  /*< private >*/
  GstBufferPoolPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstBufferPoolClass</NAME>
struct _GstBufferPoolClass {
  GstObjectClass    object_class;

  /*< public >*/
  const gchar ** (*get_options)    (GstBufferPool *pool);
  gboolean       (*set_config)     (GstBufferPool *pool, GstStructure *config);

  gboolean       (*start)          (GstBufferPool *pool);
  gboolean       (*stop)           (GstBufferPool *pool);

  GstFlowReturn  (*acquire_buffer) (GstBufferPool *pool, GstBuffer **buffer,
                                    GstBufferPoolAcquireParams *params);
  GstFlowReturn  (*alloc_buffer)   (GstBufferPool *pool, GstBuffer **buffer,
                                    GstBufferPoolAcquireParams *params);
  void           (*reset_buffer)   (GstBufferPool *pool, GstBuffer *buffer);
  void           (*release_buffer) (GstBufferPool *pool, GstBuffer *buffer);
  void           (*free_buffer)    (GstBufferPool *pool, GstBuffer *buffer);
  void           (*flush_start)    (GstBufferPool *pool);
  void           (*flush_stop)     (GstBufferPool *pool);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING - 2];
};
</STRUCT>
<FUNCTION>
<NAME>gst_buffer_pool_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_new</NAME>
<RETURNS>GstBufferPool  *  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_set_active</NAME>
<RETURNS>gboolean          </RETURNS>
GstBufferPool *pool, gboolean active
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_is_active</NAME>
<RETURNS>gboolean          </RETURNS>
GstBufferPool *pool
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_set_config</NAME>
<RETURNS>gboolean          </RETURNS>
GstBufferPool *pool, GstStructure *config
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_get_config</NAME>
<RETURNS>GstStructure  *   </RETURNS>
GstBufferPool *pool
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_get_options</NAME>
<RETURNS>const gchar  **   </RETURNS>
GstBufferPool *pool
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_has_option</NAME>
<RETURNS>gboolean          </RETURNS>
GstBufferPool *pool, const gchar *option
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_set_flushing</NAME>
<RETURNS>void              </RETURNS>
GstBufferPool *pool, gboolean flushing
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_set_params</NAME>
<RETURNS>void              </RETURNS>
GstStructure *config, GstCaps *caps, guint size, guint min_buffers, guint max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_get_params</NAME>
<RETURNS>gboolean          </RETURNS>
GstStructure *config, GstCaps **caps, guint *size, guint *min_buffers, guint *max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_set_allocator</NAME>
<RETURNS>void              </RETURNS>
GstStructure *config, GstAllocator *allocator, const GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_get_allocator</NAME>
<RETURNS>gboolean          </RETURNS>
GstStructure *config, GstAllocator **allocator, GstAllocationParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_n_options</NAME>
<RETURNS>guint             </RETURNS>
GstStructure *config
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_add_option</NAME>
<RETURNS>void              </RETURNS>
GstStructure *config, const gchar *option
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_get_option</NAME>
<RETURNS>const gchar  *    </RETURNS>
GstStructure *config, guint index
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_has_option</NAME>
<RETURNS>gboolean          </RETURNS>
GstStructure *config, const gchar *option
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_config_validate_params</NAME>
<RETURNS>gboolean          </RETURNS>
GstStructure *config, GstCaps *caps, guint size, guint min_buffers, guint max_buffers
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_acquire_buffer</NAME>
<RETURNS>GstFlowReturn     </RETURNS>
GstBufferPool *pool, GstBuffer **buffer, GstBufferPoolAcquireParams *params
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_pool_release_buffer</NAME>
<RETURNS>void              </RETURNS>
GstBufferPool *pool, GstBuffer *buffer
</FUNCTION>
<STRUCT>
<NAME>GstBufferPoolPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_CAPS_FEATURES</NAME>
#define GST_TYPE_CAPS_FEATURES (_gst_caps_features_type)
</MACRO>
<MACRO>
<NAME>GST_IS_CAPS_FEATURES</NAME>
#define GST_IS_CAPS_FEATURES(object)       (gst_is_caps_features(object))
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURES_CAST</NAME>
#define GST_CAPS_FEATURES_CAST(object)     ((GstCapsFeatures *)(object))
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURES</NAME>
#define GST_CAPS_FEATURES(object)          (GST_CAPS_FEATURES_CAST(object))
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY</NAME>
#define GST_CAPS_FEATURE_MEMORY_SYSTEM_MEMORY "memory:SystemMemory"
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURES_ANY</NAME>
#define GST_CAPS_FEATURES_ANY (_gst_caps_features_any)
</MACRO>
<MACRO>
<NAME>GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY</NAME>
#define GST_CAPS_FEATURES_MEMORY_SYSTEM_MEMORY (_gst_caps_features_memory_system_memory)
</MACRO>
<FUNCTION>
<NAME>gst_caps_features_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_is_caps_features</NAME>
<RETURNS>gboolean           </RETURNS>
gconstpointer obj
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new_empty</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new_any</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
const gchar *feature1, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new_valist</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
const gchar *feature1, va_list varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new_id</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
GQuark feature1, ...
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_new_id_valist</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
GQuark feature1, va_list varargs
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_set_parent_refcount</NAME>
<RETURNS>gboolean           </RETURNS>
GstCapsFeatures *features, gint * refcount
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_copy</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
const GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_free</NAME>
<RETURNS>void               </RETURNS>
GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_to_string</NAME>
<RETURNS>gchar  *           </RETURNS>
const GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_from_string</NAME>
<RETURNS>GstCapsFeatures  * </RETURNS>
const gchar * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_get_size</NAME>
<RETURNS>guint              </RETURNS>
const GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_get_nth</NAME>
<RETURNS>const gchar  *     </RETURNS>
const GstCapsFeatures * features, guint i
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_get_nth_id</NAME>
<RETURNS>GQuark             </RETURNS>
const GstCapsFeatures * features, guint i
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_contains</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCapsFeatures * features, const gchar * feature
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_contains_id</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCapsFeatures * features, GQuark feature
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_is_equal</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCapsFeatures * features1, const GstCapsFeatures * features2
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_is_any</NAME>
<RETURNS>gboolean           </RETURNS>
const GstCapsFeatures * features
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_add</NAME>
<RETURNS>void               </RETURNS>
GstCapsFeatures * features, const gchar * feature
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_add_id</NAME>
<RETURNS>void               </RETURNS>
 GstCapsFeatures * features, GQuark feature
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_remove</NAME>
<RETURNS>void               </RETURNS>
GstCapsFeatures * features, const gchar * feature
</FUNCTION>
<FUNCTION>
<NAME>gst_caps_features_remove_id</NAME>
<RETURNS>void               </RETURNS>
GstCapsFeatures * features, GQuark feature
</FUNCTION>
<STRUCT>
<NAME>GstCapsFeatures</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_DATE_TIME</NAME>
#define GST_TYPE_DATE_TIME (_gst_date_time_type)
</MACRO>
<FUNCTION>
<NAME>gst_date_time_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_has_year</NAME>
<RETURNS>gboolean         </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_has_month</NAME>
<RETURNS>gboolean         </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_has_day</NAME>
<RETURNS>gboolean         </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_has_time</NAME>
<RETURNS>gboolean         </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_has_second</NAME>
<RETURNS>gboolean         </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_year</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_month</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_day</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_hour</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_minute</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_second</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_microsecond</NAME>
<RETURNS>gint             </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_get_time_zone_offset</NAME>
<RETURNS>gfloat           </RETURNS>
const GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_from_unix_epoch_local_time</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint64 secs
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_from_unix_epoch_utc</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint64 secs
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_local_time</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint year, gint month, gint day, gint hour, gint minute, gdouble seconds
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_y</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint year
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_ym</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint year, gint month
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_ymd</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gint year, gint month, gint day
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
gfloat tzoffset, gint year, gint month, gint day, gint hour, gint minute, gdouble seconds
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_now_local_time</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_now_utc</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_to_iso8601_string</NAME>
<RETURNS>gchar  *         </RETURNS>
GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_from_iso8601_string</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
const gchar * string
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_to_g_date_time</NAME>
<RETURNS>GDateTime  *     </RETURNS>
GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_new_from_g_date_time</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
GDateTime * dt
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_ref</NAME>
<RETURNS>GstDateTime  *   </RETURNS>
GstDateTime * datetime
</FUNCTION>
<FUNCTION>
<NAME>gst_date_time_unref</NAME>
<RETURNS>void             </RETURNS>
GstDateTime * datetime
</FUNCTION>
<STRUCT>
<NAME>GstDateTime</NAME>
</STRUCT>
<MACRO>
<NAME>GST_ELEMENT_METADATA_LONGNAME</NAME>
#define GST_ELEMENT_METADATA_LONGNAME      "long-name"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_METADATA_KLASS</NAME>
#define GST_ELEMENT_METADATA_KLASS         "klass"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_METADATA_DESCRIPTION</NAME>
#define GST_ELEMENT_METADATA_DESCRIPTION   "description"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_METADATA_AUTHOR</NAME>
#define GST_ELEMENT_METADATA_AUTHOR        "author"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_METADATA_DOC_URI</NAME>
#define GST_ELEMENT_METADATA_DOC_URI       "doc-uri"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_METADATA_ICON_NAME</NAME>
#define GST_ELEMENT_METADATA_ICON_NAME     "icon-name"
</MACRO>
<ENUM>
<NAME>GstEventTypeFlags</NAME>
typedef enum {
  GST_EVENT_TYPE_UPSTREAM       = 1 << 0,
  GST_EVENT_TYPE_DOWNSTREAM     = 1 << 1,
  GST_EVENT_TYPE_SERIALIZED     = 1 << 2,
  GST_EVENT_TYPE_STICKY         = 1 << 3,
  GST_EVENT_TYPE_STICKY_MULTI   = 1 << 4
} GstEventTypeFlags;
</ENUM>
<MACRO>
<NAME>GST_EVENT_TYPE_BOTH</NAME>
#define GST_EVENT_TYPE_BOTH \
    (GST_EVENT_TYPE_UPSTREAM | GST_EVENT_TYPE_DOWNSTREAM)
</MACRO>
<MACRO>
<NAME>GST_EVENT_NUM_SHIFT</NAME>
#define GST_EVENT_NUM_SHIFT     (8)
</MACRO>
<MACRO>
<NAME>GST_EVENT_MAKE_TYPE</NAME>
#define GST_EVENT_MAKE_TYPE(num,flags) \
    (((num) << GST_EVENT_NUM_SHIFT) | (flags))
</MACRO>
<MACRO>
<NAME>FLAG</NAME>
#define FLAG(name) GST_EVENT_TYPE_##name
</MACRO>
<ENUM>
<NAME>GstEventType</NAME>
typedef enum {
  GST_EVENT_UNKNOWN               = GST_EVENT_MAKE_TYPE (0, 0),

  /* bidirectional events */
  GST_EVENT_FLUSH_START           = GST_EVENT_MAKE_TYPE (10, FLAG(BOTH)),
  GST_EVENT_FLUSH_STOP            = GST_EVENT_MAKE_TYPE (20, FLAG(BOTH) | FLAG(SERIALIZED)),

  /* downstream serialized events */
  GST_EVENT_STREAM_START          = GST_EVENT_MAKE_TYPE (40, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY)),
  GST_EVENT_CAPS                  = GST_EVENT_MAKE_TYPE (50, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY)),
  GST_EVENT_SEGMENT               = GST_EVENT_MAKE_TYPE (70, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY)),
  GST_EVENT_TAG                   = GST_EVENT_MAKE_TYPE (80, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY) | FLAG(STICKY_MULTI)),
  GST_EVENT_BUFFERSIZE            = GST_EVENT_MAKE_TYPE (90, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY)),
  GST_EVENT_SINK_MESSAGE          = GST_EVENT_MAKE_TYPE (100, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY) | FLAG(STICKY_MULTI)),
  GST_EVENT_EOS                   = GST_EVENT_MAKE_TYPE (110, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY)),
  GST_EVENT_TOC                   = GST_EVENT_MAKE_TYPE (120, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY) | FLAG(STICKY_MULTI)),
  GST_EVENT_PROTECTION            = GST_EVENT_MAKE_TYPE (130, FLAG (DOWNSTREAM) | FLAG (SERIALIZED) | FLAG (STICKY) | FLAG (STICKY_MULTI)),

  /* non-sticky downstream serialized */
  GST_EVENT_SEGMENT_DONE          = GST_EVENT_MAKE_TYPE (150, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
  GST_EVENT_GAP                   = GST_EVENT_MAKE_TYPE (160, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),

  /* upstream events */
  GST_EVENT_QOS                   = GST_EVENT_MAKE_TYPE (190, FLAG(UPSTREAM)),
  GST_EVENT_SEEK                  = GST_EVENT_MAKE_TYPE (200, FLAG(UPSTREAM)),
  GST_EVENT_NAVIGATION            = GST_EVENT_MAKE_TYPE (210, FLAG(UPSTREAM)),
  GST_EVENT_LATENCY               = GST_EVENT_MAKE_TYPE (220, FLAG(UPSTREAM)),
  GST_EVENT_STEP                  = GST_EVENT_MAKE_TYPE (230, FLAG(UPSTREAM)),
  GST_EVENT_RECONFIGURE           = GST_EVENT_MAKE_TYPE (240, FLAG(UPSTREAM)),
  GST_EVENT_TOC_SELECT            = GST_EVENT_MAKE_TYPE (250, FLAG(UPSTREAM)),

  /* custom events start here */
  GST_EVENT_CUSTOM_UPSTREAM          = GST_EVENT_MAKE_TYPE (270, FLAG(UPSTREAM)),
  GST_EVENT_CUSTOM_DOWNSTREAM        = GST_EVENT_MAKE_TYPE (280, FLAG(DOWNSTREAM) | FLAG(SERIALIZED)),
  GST_EVENT_CUSTOM_DOWNSTREAM_OOB    = GST_EVENT_MAKE_TYPE (290, FLAG(DOWNSTREAM)),
  GST_EVENT_CUSTOM_DOWNSTREAM_STICKY = GST_EVENT_MAKE_TYPE (300, FLAG(DOWNSTREAM) | FLAG(SERIALIZED) | FLAG(STICKY) | FLAG(STICKY_MULTI)),
  GST_EVENT_CUSTOM_BOTH              = GST_EVENT_MAKE_TYPE (310, FLAG(BOTH) | FLAG(SERIALIZED)),
  GST_EVENT_CUSTOM_BOTH_OOB          = GST_EVENT_MAKE_TYPE (320, FLAG(BOTH))
} GstEventType;
</ENUM>
<MACRO>
<NAME>GST_TYPE_EVENT</NAME>
#define GST_TYPE_EVENT                  (_gst_event_type)
</MACRO>
<MACRO>
<NAME>GST_IS_EVENT</NAME>
#define GST_IS_EVENT(obj)               (GST_IS_MINI_OBJECT_TYPE (obj, GST_TYPE_EVENT))
</MACRO>
<MACRO>
<NAME>GST_EVENT_CAST</NAME>
#define GST_EVENT_CAST(obj)             ((GstEvent *)(obj))
</MACRO>
<MACRO>
<NAME>GST_EVENT</NAME>
#define GST_EVENT(obj)                  (GST_EVENT_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_EVENT_TYPE</NAME>
#define GST_EVENT_TYPE(event)           (GST_EVENT_CAST(event)->type)
</MACRO>
<MACRO>
<NAME>GST_EVENT_TYPE_NAME</NAME>
#define GST_EVENT_TYPE_NAME(event)      (gst_event_type_get_name(GST_EVENT_TYPE(event)))
</MACRO>
<MACRO>
<NAME>GST_EVENT_TIMESTAMP</NAME>
#define GST_EVENT_TIMESTAMP(event)      (GST_EVENT_CAST(event)->timestamp)
</MACRO>
<MACRO>
<NAME>GST_EVENT_SEQNUM</NAME>
#define GST_EVENT_SEQNUM(event)         (GST_EVENT_CAST(event)->seqnum)
</MACRO>
<MACRO>
<NAME>GST_EVENT_IS_UPSTREAM</NAME>
#define GST_EVENT_IS_UPSTREAM(ev)       !!(GST_EVENT_TYPE (ev) & GST_EVENT_TYPE_UPSTREAM)
</MACRO>
<MACRO>
<NAME>GST_EVENT_IS_DOWNSTREAM</NAME>
#define GST_EVENT_IS_DOWNSTREAM(ev)     !!(GST_EVENT_TYPE (ev) & GST_EVENT_TYPE_DOWNSTREAM)
</MACRO>
<MACRO>
<NAME>GST_EVENT_IS_SERIALIZED</NAME>
#define GST_EVENT_IS_SERIALIZED(ev)     !!(GST_EVENT_TYPE (ev) & GST_EVENT_TYPE_SERIALIZED)
</MACRO>
<MACRO>
<NAME>GST_EVENT_IS_STICKY</NAME>
#define GST_EVENT_IS_STICKY(ev)     !!(GST_EVENT_TYPE (ev) & GST_EVENT_TYPE_STICKY)
</MACRO>
<MACRO>
<NAME>gst_event_is_writable</NAME>
#define         gst_event_is_writable(ev)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (ev))
</MACRO>
<MACRO>
<NAME>gst_event_make_writable</NAME>
#define         gst_event_make_writable(ev)   GST_EVENT_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (ev)))
</MACRO>
<FUNCTION>
<NAME>gst_event_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstEvent **old_event, GstEvent *new_event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_steal</NAME>
<RETURNS>GstEvent  * </RETURNS>
GstEvent **old_event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_take</NAME>
<RETURNS>gboolean  </RETURNS>
GstEvent **old_event, GstEvent *new_event
</FUNCTION>
<ENUM>
<NAME>GstQOSType</NAME>
typedef enum {
  GST_QOS_TYPE_OVERFLOW        = 0,
  GST_QOS_TYPE_UNDERFLOW       = 1,
  GST_QOS_TYPE_THROTTLE        = 2
} GstQOSType;
</ENUM>
<ENUM>
<NAME>GstStreamFlags</NAME>
typedef enum {
  GST_STREAM_FLAG_NONE,
  GST_STREAM_FLAG_SPARSE       = (1 << 0),
  GST_STREAM_FLAG_SELECT       = (1 << 1),
  GST_STREAM_FLAG_UNSELECT     = (1 << 2)
} GstStreamFlags;
</ENUM>
<STRUCT>
<NAME>GstEvent</NAME>
struct _GstEvent {
  GstMiniObject mini_object;

  /*< public >*/ /* with COW */
  GstEventType  type;
  guint64       timestamp;
  guint32       seqnum;
};
</STRUCT>
<FUNCTION>
<NAME>gst_event_type_get_name</NAME>
<RETURNS>const gchar *    </RETURNS>
GstEventType type
</FUNCTION>
<FUNCTION>
<NAME>gst_event_type_to_quark</NAME>
<RETURNS>GQuark           </RETURNS>
GstEventType type
</FUNCTION>
<FUNCTION>
<NAME>gst_event_type_get_flags</NAME>
<RETURNS>GstEventTypeFlags </RETURNS>
GstEventType type
</FUNCTION>
<FUNCTION>
<NAME>gst_event_ref</NAME>
<RETURNS>GstEvent  * </RETURNS>
GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_unref</NAME>
<RETURNS>void  </RETURNS>
GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_copy</NAME>
<RETURNS>GstEvent  * </RETURNS>
const GstEvent * event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_custom</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstEventType type, GstStructure *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_event_get_structure</NAME>
<RETURNS>const GstStructure  *</RETURNS>
GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_writable_structure</NAME>
<RETURNS>GstStructure  *  </RETURNS>
GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_has_name</NAME>
<RETURNS>gboolean         </RETURNS>
GstEvent *event, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_event_get_seqnum</NAME>
<RETURNS>guint32          </RETURNS>
GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_set_seqnum</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, guint32 seqnum
</FUNCTION>
<FUNCTION>
<NAME>gst_event_get_running_time_offset</NAME>
<RETURNS>gint64           </RETURNS>
GstEvent *event
</FUNCTION>
<FUNCTION>
<NAME>gst_event_set_running_time_offset</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, gint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_stream_start</NAME>
<RETURNS>GstEvent  *      </RETURNS>
const gchar *stream_id
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_stream_start</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, const gchar **stream_id
</FUNCTION>
<FUNCTION>
<NAME>gst_event_set_stream_flags</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstStreamFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_stream_flags</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstStreamFlags *flags
</FUNCTION>
<FUNCTION>
<NAME>gst_event_set_group_id</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, guint group_id
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_group_id</NAME>
<RETURNS>gboolean         </RETURNS>
GstEvent *event, guint *group_id
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_flush_start</NAME>
<RETURNS>GstEvent  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_flush_stop</NAME>
<RETURNS>GstEvent  *      </RETURNS>
gboolean reset_time
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_flush_stop</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, gboolean *reset_time
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_eos</NAME>
<RETURNS>GstEvent  *      </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_gap</NAME>
<RETURNS>GstEvent  *      </RETURNS>
GstClockTime   timestamp, GstClockTime   duration
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_gap</NAME>
<RETURNS>void             </RETURNS>
GstEvent     * event, GstClockTime * timestamp, GstClockTime * duration
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_caps</NAME>
<RETURNS>GstEvent  *      </RETURNS>
GstCaps *caps
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_caps</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstCaps **caps
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_segment</NAME>
<RETURNS>GstEvent *       </RETURNS>
const GstSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_segment</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, const GstSegment **segment
</FUNCTION>
<FUNCTION>
<NAME>gst_event_copy_segment</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_tag</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstTagList *taglist
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_tag</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstTagList **taglist
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_toc</NAME>
<RETURNS>GstEvent *      </RETURNS>
GstToc *toc, gboolean updated
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_toc</NAME>
<RETURNS>void            </RETURNS>
GstEvent *event, GstToc **toc, gboolean *updated
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_protection</NAME>
<RETURNS>GstEvent  *     </RETURNS>
const gchar * system_id, GstBuffer * data, const gchar * origin
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_protection</NAME>
<RETURNS>void            </RETURNS>
GstEvent * event, const gchar ** system_id, GstBuffer ** data, const gchar ** origin
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_buffer_size</NAME>
<RETURNS>GstEvent  *      </RETURNS>
GstFormat format, gint64 minsize, gint64 maxsize, gboolean async
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_buffer_size</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstFormat *format, gint64 *minsize, gint64 *maxsize, gboolean *async
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_sink_message</NAME>
<RETURNS>GstEvent *       </RETURNS>
const gchar *name, GstMessage *msg
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_sink_message</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstMessage **msg
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_qos</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstQOSType type, gdouble proportion, GstClockTimeDiff diff, GstClockTime timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_qos</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstQOSType *type, gdouble *proportion, GstClockTimeDiff *diff, GstClockTime *timestamp
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_seek</NAME>
<RETURNS>GstEvent *       </RETURNS>
gdouble rate, GstFormat format, GstSeekFlags flags, GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_seek</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, gdouble *rate, GstFormat *format, GstSeekFlags *flags, GstSeekType *start_type, gint64 *start, GstSeekType *stop_type, gint64 *stop
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_navigation</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstStructure *structure
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_latency</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstClockTime latency
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_latency</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstClockTime *latency
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_step</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstFormat format, guint64 amount, gdouble rate, gboolean flush, gboolean intermediate
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_step</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstFormat *format, guint64 *amount, gdouble *rate, gboolean *flush, gboolean *intermediate
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_reconfigure</NAME>
<RETURNS>GstEvent *       </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_toc_select</NAME>
<RETURNS>GstEvent *       </RETURNS>
const gchar *uid
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_toc_select</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, gchar **uid
</FUNCTION>
<FUNCTION>
<NAME>gst_event_new_segment_done</NAME>
<RETURNS>GstEvent *       </RETURNS>
GstFormat format, gint64 position
</FUNCTION>
<FUNCTION>
<NAME>gst_event_parse_segment_done</NAME>
<RETURNS>void             </RETURNS>
GstEvent *event, GstFormat *format, gint64 *position
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_ELEMENT_FACTORY</NAME>
#define GST_TYPE_ELEMENT_FACTORY                (gst_element_factory_get_type())
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY</NAME>
#define GST_ELEMENT_FACTORY(obj)                (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_ELEMENT_FACTORY,\
                                                 GstElementFactory))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_CLASS</NAME>
#define GST_ELEMENT_FACTORY_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_ELEMENT_FACTORY,\
                                                 GstElementFactoryClass))
</MACRO>
<MACRO>
<NAME>GST_IS_ELEMENT_FACTORY</NAME>
#define GST_IS_ELEMENT_FACTORY(obj)             (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_ELEMENT_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_IS_ELEMENT_FACTORY_CLASS</NAME>
#define GST_IS_ELEMENT_FACTORY_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_ELEMENT_FACTORY))
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_CAST</NAME>
#define GST_ELEMENT_FACTORY_CAST(obj)           ((GstElementFactory *)(obj))
</MACRO>
<FUNCTION>
<NAME>gst_element_factory_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_find</NAME>
<RETURNS>GstElementFactory  *     </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_element_type</NAME>
<RETURNS>GType                    </RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_metadata</NAME>
<RETURNS>const gchar  *           </RETURNS>
GstElementFactory *factory, const gchar *key
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_metadata_keys</NAME>
<RETURNS>gchar  **                </RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_num_pad_templates</NAME>
<RETURNS>guint                    </RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_static_pad_templates</NAME>
<RETURNS>const GList  *           </RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_uri_type</NAME>
<RETURNS>GstURIType               </RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_get_uri_protocols</NAME>
<RETURNS>const gchar  * const *</RETURNS>
GstElementFactory *factory
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_has_interface</NAME>
<RETURNS>gboolean                 </RETURNS>
GstElementFactory *factory, const gchar *interfacename
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_create</NAME>
<RETURNS>GstElement *             </RETURNS>
GstElementFactory *factory, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_make</NAME>
<RETURNS>GstElement *             </RETURNS>
const gchar *factoryname, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_element_register</NAME>
<RETURNS>gboolean                 </RETURNS>
GstPlugin *plugin, const gchar *name, guint rank, GType type
</FUNCTION>
<TYPEDEF>
<NAME>GstElementFactoryListType</NAME>
typedef guint64 GstElementFactoryListType;
</TYPEDEF>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_DECODER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_DECODER        (G_GUINT64_CONSTANT (1) << 0)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_ENCODER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_ENCODER        (G_GUINT64_CONSTANT (1) << 1)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_SINK</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_SINK           (G_GUINT64_CONSTANT (1) << 2)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_SRC</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_SRC            (G_GUINT64_CONSTANT (1) << 3)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MUXER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MUXER          (G_GUINT64_CONSTANT (1) << 4)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_DEMUXER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_DEMUXER        (G_GUINT64_CONSTANT (1) << 5)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_PARSER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_PARSER         (G_GUINT64_CONSTANT (1) << 6)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_PAYLOADER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_PAYLOADER      (G_GUINT64_CONSTANT (1) << 7)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER    (G_GUINT64_CONSTANT (1) << 8)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_FORMATTER</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_FORMATTER      (G_GUINT64_CONSTANT (1) << 9)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_DECRYPTOR</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_DECRYPTOR      (G_GUINT64_CONSTANT (1) << 10)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_ENCRYPTOR      (G_GUINT64_CONSTANT (1) << 11)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MAX_ELEMENTS   (G_GUINT64_CONSTANT (1) << 48)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO    (G_GUINT64_CONSTANT (1) << 49)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO    (G_GUINT64_CONSTANT (1) << 50)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE    (G_GUINT64_CONSTANT (1) << 51)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MEDIA_SUBTITLE (G_GUINT64_CONSTANT (1) << 52)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_MEDIA_METADATA (G_GUINT64_CONSTANT (1) << 53)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_ANY</NAME>
#define  GST_ELEMENT_FACTORY_TYPE_ANY ((G_GUINT64_CONSTANT (1) << 49) - 1)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY</NAME>
#define GST_ELEMENT_FACTORY_TYPE_MEDIA_ANY (~G_GUINT64_CONSTANT (0) << 48)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER</NAME>
#define GST_ELEMENT_FACTORY_TYPE_VIDEO_ENCODER (GST_ELEMENT_FACTORY_TYPE_ENCODER | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO | GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER</NAME>
#define GST_ELEMENT_FACTORY_TYPE_AUDIO_ENCODER (GST_ELEMENT_FACTORY_TYPE_ENCODER | GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS</NAME>
#define GST_ELEMENT_FACTORY_TYPE_AUDIOVIDEO_SINKS (GST_ELEMENT_FACTORY_TYPE_SINK | GST_ELEMENT_FACTORY_TYPE_MEDIA_AUDIO | GST_ELEMENT_FACTORY_TYPE_MEDIA_VIDEO | GST_ELEMENT_FACTORY_TYPE_MEDIA_IMAGE)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_TYPE_DECODABLE</NAME>
#define GST_ELEMENT_FACTORY_TYPE_DECODABLE \
  (GST_ELEMENT_FACTORY_TYPE_DECODER | GST_ELEMENT_FACTORY_TYPE_DEMUXER | GST_ELEMENT_FACTORY_TYPE_DEPAYLOADER | GST_ELEMENT_FACTORY_TYPE_PARSER | GST_ELEMENT_FACTORY_TYPE_DECRYPTOR)
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_DECODER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_DECODER               "Decoder"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_ENCODER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_ENCODER               "Encoder"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_SINK</NAME>
#define GST_ELEMENT_FACTORY_KLASS_SINK                  "Sink"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_SRC</NAME>
#define GST_ELEMENT_FACTORY_KLASS_SRC                   "Source"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MUXER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MUXER                 "Muxer"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_DEMUXER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_DEMUXER               "Demuxer"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_PARSER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_PARSER                "Parser"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_PAYLOADER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_PAYLOADER             "Payloader"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_DEPAYLOADER           "Depayloader"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_FORMATTER</NAME>
#define GST_ELEMENT_FACTORY_KLASS_FORMATTER             "Formatter"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_DECRYPTOR</NAME>
#define GST_ELEMENT_FACTORY_KLASS_DECRYPTOR             "Decryptor"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR</NAME>
#define GST_ELEMENT_FACTORY_KLASS_ENCRYPTOR             "Encryptor"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MEDIA_VIDEO           "Video"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MEDIA_AUDIO           "Audio"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MEDIA_IMAGE           "Image"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MEDIA_SUBTITLE        "Subtitle"
</MACRO>
<MACRO>
<NAME>GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA</NAME>
#define GST_ELEMENT_FACTORY_KLASS_MEDIA_METADATA        "Metadata"
</MACRO>
<FUNCTION>
<NAME>gst_element_factory_list_is_type</NAME>
<RETURNS>gboolean       </RETURNS>
GstElementFactory *factory, GstElementFactoryListType type
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_list_get_elements</NAME>
<RETURNS>GList  *       </RETURNS>
GstElementFactoryListType type, GstRank minrank
</FUNCTION>
<FUNCTION>
<NAME>gst_element_factory_list_filter</NAME>
<RETURNS>GList  *       </RETURNS>
GList *list, const GstCaps *caps, GstPadDirection direction, gboolean subsetonly
</FUNCTION>
<STRUCT>
<NAME>GstElementFactory</NAME>
</STRUCT>
<STRUCT>
<NAME>GstElementFactoryClass</NAME>
</STRUCT>
<STRUCT>
<NAME>GstPluginLoaderFuncs</NAME>
typedef struct _GstPluginLoaderFuncs {
  GstPluginLoader * (*create)   (GstRegistry *registry);
  gboolean          (*destroy)  (GstPluginLoader *loader);
  gboolean          (*load)     (GstPluginLoader *loader, const gchar *filename,
                                 off_t file_size, time_t file_mtime);
} GstPluginLoaderFuncs;
</STRUCT>
<STRUCT>
<NAME>GstPluginLoader</NAME>
</STRUCT>
<MACRO>
<NAME>GST_IS_MINI_OBJECT_TYPE</NAME>
#define GST_IS_MINI_OBJECT_TYPE(obj,type)  ((obj) && GST_MINI_OBJECT_TYPE(obj) == (type))
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_CAST</NAME>
#define GST_MINI_OBJECT_CAST(obj)          ((GstMiniObject*)(obj))
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_CONST_CAST</NAME>
#define GST_MINI_OBJECT_CONST_CAST(obj)    ((const GstMiniObject*)(obj))
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT</NAME>
#define GST_MINI_OBJECT(obj)               (GST_MINI_OBJECT_CAST(obj))
</MACRO>
<USER_FUNCTION>
<NAME>GstMiniObjectCopyFunction</NAME>
<RETURNS>GstMiniObject *</RETURNS>
const GstMiniObject *obj
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMiniObjectDisposeFunction</NAME>
<RETURNS>gboolean </RETURNS>
GstMiniObject *obj
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMiniObjectFreeFunction</NAME>
<RETURNS>void </RETURNS>
GstMiniObject *obj
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstMiniObjectNotify</NAME>
<RETURNS>void </RETURNS>
gpointer user_data, GstMiniObject * obj
</USER_FUNCTION>
<MACRO>
<NAME>GST_MINI_OBJECT_TYPE</NAME>
#define GST_MINI_OBJECT_TYPE(obj)  (GST_MINI_OBJECT_CAST(obj)->type)
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_FLAGS</NAME>
#define GST_MINI_OBJECT_FLAGS(obj)  (GST_MINI_OBJECT_CAST(obj)->flags)
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_FLAG_IS_SET</NAME>
#define GST_MINI_OBJECT_FLAG_IS_SET(obj,flag)        !!(GST_MINI_OBJECT_FLAGS (obj) & (flag))
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_FLAG_SET</NAME>
#define GST_MINI_OBJECT_FLAG_SET(obj,flag)           (GST_MINI_OBJECT_FLAGS (obj) |= (flag))
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_FLAG_UNSET</NAME>
#define GST_MINI_OBJECT_FLAG_UNSET(obj,flag)         (GST_MINI_OBJECT_FLAGS (obj) &= ~(flag))
</MACRO>
<ENUM>
<NAME>GstMiniObjectFlags</NAME>
typedef enum
{
  GST_MINI_OBJECT_FLAG_LOCKABLE      = (1 << 0),
  GST_MINI_OBJECT_FLAG_LOCK_READONLY = (1 << 1),
  /* padding */
  GST_MINI_OBJECT_FLAG_LAST          = (1 << 4)
} GstMiniObjectFlags;
</ENUM>
<MACRO>
<NAME>GST_MINI_OBJECT_IS_LOCKABLE</NAME>
#define GST_MINI_OBJECT_IS_LOCKABLE(obj)  GST_MINI_OBJECT_FLAG_IS_SET(obj, GST_MINI_OBJECT_FLAG_LOCKABLE)
</MACRO>
<ENUM>
<NAME>GstLockFlags</NAME>
typedef enum {
  GST_LOCK_FLAG_READ      = (1 << 0),
  GST_LOCK_FLAG_WRITE     = (1 << 1),
  GST_LOCK_FLAG_EXCLUSIVE = (1 << 2),

  GST_LOCK_FLAG_LAST      = (1 << 8)
} GstLockFlags;
</ENUM>
<MACRO>
<NAME>GST_LOCK_FLAG_READWRITE</NAME>
#define GST_LOCK_FLAG_READWRITE  (GST_LOCK_FLAG_READ | GST_LOCK_FLAG_WRITE)
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_REFCOUNT</NAME>
#define GST_MINI_OBJECT_REFCOUNT(obj)           ((GST_MINI_OBJECT_CAST(obj))->refcount)
</MACRO>
<MACRO>
<NAME>GST_MINI_OBJECT_REFCOUNT_VALUE</NAME>
#define GST_MINI_OBJECT_REFCOUNT_VALUE(obj)     (g_atomic_int_get (&(GST_MINI_OBJECT_CAST(obj))->refcount))
</MACRO>
<STRUCT>
<NAME>GstMiniObject</NAME>
struct _GstMiniObject {
  GType   type;

  /*< public >*/ /* with COW */
  gint    refcount;
  gint    lockstate;
  guint   flags;

  GstMiniObjectCopyFunction copy;
  GstMiniObjectDisposeFunction dispose;
  GstMiniObjectFreeFunction free;

  /* < private > */
  /* Used to keep track of weak ref notifies and qdata */
  guint n_qdata;
  gpointer qdata;
};
</STRUCT>
<FUNCTION>
<NAME>gst_mini_object_init</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *mini_object, guint flags, GType type, GstMiniObjectCopyFunction copy_func, GstMiniObjectDisposeFunction dispose_func, GstMiniObjectFreeFunction free_func
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_ref</NAME>
<RETURNS>GstMiniObject  * </RETURNS>
GstMiniObject *mini_object
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_unref</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *mini_object
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_weak_ref</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *object, GstMiniObjectNotify notify, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_weak_unref</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *object, GstMiniObjectNotify notify, gpointer data
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_lock</NAME>
<RETURNS>gboolean         </RETURNS>
GstMiniObject *object, GstLockFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_unlock</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *object, GstLockFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_is_writable</NAME>
<RETURNS>gboolean         </RETURNS>
const GstMiniObject *mini_object
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_make_writable</NAME>
<RETURNS>GstMiniObject  * </RETURNS>
GstMiniObject *mini_object
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_copy</NAME>
<RETURNS>GstMiniObject  * </RETURNS>
const GstMiniObject *mini_object
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_set_qdata</NAME>
<RETURNS>void             </RETURNS>
GstMiniObject *object, GQuark quark, gpointer data, GDestroyNotify destroy
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_get_qdata</NAME>
<RETURNS>gpointer         </RETURNS>
GstMiniObject *object, GQuark quark
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_steal_qdata</NAME>
<RETURNS>gpointer         </RETURNS>
GstMiniObject *object, GQuark quark
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_replace</NAME>
<RETURNS>gboolean         </RETURNS>
GstMiniObject **olddata, GstMiniObject *newdata
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_take</NAME>
<RETURNS>gboolean         </RETURNS>
GstMiniObject **olddata, GstMiniObject *newdata
</FUNCTION>
<FUNCTION>
<NAME>gst_mini_object_steal</NAME>
<RETURNS>GstMiniObject  * </RETURNS>
GstMiniObject **olddata
</FUNCTION>
<MACRO>
<NAME>GST_DEFINE_MINI_OBJECT_TYPE</NAME>
#define GST_DEFINE_MINI_OBJECT_TYPE(TypeName,type_name) \
   G_DEFINE_BOXED_TYPE(TypeName,type_name,              \
       (GBoxedCopyFunc) gst_mini_object_ref,            \
       (GBoxedFreeFunc) gst_mini_object_unref)
</MACRO>
<MACRO>
<NAME>GST_TYPE_SEGMENT</NAME>
#define GST_TYPE_SEGMENT             (gst_segment_get_type())
</MACRO>
<ENUM>
<NAME>GstSeekType</NAME>
typedef enum {
  /* one of these */
  GST_SEEK_TYPE_NONE            = 0,
  GST_SEEK_TYPE_SET             = 1,
  GST_SEEK_TYPE_END             = 2
} GstSeekType;
</ENUM>
<ENUM>
<NAME>GstSeekFlags</NAME>
typedef enum {
  GST_SEEK_FLAG_NONE            = 0,
  GST_SEEK_FLAG_FLUSH           = (1 << 0),
  GST_SEEK_FLAG_ACCURATE        = (1 << 1),
  GST_SEEK_FLAG_KEY_UNIT        = (1 << 2),
  GST_SEEK_FLAG_SEGMENT         = (1 << 3),
  GST_SEEK_FLAG_TRICKMODE       = (1 << 4),
  /* FIXME 2.0: Remove _SKIP flag,
   * which was kept for backward compat when _TRICKMODE was added */
  GST_SEEK_FLAG_SKIP            = (1 << 4),
  GST_SEEK_FLAG_SNAP_BEFORE     = (1 << 5),
  GST_SEEK_FLAG_SNAP_AFTER      = (1 << 6),
  GST_SEEK_FLAG_SNAP_NEAREST    = GST_SEEK_FLAG_SNAP_BEFORE | GST_SEEK_FLAG_SNAP_AFTER,
  /* Careful to restart next flag with 1<<7 here */
  GST_SEEK_FLAG_TRICKMODE_KEY_UNITS = (1 << 7),
  GST_SEEK_FLAG_TRICKMODE_NO_AUDIO  = (1 << 8),
} GstSeekFlags;
</ENUM>
<ENUM>
<NAME>GstSegmentFlags</NAME>
typedef enum { /*< flags >*/
  GST_SEGMENT_FLAG_NONE            = GST_SEEK_FLAG_NONE,
  GST_SEGMENT_FLAG_RESET           = GST_SEEK_FLAG_FLUSH,
  GST_SEGMENT_FLAG_TRICKMODE       = GST_SEEK_FLAG_TRICKMODE,
  /* FIXME 2.0: Remove _SKIP flag,
   * which was kept for backward compat when _TRICKMODE was added */
  GST_SEGMENT_FLAG_SKIP            = GST_SEEK_FLAG_TRICKMODE,
  GST_SEGMENT_FLAG_SEGMENT         = GST_SEEK_FLAG_SEGMENT,
  GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS = GST_SEEK_FLAG_TRICKMODE_KEY_UNITS,
  GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO      = GST_SEEK_FLAG_TRICKMODE_NO_AUDIO
} GstSegmentFlags;
</ENUM>
<STRUCT>
<NAME>GstSegment</NAME>
struct _GstSegment {
  /*< public >*/
  GstSegmentFlags flags;

  gdouble         rate;
  gdouble         applied_rate;

  GstFormat       format;
  guint64         base;
  guint64         offset;
  guint64         start;
  guint64         stop;
  guint64         time;

  guint64         position;
  guint64         duration;

  /* < private > */
  gpointer        _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_segment_get_type</NAME>
<RETURNS>GType         </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_new</NAME>
<RETURNS>GstSegment  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_copy</NAME>
<RETURNS>GstSegment  * </RETURNS>
const GstSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_copy_into</NAME>
<RETURNS>void          </RETURNS>
const GstSegment *src, GstSegment *dest
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_free</NAME>
<RETURNS>void          </RETURNS>
GstSegment *segment
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_init</NAME>
<RETURNS>void          </RETURNS>
GstSegment *segment, GstFormat format
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_to_stream_time</NAME>
<RETURNS>guint64       </RETURNS>
const GstSegment *segment, GstFormat format, guint64 position
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_to_running_time</NAME>
<RETURNS>guint64       </RETURNS>
const GstSegment *segment, GstFormat format, guint64 position
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_to_running_time_full</NAME>
<RETURNS>gint          </RETURNS>
const GstSegment *segment, GstFormat format, guint64 position, guint64 * running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_to_position</NAME>
<RETURNS>guint64       </RETURNS>
const GstSegment *segment, GstFormat format, guint64 running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_set_running_time</NAME>
<RETURNS>gboolean      </RETURNS>
GstSegment *segment, GstFormat format, guint64 running_time
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_offset_running_time</NAME>
<RETURNS>gboolean      </RETURNS>
GstSegment *segment, GstFormat format, gint64 offset
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_clip</NAME>
<RETURNS>gboolean      </RETURNS>
const GstSegment *segment, GstFormat format, guint64 start, guint64 stop, guint64 *clip_start, guint64 *clip_stop
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_do_seek</NAME>
<RETURNS>gboolean      </RETURNS>
GstSegment * segment, gdouble rate, GstFormat format, GstSeekFlags flags, GstSeekType start_type, guint64 start, GstSeekType stop_type, guint64 stop, gboolean * update
</FUNCTION>
<FUNCTION>
<NAME>gst_segment_is_equal</NAME>
<RETURNS>gboolean      </RETURNS>
const GstSegment * s0, const GstSegment * s1
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_BUFFER</NAME>
#define GST_TYPE_BUFFER                         (_gst_buffer_type)
</MACRO>
<MACRO>
<NAME>GST_IS_BUFFER</NAME>
#define GST_IS_BUFFER(obj)                      (GST_IS_MINI_OBJECT_TYPE(obj, GST_TYPE_BUFFER))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_CAST</NAME>
#define GST_BUFFER_CAST(obj)                    ((GstBuffer *)(obj))
</MACRO>
<MACRO>
<NAME>GST_BUFFER</NAME>
#define GST_BUFFER(obj)                         (GST_BUFFER_CAST(obj))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_FLAGS</NAME>
#define GST_BUFFER_FLAGS(buf)                   GST_MINI_OBJECT_FLAGS(buf)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_FLAG_IS_SET</NAME>
#define GST_BUFFER_FLAG_IS_SET(buf,flag)        GST_MINI_OBJECT_FLAG_IS_SET (buf, flag)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_FLAG_SET</NAME>
#define GST_BUFFER_FLAG_SET(buf,flag)           GST_MINI_OBJECT_FLAG_SET (buf, flag)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_FLAG_UNSET</NAME>
#define GST_BUFFER_FLAG_UNSET(buf,flag)         GST_MINI_OBJECT_FLAG_UNSET (buf, flag)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_PTS</NAME>
#define GST_BUFFER_PTS(buf)                     (GST_BUFFER_CAST(buf)->pts)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_DTS</NAME>
#define GST_BUFFER_DTS(buf)                     (GST_BUFFER_CAST(buf)->dts)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_DURATION</NAME>
#define GST_BUFFER_DURATION(buf)                (GST_BUFFER_CAST(buf)->duration)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_OFFSET</NAME>
#define GST_BUFFER_OFFSET(buf)                  (GST_BUFFER_CAST(buf)->offset)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_OFFSET_END</NAME>
#define GST_BUFFER_OFFSET_END(buf)              (GST_BUFFER_CAST(buf)->offset_end)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_OFFSET_NONE</NAME>
#define GST_BUFFER_OFFSET_NONE  ((guint64)-1)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_DURATION_IS_VALID</NAME>
#define GST_BUFFER_DURATION_IS_VALID(buffer)    (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DURATION (buffer)))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_PTS_IS_VALID</NAME>
#define GST_BUFFER_PTS_IS_VALID(buffer)   (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_PTS (buffer)))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_DTS_IS_VALID</NAME>
#define GST_BUFFER_DTS_IS_VALID(buffer)   (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (buffer)))
</MACRO>
<MACRO>
<NAME>GST_BUFFER_OFFSET_IS_VALID</NAME>
#define GST_BUFFER_OFFSET_IS_VALID(buffer)      (GST_BUFFER_OFFSET (buffer) != GST_BUFFER_OFFSET_NONE)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_OFFSET_END_IS_VALID</NAME>
#define GST_BUFFER_OFFSET_END_IS_VALID(buffer)  (GST_BUFFER_OFFSET_END (buffer) != GST_BUFFER_OFFSET_NONE)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_IS_DISCONT</NAME>
#define GST_BUFFER_IS_DISCONT(buffer)   (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT))
</MACRO>
<ENUM>
<NAME>GstBufferFlags</NAME>
typedef enum {
  GST_BUFFER_FLAG_LIVE        = (GST_MINI_OBJECT_FLAG_LAST << 0),
  GST_BUFFER_FLAG_DECODE_ONLY = (GST_MINI_OBJECT_FLAG_LAST << 1),
  GST_BUFFER_FLAG_DISCONT     = (GST_MINI_OBJECT_FLAG_LAST << 2),
  GST_BUFFER_FLAG_RESYNC      = (GST_MINI_OBJECT_FLAG_LAST << 3),
  GST_BUFFER_FLAG_CORRUPTED   = (GST_MINI_OBJECT_FLAG_LAST << 4),
  GST_BUFFER_FLAG_MARKER      = (GST_MINI_OBJECT_FLAG_LAST << 5),
  GST_BUFFER_FLAG_HEADER      = (GST_MINI_OBJECT_FLAG_LAST << 6),
  GST_BUFFER_FLAG_GAP         = (GST_MINI_OBJECT_FLAG_LAST << 7),
  GST_BUFFER_FLAG_DROPPABLE   = (GST_MINI_OBJECT_FLAG_LAST << 8),
  GST_BUFFER_FLAG_DELTA_UNIT  = (GST_MINI_OBJECT_FLAG_LAST << 9),
  GST_BUFFER_FLAG_TAG_MEMORY  = (GST_MINI_OBJECT_FLAG_LAST << 10),
  GST_BUFFER_FLAG_SYNC_AFTER  = (GST_MINI_OBJECT_FLAG_LAST << 11),

  GST_BUFFER_FLAG_LAST        = (GST_MINI_OBJECT_FLAG_LAST << 16)
} GstBufferFlags;
</ENUM>
<STRUCT>
<NAME>GstBuffer</NAME>
struct _GstBuffer {
  GstMiniObject          mini_object;

  /*< public >*/ /* with COW */
  GstBufferPool         *pool;

  /* timestamp */
  GstClockTime           pts;
  GstClockTime           dts;
  GstClockTime           duration;

  /* media specific offset */
  guint64                offset;
  guint64                offset_end;
};
</STRUCT>
<FUNCTION>
<NAME>gst_buffer_get_type</NAME>
<RETURNS>GType        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_max_memory</NAME>
<RETURNS>guint        </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_new</NAME>
<RETURNS>GstBuffer  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_new_allocate</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstAllocator * allocator, gsize size, GstAllocationParams * params
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_new_wrapped_full</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstMemoryFlags flags, gpointer data, gsize maxsize, gsize offset, gsize size, gpointer user_data, GDestroyNotify notify
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_new_wrapped</NAME>
<RETURNS>GstBuffer  * </RETURNS>
gpointer data, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_n_memory</NAME>
<RETURNS>guint        </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_insert_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, gint idx, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_replace_memory_range</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, guint idx, gint length, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_peek_memory</NAME>
<RETURNS>GstMemory  * </RETURNS>
GstBuffer *buffer, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_memory_range</NAME>
<RETURNS>GstMemory  * </RETURNS>
GstBuffer *buffer, guint idx, gint length
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_remove_memory_range</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, guint idx, gint length
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_prepend_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_append_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_replace_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, guint idx, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_replace_all_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, GstMemory *mem
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_memory</NAME>
<RETURNS>GstMemory  * </RETURNS>
GstBuffer *buffer, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_all_memory</NAME>
<RETURNS>GstMemory  * </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_remove_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, guint idx
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_remove_all_memory</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_find_memory</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer, gsize offset, gsize size, guint *idx, guint *length, gsize *skip
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_is_memory_range_writable</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer, guint idx, gint length
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_is_all_memory_writable</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_fill</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer, gsize offset, gconstpointer src, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_extract</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer, gsize offset, gpointer dest, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_memcmp</NAME>
<RETURNS>gint         </RETURNS>
GstBuffer *buffer, gsize offset, gconstpointer mem, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_memset</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer, gsize offset, guint8 val, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_sizes_range</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer, guint idx, gint length, gsize *offset, gsize *maxsize
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_resize_range</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer, guint idx, gint length, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_sizes</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer, gsize *offset, gsize *maxsize
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_size</NAME>
<RETURNS>gsize        </RETURNS>
GstBuffer *buffer
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_resize</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_set_size</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_map_range</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer, guint idx, gint length, GstMapInfo *info, GstMapFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_map</NAME>
<RETURNS>gboolean     </RETURNS>
GstBuffer *buffer, GstMapInfo *info, GstMapFlags flags
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_unmap</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, GstMapInfo *info
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_extract_dup</NAME>
<RETURNS>void         </RETURNS>
GstBuffer *buffer, gsize offset, gsize size, gpointer *dest, gsize *dest_size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_ref</NAME>
<RETURNS>GstBuffer  * </RETURNS>
GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_unref</NAME>
<RETURNS>void  </RETURNS>
GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_copy</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const GstBuffer * buf
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_copy_deep</NAME>
<RETURNS>GstBuffer  * </RETURNS>
const GstBuffer * buf
</FUNCTION>
<ENUM>
<NAME>GstBufferCopyFlags</NAME>
typedef enum {
  GST_BUFFER_COPY_NONE           = 0,
  GST_BUFFER_COPY_FLAGS          = (1 << 0),
  GST_BUFFER_COPY_TIMESTAMPS     = (1 << 1),
  GST_BUFFER_COPY_META           = (1 << 2),
  GST_BUFFER_COPY_MEMORY         = (1 << 3),
  GST_BUFFER_COPY_MERGE          = (1 << 4),
  GST_BUFFER_COPY_DEEP           = (1 << 5)
} GstBufferCopyFlags;
</ENUM>
<MACRO>
<NAME>GST_BUFFER_COPY_METADATA</NAME>
#define GST_BUFFER_COPY_METADATA       (GST_BUFFER_COPY_FLAGS | GST_BUFFER_COPY_TIMESTAMPS |\
                                        GST_BUFFER_COPY_META)
</MACRO>
<MACRO>
<NAME>GST_BUFFER_COPY_ALL</NAME>
#define GST_BUFFER_COPY_ALL  ((GstBufferCopyFlags)(GST_BUFFER_COPY_METADATA | GST_BUFFER_COPY_MEMORY))
</MACRO>
<FUNCTION>
<NAME>gst_buffer_copy_into</NAME>
<RETURNS>gboolean         </RETURNS>
GstBuffer *dest, GstBuffer *src, GstBufferCopyFlags flags, gsize offset, gsize size
</FUNCTION>
<MACRO>
<NAME>gst_buffer_is_writable</NAME>
#define         gst_buffer_is_writable(buf)     gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (buf))
</MACRO>
<MACRO>
<NAME>gst_buffer_make_writable</NAME>
#define         gst_buffer_make_writable(buf)   GST_BUFFER_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (buf)))
</MACRO>
<FUNCTION>
<NAME>gst_buffer_replace</NAME>
<RETURNS>gboolean  </RETURNS>
GstBuffer **obuf, GstBuffer *nbuf
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_copy_region</NAME>
<RETURNS>GstBuffer *      </RETURNS>
GstBuffer *parent, GstBufferCopyFlags flags, gsize offset, gsize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_append_region</NAME>
<RETURNS>GstBuffer *      </RETURNS>
GstBuffer *buf1, GstBuffer *buf2, gssize offset, gssize size
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_append</NAME>
<RETURNS>GstBuffer *      </RETURNS>
GstBuffer *buf1, GstBuffer *buf2
</FUNCTION>
<USER_FUNCTION>
<NAME>GstBufferForeachMetaFunc</NAME>
<RETURNS>gboolean </RETURNS>
GstBuffer *buffer, GstMeta **meta,
                                                 gpointer user_data
</USER_FUNCTION>
<FUNCTION>
<NAME>gst_buffer_get_meta</NAME>
<RETURNS>GstMeta  *       </RETURNS>
GstBuffer *buffer, GType api
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_add_meta</NAME>
<RETURNS>GstMeta  *       </RETURNS>
GstBuffer *buffer, const GstMetaInfo *info, gpointer params
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_remove_meta</NAME>
<RETURNS>gboolean         </RETURNS>
GstBuffer *buffer, GstMeta *meta
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_iterate_meta</NAME>
<RETURNS>GstMeta  *       </RETURNS>
GstBuffer *buffer, gpointer *state
</FUNCTION>
<FUNCTION>
<NAME>gst_buffer_foreach_meta</NAME>
<RETURNS>gboolean         </RETURNS>
GstBuffer *buffer, GstBufferForeachMetaFunc func, gpointer user_data
</FUNCTION>
<MACRO>
<NAME>gst_value_set_buffer</NAME>
#define         gst_value_set_buffer(v,b)       g_value_set_boxed((v),(b))
</MACRO>
<MACRO>
<NAME>gst_value_take_buffer</NAME>
#define         gst_value_take_buffer(v,b)      g_value_take_boxed(v,(b))
</MACRO>
<MACRO>
<NAME>gst_value_get_buffer</NAME>
#define         gst_value_get_buffer(v)         GST_BUFFER_CAST (g_value_get_boxed(v))
</MACRO>
<STRUCT>
<NAME>GstParentBufferMeta</NAME>
struct _GstParentBufferMeta
{
  GstMeta parent;

  /*< public >*/
  GstBuffer *buffer;
};
</STRUCT>
<FUNCTION>
<NAME>gst_parent_buffer_meta_api_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_PARENT_BUFFER_META_API_TYPE</NAME>
#define GST_TYPE_PARENT_BUFFER_META_API_TYPE (gst_parent_buffer_meta_api_get_type())
</MACRO>
<MACRO>
<NAME>gst_buffer_get_parent_buffer_meta</NAME>
#define gst_buffer_get_parent_buffer_meta(b) \
  ((GstParentBufferMeta*)gst_buffer_get_meta((b),GST_PARENT_BUFFER_META_API_TYPE))
</MACRO>
<FUNCTION>
<NAME>gst_parent_buffer_meta_get_info</NAME>
<RETURNS>const GstMetaInfo  *</RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_PARENT_BUFFER_META_INFO</NAME>
#define GST_PARENT_BUFFER_META_INFO (gst_parent_buffer_meta_get_info())
</MACRO>
<FUNCTION>
<NAME>gst_buffer_add_parent_buffer_meta</NAME>
<RETURNS>GstParentBufferMeta  *</RETURNS>
GstBuffer *buffer, GstBuffer *ref
</FUNCTION>
<STRUCT>
<NAME>GstBufferPool</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TASK_POOL</NAME>
#define GST_TYPE_TASK_POOL             (gst_task_pool_get_type ())
</MACRO>
<MACRO>
<NAME>GST_TASK_POOL</NAME>
#define GST_TASK_POOL(pool)            (G_TYPE_CHECK_INSTANCE_CAST ((pool), GST_TYPE_TASK_POOL, GstTaskPool))
</MACRO>
<MACRO>
<NAME>GST_IS_TASK_POOL</NAME>
#define GST_IS_TASK_POOL(pool)         (G_TYPE_CHECK_INSTANCE_TYPE ((pool), GST_TYPE_TASK_POOL))
</MACRO>
<MACRO>
<NAME>GST_TASK_POOL_CLASS</NAME>
#define GST_TASK_POOL_CLASS(pclass)    (G_TYPE_CHECK_CLASS_CAST ((pclass), GST_TYPE_TASK_POOL, GstTaskPoolClass))
</MACRO>
<MACRO>
<NAME>GST_IS_TASK_POOL_CLASS</NAME>
#define GST_IS_TASK_POOL_CLASS(pclass) (G_TYPE_CHECK_CLASS_TYPE ((pclass), GST_TYPE_TASK_POOL))
</MACRO>
<MACRO>
<NAME>GST_TASK_POOL_GET_CLASS</NAME>
#define GST_TASK_POOL_GET_CLASS(pool)  (G_TYPE_INSTANCE_GET_CLASS ((pool), GST_TYPE_TASK_POOL, GstTaskPoolClass))
</MACRO>
<MACRO>
<NAME>GST_TASK_POOL_CAST</NAME>
#define GST_TASK_POOL_CAST(pool)       ((GstTaskPool*)(pool))
</MACRO>
<USER_FUNCTION>
<NAME>GstTaskPoolFunction</NAME>
<RETURNS>void </RETURNS>
void *user_data
</USER_FUNCTION>
<STRUCT>
<NAME>GstTaskPool</NAME>
struct _GstTaskPool {
  GstObject      object;

  /*< private >*/
  GThreadPool   *pool;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstTaskPoolClass</NAME>
struct _GstTaskPoolClass {
  GstObjectClass parent_class;

  /*< public >*/
  void      (*prepare)  (GstTaskPool *pool, GError **error);
  void      (*cleanup)  (GstTaskPool *pool);

  gpointer  (*push)     (GstTaskPool *pool, GstTaskPoolFunction func,
                         gpointer user_data, GError **error);
  void      (*join)     (GstTaskPool *pool, gpointer id);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_task_pool_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pool_new</NAME>
<RETURNS>GstTaskPool  *   </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pool_prepare</NAME>
<RETURNS>void             </RETURNS>
GstTaskPool *pool, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pool_push</NAME>
<RETURNS>gpointer         </RETURNS>
GstTaskPool *pool, GstTaskPoolFunction func, gpointer user_data, GError **error
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pool_join</NAME>
<RETURNS>void             </RETURNS>
GstTaskPool *pool, gpointer id
</FUNCTION>
<FUNCTION>
<NAME>gst_task_pool_cleanup</NAME>
<RETURNS>void 		</RETURNS>
GstTaskPool *pool
</FUNCTION>
<MACRO>
<NAME>GST_TYPE_CONTROL_SOURCE</NAME>
#define GST_TYPE_CONTROL_SOURCE \
  (gst_control_source_get_type())
</MACRO>
<MACRO>
<NAME>GST_CONTROL_SOURCE</NAME>
#define GST_CONTROL_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_CONTROL_SOURCE,GstControlSource))
</MACRO>
<MACRO>
<NAME>GST_CONTROL_SOURCE_CLASS</NAME>
#define GST_CONTROL_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_CONTROL_SOURCE,GstControlSourceClass))
</MACRO>
<MACRO>
<NAME>GST_IS_CONTROL_SOURCE</NAME>
#define GST_IS_CONTROL_SOURCE(obj) \
  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_CONTROL_SOURCE))
</MACRO>
<MACRO>
<NAME>GST_IS_CONTROL_SOURCE_CLASS</NAME>
#define GST_IS_CONTROL_SOURCE_CLASS(klass) \
  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_CONTROL_SOURCE))
</MACRO>
<MACRO>
<NAME>GST_CONTROL_SOURCE_GET_CLASS</NAME>
#define GST_CONTROL_SOURCE_GET_CLASS(obj) \
  (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_CONTOL_SOURCE, GstControlSourceClass))
</MACRO>
<STRUCT>
<NAME>GstTimedValue</NAME>
struct _GstTimedValue
{
  GstClockTime timestamp;
  gdouble      value;
};
</STRUCT>
<USER_FUNCTION>
<NAME>GstControlSourceGetValue</NAME>
<RETURNS>gboolean </RETURNS>
GstControlSource *self, 
    GstClockTime timestamp, gdouble *value
</USER_FUNCTION>
<USER_FUNCTION>
<NAME>GstControlSourceGetValueArray</NAME>
<RETURNS>gboolean </RETURNS>
GstControlSource *self, 
    GstClockTime timestamp, GstClockTime interval, guint n_values, gdouble *values
</USER_FUNCTION>
<STRUCT>
<NAME>GstControlSource</NAME>
struct _GstControlSource {
  GstObject parent;

  /*< public >*/
  GstControlSourceGetValue get_value;             /* Returns the value for a property at a given timestamp */
  GstControlSourceGetValueArray get_value_array;  /* Returns values for a property in a given timespan */

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstControlSourceClass</NAME>
struct _GstControlSourceClass
{
  GstObjectClass parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_control_source_get_type</NAME>
<RETURNS>GType  </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_control_source_get_value</NAME>
<RETURNS>gboolean        </RETURNS>
GstControlSource *self, GstClockTime timestamp, gdouble *value
</FUNCTION>
<FUNCTION>
<NAME>gst_control_source_get_value_array</NAME>
<RETURNS>gboolean        </RETURNS>
GstControlSource *self, GstClockTime timestamp, GstClockTime interval, guint n_values, gdouble *values
</FUNCTION>
<STRUCT>
<NAME>GstValueArray</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_SYSTEM_CLOCK</NAME>
#define GST_TYPE_SYSTEM_CLOCK                   (gst_system_clock_get_type ())
</MACRO>
<MACRO>
<NAME>GST_SYSTEM_CLOCK</NAME>
#define GST_SYSTEM_CLOCK(obj)                   (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_SYSTEM_CLOCK, GstSystemClock))
</MACRO>
<MACRO>
<NAME>GST_SYSTEM_CLOCK_CAST</NAME>
#define GST_SYSTEM_CLOCK_CAST(obj)              ((GstSystemClock *)(obj))
</MACRO>
<MACRO>
<NAME>GST_IS_SYSTEM_CLOCK</NAME>
#define GST_IS_SYSTEM_CLOCK(obj)                (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_SYSTEM_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_SYSTEM_CLOCK_CLASS</NAME>
#define GST_SYSTEM_CLOCK_CLASS(klass)           (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass))
</MACRO>
<MACRO>
<NAME>GST_IS_SYSTEM_CLOCK_CLASS</NAME>
#define GST_IS_SYSTEM_CLOCK_CLASS(klass)        (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_SYSTEM_CLOCK))
</MACRO>
<MACRO>
<NAME>GST_SYSTEM_CLOCK_GET_CLASS</NAME>
#define GST_SYSTEM_CLOCK_GET_CLASS(obj)         (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_SYSTEM_CLOCK, GstSystemClockClass))
</MACRO>
<ENUM>
<NAME>GstClockType</NAME>
typedef enum {
  GST_CLOCK_TYPE_REALTIME       = 0,
  GST_CLOCK_TYPE_MONOTONIC      = 1,
  GST_CLOCK_TYPE_OTHER          = 2
} GstClockType;
</ENUM>
<STRUCT>
<NAME>GstSystemClock</NAME>
struct _GstSystemClock {
  GstClock       clock;

  /*< private >*/
  GstSystemClockPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstSystemClockClass</NAME>
struct _GstSystemClockClass {
  GstClockClass  parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_system_clock_get_type</NAME>
<RETURNS>GType                    </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_system_clock_obtain</NAME>
<RETURNS>GstClock *               </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_system_clock_set_default</NAME>
<RETURNS>void                     </RETURNS>
GstClock *new_clock
</FUNCTION>
<STRUCT>
<NAME>GstSystemClockPrivate</NAME>
</STRUCT>
<FUNCTION>
<NAME>gst_parse_error_quark</NAME>
<RETURNS>GQuark  </RETURNS>
void
</FUNCTION>
<MACRO>
<NAME>GST_PARSE_ERROR</NAME>
#define GST_PARSE_ERROR gst_parse_error_quark ()
</MACRO>
<ENUM>
<NAME>GstParseError</NAME>
typedef enum
{
  GST_PARSE_ERROR_SYNTAX,
  GST_PARSE_ERROR_NO_SUCH_ELEMENT,
  GST_PARSE_ERROR_NO_SUCH_PROPERTY,
  GST_PARSE_ERROR_LINK,
  GST_PARSE_ERROR_COULD_NOT_SET_PROPERTY,
  GST_PARSE_ERROR_EMPTY_BIN,
  GST_PARSE_ERROR_EMPTY
} GstParseError;
</ENUM>
<ENUM>
<NAME>GstParseFlags</NAME>
typedef enum
{
  GST_PARSE_FLAG_NONE = 0,
  GST_PARSE_FLAG_FATAL_ERRORS = (1 << 0),
  GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS = (1 << 1)
} GstParseFlags;
</ENUM>
<MACRO>
<NAME>GST_TYPE_PARSE_CONTEXT</NAME>
#define GST_TYPE_PARSE_CONTEXT (gst_parse_context_get_type())
</MACRO>
<FUNCTION>
<NAME>gst_parse_context_get_type</NAME>
<RETURNS>GType              </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_context_new</NAME>
<RETURNS>GstParseContext  * </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_context_get_missing_elements</NAME>
<RETURNS>gchar           ** </RETURNS>
GstParseContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_context_free</NAME>
<RETURNS>void               </RETURNS>
GstParseContext * context
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_launch</NAME>
<RETURNS>GstElement       * </RETURNS>
const gchar      * pipeline_description, GError          ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_launchv</NAME>
<RETURNS>GstElement       * </RETURNS>
const gchar     ** argv, GError          ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_launch_full</NAME>
<RETURNS>GstElement       * </RETURNS>
const gchar      * pipeline_description, GstParseContext  * context, GstParseFlags      flags, GError          ** error
</FUNCTION>
<FUNCTION>
<NAME>gst_parse_launchv_full</NAME>
<RETURNS>GstElement       * </RETURNS>
const gchar     ** argv, GstParseContext  * context, GstParseFlags      flags, GError          ** error
</FUNCTION>
<STRUCT>
<NAME>GstParseContext</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_TOC</NAME>
#define GST_TYPE_TOC (_gst_toc_type)
</MACRO>
<MACRO>
<NAME>GST_TYPE_TOC_ENTRY</NAME>
#define GST_TYPE_TOC_ENTRY (_gst_toc_entry_type)
</MACRO>
<ENUM>
<NAME>GstTocScope</NAME>
typedef enum {
  GST_TOC_SCOPE_GLOBAL = 1,
  GST_TOC_SCOPE_CURRENT = 2
} GstTocScope;
</ENUM>
<ENUM>
<NAME>GstTocEntryType</NAME>
typedef enum {
  GST_TOC_ENTRY_TYPE_ANGLE       = -3,
  GST_TOC_ENTRY_TYPE_VERSION     = -2,
  GST_TOC_ENTRY_TYPE_EDITION     = -1,
  GST_TOC_ENTRY_TYPE_INVALID     = 0,
  GST_TOC_ENTRY_TYPE_TITLE       = 1,
  GST_TOC_ENTRY_TYPE_TRACK       = 2,
  GST_TOC_ENTRY_TYPE_CHAPTER     = 3,
} GstTocEntryType;
</ENUM>
<MACRO>
<NAME>GST_TOC_ENTRY_TYPE_IS_ALTERNATIVE</NAME>
#define GST_TOC_ENTRY_TYPE_IS_ALTERNATIVE(entry_type)  (entry_type < 0)
</MACRO>
<MACRO>
<NAME>GST_TOC_ENTRY_TYPE_IS_SEQUENCE</NAME>
#define GST_TOC_ENTRY_TYPE_IS_SEQUENCE(entry_type)     (entry_type > 0)
</MACRO>
<ENUM>
<NAME>GstTocLoopType</NAME>
typedef enum {
  GST_TOC_LOOP_NONE = 0,
  GST_TOC_LOOP_FORWARD,
  GST_TOC_LOOP_REVERSE,
  GST_TOC_LOOP_PING_PONG
} GstTocLoopType;
</ENUM>
<MACRO>
<NAME>GST_TOC_REPEAT_COUNT_INFINITE</NAME>
#define GST_TOC_REPEAT_COUNT_INFINITE (-1)
</MACRO>
<FUNCTION>
<NAME>gst_toc_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_new</NAME>
<RETURNS>GstToc  *           </RETURNS>
GstTocScope scope
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_get_scope</NAME>
<RETURNS>GstTocScope         </RETURNS>
const GstToc *toc
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_set_tags</NAME>
<RETURNS>void                </RETURNS>
GstToc *toc, GstTagList * tags
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_merge_tags</NAME>
<RETURNS>void                </RETURNS>
GstToc *toc, GstTagList *tags, GstTagMergeMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_get_tags</NAME>
<RETURNS>GstTagList  *       </RETURNS>
const GstToc *toc
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_append_entry</NAME>
<RETURNS>void                </RETURNS>
GstToc *toc, GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_get_entries</NAME>
<RETURNS>GList  *            </RETURNS>
const GstToc *toc
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_dump</NAME>
<RETURNS>void                </RETURNS>
GstToc *toc
</FUNCTION>
<MACRO>
<NAME>gst_toc_ref</NAME>
#define gst_toc_ref(toc)            (GstToc*)gst_mini_object_ref(GST_MINI_OBJECT_CAST(toc))
</MACRO>
<MACRO>
<NAME>gst_toc_unref</NAME>
#define gst_toc_unref(toc)          gst_mini_object_unref(GST_MINI_OBJECT_CAST(toc))
</MACRO>
<MACRO>
<NAME>gst_toc_copy</NAME>
#define gst_toc_copy(toc)           (GstToc*)gst_mini_object_copy(GST_MINI_OBJECT_CAST(toc))
</MACRO>
<MACRO>
<NAME>gst_toc_make_writable</NAME>
#define gst_toc_make_writable(toc)  (GstToc*)gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(toc))
</MACRO>
<FUNCTION>
<NAME>gst_toc_entry_new</NAME>
<RETURNS>GstTocEntry  *   </RETURNS>
GstTocEntryType type, const gchar *uid
</FUNCTION>
<MACRO>
<NAME>gst_toc_entry_ref</NAME>
#define gst_toc_entry_ref(entry)            (GstTocEntry*)gst_mini_object_ref(GST_MINI_OBJECT_CAST(entry))
</MACRO>
<MACRO>
<NAME>gst_toc_entry_unref</NAME>
#define gst_toc_entry_unref(entry)          gst_mini_object_unref(GST_MINI_OBJECT_CAST(entry))
</MACRO>
<MACRO>
<NAME>gst_toc_entry_copy</NAME>
#define gst_toc_entry_copy(entry)           (GstTocEntry*)gst_mini_object_copy(GST_MINI_OBJECT_CAST(entry))
</MACRO>
<MACRO>
<NAME>gst_toc_entry_make_writable</NAME>
#define gst_toc_entry_make_writable(entry)  (GstTocEntry*)gst_mini_object_make_writable(GST_MINI_OBJECT_CAST(entry))
</MACRO>
<FUNCTION>
<NAME>gst_toc_find_entry</NAME>
<RETURNS>GstTocEntry  *      </RETURNS>
const GstToc *toc, const gchar *uid
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_entry_type</NAME>
<RETURNS>GstTocEntryType     </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_uid</NAME>
<RETURNS>const gchar  *      </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_append_sub_entry</NAME>
<RETURNS>void                </RETURNS>
GstTocEntry *entry, GstTocEntry *subentry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_sub_entries</NAME>
<RETURNS>GList  *            </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_set_tags</NAME>
<RETURNS>void                </RETURNS>
GstTocEntry *entry, GstTagList *tags
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_merge_tags</NAME>
<RETURNS>void                </RETURNS>
GstTocEntry *entry, GstTagList *tags, GstTagMergeMode mode
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_tags</NAME>
<RETURNS>GstTagList  *       </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_is_alternative</NAME>
<RETURNS>gboolean            </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_is_sequence</NAME>
<RETURNS>gboolean            </RETURNS>
const GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_set_start_stop_times</NAME>
<RETURNS>void                </RETURNS>
GstTocEntry *entry, gint64 start, gint64 stop
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_start_stop_times</NAME>
<RETURNS>gboolean            </RETURNS>
const GstTocEntry *entry, gint64 *start, gint64 *stop
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_set_loop</NAME>
<RETURNS>void                </RETURNS>
GstTocEntry *entry, GstTocLoopType loop_type, gint repeat_count
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_loop</NAME>
<RETURNS>gboolean            </RETURNS>
const GstTocEntry *entry, GstTocLoopType *loop_type, gint *repeat_count
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_toc</NAME>
<RETURNS>GstToc  *           </RETURNS>
GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_get_parent</NAME>
<RETURNS>GstTocEntry  *      </RETURNS>
GstTocEntry *entry
</FUNCTION>
<FUNCTION>
<NAME>gst_toc_entry_type_get_nick</NAME>
<RETURNS>const gchar  *      </RETURNS>
GstTocEntryType type
</FUNCTION>
<STRUCT>
<NAME>GstToc</NAME>
</STRUCT>
<STRUCT>
<NAME>GstTocEntry</NAME>
</STRUCT>
<MACRO>
<NAME>GST_TYPE_PIPELINE</NAME>
#define GST_TYPE_PIPELINE               (gst_pipeline_get_type ())
</MACRO>
<MACRO>
<NAME>GST_PIPELINE</NAME>
#define GST_PIPELINE(obj)               (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_PIPELINE, GstPipeline))
</MACRO>
<MACRO>
<NAME>GST_IS_PIPELINE</NAME>
#define GST_IS_PIPELINE(obj)            (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GST_PIPELINE_CLASS</NAME>
#define GST_PIPELINE_CLASS(klass)       (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_PIPELINE, GstPipelineClass))
</MACRO>
<MACRO>
<NAME>GST_IS_PIPELINE_CLASS</NAME>
#define GST_IS_PIPELINE_CLASS(klass)    (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_PIPELINE))
</MACRO>
<MACRO>
<NAME>GST_PIPELINE_GET_CLASS</NAME>
#define GST_PIPELINE_GET_CLASS(obj)     (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_PIPELINE, GstPipelineClass))
</MACRO>
<MACRO>
<NAME>GST_PIPELINE_CAST</NAME>
#define GST_PIPELINE_CAST(obj)          ((GstPipeline*)(obj))
</MACRO>
<ENUM>
<NAME>GstPipelineFlags</NAME>
typedef enum {
  GST_PIPELINE_FLAG_FIXED_CLOCK        = (GST_BIN_FLAG_LAST << 0),
  /* padding */
  GST_PIPELINE_FLAG_LAST               = (GST_BIN_FLAG_LAST << 4)
} GstPipelineFlags;
</ENUM>
<STRUCT>
<NAME>GstPipeline</NAME>
struct _GstPipeline {
  GstBin         bin;

  /*< public >*/ /* with LOCK */
  GstClock      *fixed_clock;

  GstClockTime   stream_time;
  GstClockTime   delay;

  /*< private >*/
  GstPipelinePrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstPipelineClass</NAME>
struct _GstPipelineClass {
  GstBinClass parent_class;

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_pipeline_get_type</NAME>
<RETURNS>GType            </RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_new</NAME>
<RETURNS>GstElement *     </RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_bus</NAME>
<RETURNS>GstBus *         </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_use_clock</NAME>
<RETURNS>void             </RETURNS>
GstPipeline *pipeline, GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_set_clock</NAME>
<RETURNS>gboolean         </RETURNS>
GstPipeline *pipeline, GstClock *clock
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_clock</NAME>
<RETURNS>GstClock *       </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_pipeline_clock</NAME>
<RETURNS>GstClock *       </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_auto_clock</NAME>
<RETURNS>void             </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_set_delay</NAME>
<RETURNS>void             </RETURNS>
GstPipeline *pipeline, GstClockTime delay
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_delay</NAME>
<RETURNS>GstClockTime     </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_set_latency</NAME>
<RETURNS>void             </RETURNS>
GstPipeline *pipeline, GstClockTime latency
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_latency</NAME>
<RETURNS>GstClockTime     </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_set_auto_flush_bus</NAME>
<RETURNS>void             </RETURNS>
GstPipeline *pipeline, gboolean auto_flush
</FUNCTION>
<FUNCTION>
<NAME>gst_pipeline_get_auto_flush_bus</NAME>
<RETURNS>gboolean         </RETURNS>
GstPipeline *pipeline
</FUNCTION>
<STRUCT>
<NAME>GstPipelinePrivate</NAME>
</STRUCT>
<ENUM>
<NAME>GstAllocTraceFlags</NAME>
typedef enum {
  GST_ALLOC_TRACE_NONE      = 0,
  GST_ALLOC_TRACE_LIVE      = (1 << 0),
  GST_ALLOC_TRACE_MEM_LIVE  = (1 << 1)
} GstAllocTraceFlags;
</ENUM>
<STRUCT>
<NAME>GstAllocTrace</NAME>
struct _GstAllocTrace {
  gchar         *name;
  gint           flags;

  goffset        offset;
  gint           live;
  GSList        *mem_live;
};
</STRUCT>
<MACRO>
<NAME>GST_TYPE_BIN</NAME>
#define GST_TYPE_BIN             (gst_bin_get_type ())
</MACRO>
<MACRO>
<NAME>GST_IS_BIN</NAME>
#define GST_IS_BIN(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), GST_TYPE_BIN))
</MACRO>
<MACRO>
<NAME>GST_IS_BIN_CLASS</NAME>
#define GST_IS_BIN_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), GST_TYPE_BIN))
</MACRO>
<MACRO>
<NAME>GST_BIN_GET_CLASS</NAME>
#define GST_BIN_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_BIN, GstBinClass))
</MACRO>
<MACRO>
<NAME>GST_BIN</NAME>
#define GST_BIN(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), GST_TYPE_BIN, GstBin))
</MACRO>
<MACRO>
<NAME>GST_BIN_CLASS</NAME>
#define GST_BIN_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), GST_TYPE_BIN, GstBinClass))
</MACRO>
<MACRO>
<NAME>GST_BIN_CAST</NAME>
#define GST_BIN_CAST(obj)        ((GstBin*)(obj))
</MACRO>
<ENUM>
<NAME>GstBinFlags</NAME>
typedef enum {
  GST_BIN_FLAG_NO_RESYNC	= (GST_ELEMENT_FLAG_LAST << 0),
  /* padding */
  GST_BIN_FLAG_LAST		= (GST_ELEMENT_FLAG_LAST << 5)
} GstBinFlags;
</ENUM>
<MACRO>
<NAME>GST_BIN_IS_NO_RESYNC</NAME>
#define GST_BIN_IS_NO_RESYNC(bin)        (GST_OBJECT_FLAG_IS_SET(bin,GST_BIN_FLAG_NO_RESYNC))
</MACRO>
<MACRO>
<NAME>GST_BIN_NUMCHILDREN</NAME>
#define GST_BIN_NUMCHILDREN(bin)	(GST_BIN_CAST(bin)->numchildren)
</MACRO>
<MACRO>
<NAME>GST_BIN_CHILDREN</NAME>
#define GST_BIN_CHILDREN(bin)		(GST_BIN_CAST(bin)->children)
</MACRO>
<MACRO>
<NAME>GST_BIN_CHILDREN_COOKIE</NAME>
#define GST_BIN_CHILDREN_COOKIE(bin)	(GST_BIN_CAST(bin)->children_cookie)
</MACRO>
<STRUCT>
<NAME>GstBin</NAME>
struct _GstBin {
  GstElement	 element;

  /*< public >*/ /* with LOCK */
  /* our children, subclass are supposed to update these
   * fields to reflect their state with _iterate_*() */
  gint		 numchildren;
  GList		*children;
  guint32	 children_cookie;

  GstBus        *child_bus;
  GList         *messages;

  gboolean	 polling;
  gboolean       state_dirty;

  gboolean       clock_dirty;
  GstClock	*provided_clock;
  GstElement    *clock_provider;

  /*< private >*/
  GstBinPrivate *priv;

  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<STRUCT>
<NAME>GstBinClass</NAME>
struct _GstBinClass {
  GstElementClass parent_class;

  /*< private >*/
  GThreadPool  *pool;

  /* signals */
  void		(*element_added)	(GstBin *bin, GstElement *child);
  void		(*element_removed)	(GstBin *bin, GstElement *child);

  /*< public >*/
  /* virtual methods for subclasses */
  gboolean	(*add_element)		(GstBin *bin, GstElement *element);
  gboolean	(*remove_element)	(GstBin *bin, GstElement *element);

  void		(*handle_message)	(GstBin *bin, GstMessage *message);

  /*< private >*/
  /* signal */
  gboolean	(*do_latency)           (GstBin *bin);

  /*< private >*/
  gpointer _gst_reserved[GST_PADDING];
};
</STRUCT>
<FUNCTION>
<NAME>gst_bin_get_type</NAME>
<RETURNS>GType 		</RETURNS>
void
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_new</NAME>
<RETURNS>GstElement *	</RETURNS>
const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_add</NAME>
<RETURNS>gboolean 	</RETURNS>
GstBin *bin, GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_remove</NAME>
<RETURNS>gboolean 	</RETURNS>
GstBin *bin, GstElement *element
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_get_by_name</NAME>
<RETURNS>GstElement *	</RETURNS>
GstBin *bin, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_get_by_name_recurse_up</NAME>
<RETURNS>GstElement *	</RETURNS>
GstBin *bin, const gchar *name
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_get_by_interface</NAME>
<RETURNS>GstElement *	</RETURNS>
GstBin *bin, GType iface
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_elements</NAME>
<RETURNS>GstIterator *    </RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_sorted</NAME>
<RETURNS>GstIterator *    </RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_recurse</NAME>
<RETURNS>GstIterator *    </RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_sinks</NAME>
<RETURNS>GstIterator *	</RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_sources</NAME>
<RETURNS>GstIterator *	</RETURNS>
GstBin *bin
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_iterate_all_by_interface</NAME>
<RETURNS>GstIterator *	</RETURNS>
GstBin *bin, GType iface
</FUNCTION>
<FUNCTION>
<NAME>gst_bin_recalculate_latency</NAME>
<RETURNS>gboolean         </RETURNS>
GstBin * bin
</FUNCTION>
<STRUCT>
<NAME>GstBinPrivate</NAME>
</STRUCT>
<MACRO>
<NAME>asnprintf</NAME>
#define asnprintf        __gst_asnprintf
</MACRO>
<MACRO>
<NAME>vasnprintf</NAME>
#define vasnprintf       __gst_vasnprintf
</MACRO>
<MACRO>
<NAME>printf_parse</NAME>
#define printf_parse     __gst_printf_parse
</MACRO>
<MACRO>
<NAME>printf_fetchargs</NAME>
#define printf_fetchargs __gst_printf_fetchargs
</MACRO>
<MACRO>
<NAME>malloc</NAME>
#define malloc  g_malloc
</MACRO>
<MACRO>
<NAME>realloc</NAME>
#define realloc g_realloc
</MACRO>
<MACRO>
<NAME>free</NAME>
#define free    g_free
</MACRO>
<MACRO>
<NAME>HAVE_INT64_AND_I64</NAME>
#define HAVE_INT64_AND_I64 1
</MACRO>
<MACRO>
<NAME>HAVE_INTMAX_T</NAME>
#define HAVE_INTMAX_T 1
</MACRO>
<MACRO>
<NAME>POINTER_EXT_SIGNIFIER_CHAR</NAME>
#define POINTER_EXT_SIGNIFIER_CHAR '\a'
</MACRO>
<ENUM>
<NAME>arg_type</NAME>
typedef enum
{
  TYPE_NONE,
  TYPE_SCHAR,
  TYPE_UCHAR,
  TYPE_SHORT,
  TYPE_USHORT,
  TYPE_INT,
  TYPE_UINT,
  TYPE_LONGINT,
  TYPE_ULONGINT,
#ifdef HAVE_LONG_LONG
  TYPE_LONGLONGINT,
  TYPE_ULONGLONGINT,
#endif
#ifdef HAVE_INT64_AND_I64
  TYPE_INT64,
  TYPE_UINT64,
#endif
  TYPE_DOUBLE,
#ifdef HAVE_LONG_DOUBLE
  TYPE_LONGDOUBLE,
#endif
  TYPE_CHAR,
#ifdef HAVE_WINT_T
  TYPE_WIDE_CHAR,
#endif
  TYPE_STRING,
#ifdef HAVE_WCHAR_T
  TYPE_WIDE_STRING,
#endif
  TYPE_POINTER,
  TYPE_POINTER_EXT,
  TYPE_COUNT_SCHAR_POINTER,
  TYPE_COUNT_SHORT_POINTER,
  TYPE_COUNT_INT_POINTER,
  TYPE_COUNT_LONGINT_POINTER
#ifdef HAVE_LONG_LONG
, TYPE_COUNT_LONGLONGINT_POINTER
#endif
} arg_type;
</ENUM>
<FUNCTION>
<NAME>printf_fetchargs</NAME>
<RETURNS>int  </RETURNS>
va_list args, arguments *a
</FUNCTION>
<USER_FUNCTION>
<NAME>PrintfPointerExtensionFunc</NAME>
<RETURNS>char *</RETURNS>
const char * format, void * ptr
</USER_FUNCTION>
<FUNCTION>
<NAME>asnprintf</NAME>
<RETURNS>char  * </RETURNS>
char *resultbuf, size_t *lengthp, const char *format, ...
</FUNCTION>
<FUNCTION>
<NAME>vasnprintf</NAME>
<RETURNS>char  * </RETURNS>
char *resultbuf, size_t *lengthp, const char *format, va_list args
</FUNCTION>
<MACRO>
<NAME>printf_parse</NAME>
#define printf_parse __gst_printf_parse
</MACRO>
<MACRO>
<NAME>FLAG_GROUP</NAME>
#define FLAG_GROUP	 1	/* ' flag */
</MACRO>
<MACRO>
<NAME>FLAG_LEFT</NAME>
#define FLAG_LEFT	 2	/* - flag */
</MACRO>
<MACRO>
<NAME>FLAG_SHOWSIGN</NAME>
#define FLAG_SHOWSIGN	 4	/* + flag */
</MACRO>
<MACRO>
<NAME>FLAG_SPACE</NAME>
#define FLAG_SPACE	 8	/* space flag */
</MACRO>
<MACRO>
<NAME>FLAG_ALT</NAME>
#define FLAG_ALT	16	/* # flag */
</MACRO>
<MACRO>
<NAME>FLAG_ZERO</NAME>
#define FLAG_ZERO	32
</MACRO>
<MACRO>
<NAME>FLAG_PTR_EXT</NAME>
#define FLAG_PTR_EXT 1024
</MACRO>
<MACRO>
<NAME>priv_gst_parse_yyIN_HEADER</NAME>
#define priv_gst_parse_yyIN_HEADER 1
</MACRO>
<MACRO>
<NAME>YY_INT_ALIGNED</NAME>
#define  YY_INT_ALIGNED short int
</MACRO>
<MACRO>
<NAME>FLEX_SCANNER</NAME>
#define FLEX_SCANNER
</MACRO>
<MACRO>
<NAME>YY_FLEX_MAJOR_VERSION</NAME>
#define YY_FLEX_MAJOR_VERSION 2
</MACRO>
<MACRO>
<NAME>YY_FLEX_MINOR_VERSION</NAME>
#define YY_FLEX_MINOR_VERSION 6
</MACRO>
<MACRO>
<NAME>YY_FLEX_SUBMINOR_VERSION</NAME>
#define YY_FLEX_SUBMINOR_VERSION 0
</MACRO>
<MACRO>
<NAME>FLEX_BETA</NAME>
#define FLEX_BETA
</MACRO>
<MACRO>
<NAME>FLEXINT_H</NAME>
#define FLEXINT_H
</MACRO>
<TYPEDEF>
<NAME>flex_int8_t</NAME>
typedef int8_t flex_int8_t;
</TYPEDEF>
<TYPEDEF>
<NAME>flex_uint8_t</NAME>
typedef uint8_t flex_uint8_t;
</TYPEDEF>
<TYPEDEF>
<NAME>flex_int16_t</NAME>
typedef int16_t flex_int16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>flex_uint16_t</NAME>
typedef uint16_t flex_uint16_t;
</TYPEDEF>
<TYPEDEF>
<NAME>flex_int32_t</NAME>
typedef int32_t flex_int32_t;
</TYPEDEF>
<TYPEDEF>
<NAME>flex_uint32_t</NAME>
typedef uint32_t flex_uint32_t;
</TYPEDEF>
<MACRO>
<NAME>INT8_MIN</NAME>
#define INT8_MIN               (-128)
</MACRO>
<MACRO>
<NAME>INT16_MIN</NAME>
#define INT16_MIN              (-32767-1)
</MACRO>
<MACRO>
<NAME>INT32_MIN</NAME>
#define INT32_MIN              (-2147483647-1)
</MACRO>
<MACRO>
<NAME>INT8_MAX</NAME>
#define INT8_MAX               (127)
</MACRO>
<MACRO>
<NAME>INT16_MAX</NAME>
#define INT16_MAX              (32767)
</MACRO>
<MACRO>
<NAME>INT32_MAX</NAME>
#define INT32_MAX              (2147483647)
</MACRO>
<MACRO>
<NAME>UINT8_MAX</NAME>
#define UINT8_MAX              (255U)
</MACRO>
<MACRO>
<NAME>UINT16_MAX</NAME>
#define UINT16_MAX             (65535U)
</MACRO>
<MACRO>
<NAME>UINT32_MAX</NAME>
#define UINT32_MAX             (4294967295U)
</MACRO>
<MACRO>
<NAME>YY_USE_CONST</NAME>
#define YY_USE_CONST
</MACRO>
<MACRO>
<NAME>yyconst</NAME>
#define yyconst const
</MACRO>
<MACRO>
<NAME>YY_TYPEDEF_YY_SCANNER_T</NAME>
#define YY_TYPEDEF_YY_SCANNER_T
</MACRO>
<TYPEDEF>
<NAME>yyscan_t</NAME>
typedef void* yyscan_t;
</TYPEDEF>
<MACRO>
<NAME>yyin</NAME>
#define yyin yyg->yyin_r
</MACRO>
<MACRO>
<NAME>yyout</NAME>
#define yyout yyg->yyout_r
</MACRO>
<MACRO>
<NAME>yyextra</NAME>
#define yyextra yyg->yyextra_r
</MACRO>
<MACRO>
<NAME>yyleng</NAME>
#define yyleng yyg->yyleng_r
</MACRO>
<MACRO>
<NAME>yytext</NAME>
#define yytext yyg->yytext_r
</MACRO>
<MACRO>
<NAME>yylineno</NAME>
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
</MACRO>
<MACRO>
<NAME>yycolumn</NAME>
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
</MACRO>
<MACRO>
<NAME>yy_flex_debug</NAME>
#define yy_flex_debug yyg->yy_flex_debug_r
</MACRO>
<MACRO>
<NAME>YY_BUF_SIZE</NAME>
#define YY_BUF_SIZE 32768
</MACRO>
<MACRO>
<NAME>YY_TYPEDEF_YY_BUFFER_STATE</NAME>
#define YY_TYPEDEF_YY_BUFFER_STATE
</MACRO>
<TYPEDEF>
<NAME>YY_BUFFER_STATE</NAME>
typedef struct yy_buffer_state *YY_BUFFER_STATE;
</TYPEDEF>
<MACRO>
<NAME>YY_TYPEDEF_YY_SIZE_T</NAME>
#define YY_TYPEDEF_YY_SIZE_T
</MACRO>
<TYPEDEF>
<NAME>yy_size_t</NAME>
typedef size_t yy_size_t;
</TYPEDEF>
<MACRO>
<NAME>YY_STRUCT_YY_BUFFER_STATE</NAME>
#define YY_STRUCT_YY_BUFFER_STATE
</MACRO>
